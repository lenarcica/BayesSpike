\name{AutomaticQuantiles}
\alias{AutomaticQuantiles}
\alias{automaticquantiles}
\alias{quantiles}
\alias{Quantiles}
\alias{automaticQuantiles}
\alias{SymmetricQuantiles}
\alias{HPDQuantiles}
\alias{BetaSymmetricConfidenceMatrix}
\alias{BetaSymmetricQuantiles}
\alias{BetasymmetricQuantiles}
\alias{betaSymmetricQuantiles}
\alias{betaSymmetricUnshrinkQuantiles}
\alias{betaSymmetricUnshrunkQuantiles}
\alias{BetaSymmetricUnshrinkQuantiles}
\alias{BetaSymmetricUnshrunkQuantiles}
\alias{BetaHPDUnshrinkQuantiles}
\alias{BetaHPDUnshrunkQuantiles}
\alias{BetaQuantiles}
\alias{betaQuantiles}
\alias{QuantilesBeta}
\alias{BetaHPDQuantiles}
\alias{betaHPDQuantiles}
\alias{Betahpdquantiles}
\alias{BetaHpdQuantiles}
\alias{betaHpdQuantiles}
\alias{TauSymmetricQuantiles}
\alias{TausymmetricQuantiles}
\alias{tauSymmetricQuantiles}
\alias{TauQuantiles}
\alias{tauQuantiles}
\alias{QuantilesTau}
\alias{TauHPDQuantiles}
\alias{tauHPDQuantiles}
\alias{Tauhpdquantiles}
\alias{TauHpdQuantiles}
\alias{tauHpdQuantiles}
\alias{PiASymmetricQuantiles}
\alias{piasymmetricQuantiles}
\alias{piASymmetricQuantiles}
\alias{PiAQuantiles}
\alias{piAQuantiles}
\alias{QuantilesPiA}
\alias{PiAHPDQuantiles}
\alias{piaHPDQuantiles}
\alias{PiAhpdquantiles}
\alias{PiAHpdQuantiles}
\alias{piAHpdQuantiles}
\alias{SigmaSymmetricQuantiles}
\alias{SigmasymmetricQuantiles}
\alias{sigmaSymmetricQuantiles}
\alias{sigmaQuantiles}
\alias{sigmaQuantiles}
\alias{QuantilesSigma}
\alias{SigmaHPDQuantiles}
\alias{sigmaHPDQuantiles}
\alias{Sigmahpdquantiles}
\alias{SigmaHpdQuantiles}
\alias{SigmaHpdQuantiles}
\alias{SigSymmetricQuantiles}
\alias{sigSymmetricQuantiles}
\alias{SigHPDQuantiles}
\alias{SighpdQuantiles}
\alias{KeepPosteriorQuantiles}
\alias{keepPosteriorQuantiles}
\alias{KeepQuantiles}
\alias{keepquantiles}
\alias{keepposteriorquantiles}
\alias{Keepposteriorquantiles}
\alias{KeepposteriorQuantiles}
\alias{ConfidenceQuantiles}
\alias{confidencequantiles}
\alias{KeepPostQuantiles}
\alias{keepPostQuantiles}
\alias{BetaSymmetricLongQuantiles}
\alias{BetaHPDLongQuantiles}
\alias{BetaSymmetricLongConfidenceMatrix}
\alias{DoLogitPostProb}
\alias{DoLogitPreProb}
\alias{DoLogitNonePostPreProb}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{Marginal Posterior Quantiles of Draws}
\description{

   Generte Quantiles (Symmetric and HPD based) for the Coda sequences generated by the algorithm.
   
   
   The package genreates \link[coda]{mcmc} formatted chains for Bayesian 
   posterior inference and plotting.   This automatically retrieves chains and
   then summarizes with the posterior quantiles stored in \code{\link{BayesSpikeR5}}
   object member \code{.KeepPosteriorQuantiles}.  Note "KeepPosteriorQuantiles"
   is a vector.  By default, first member is ".5" for the median.  Then
   it is default assigned:
   \code{.KeepPosteriorQuantiles <- c(.5, .25,.75, .05,95,.025,.975,.01,.99);}
   
   
   
   These are loaded from saved hard disk compact files.
   
   BetaSymmetricQuantiles: refers to regular quantiles of Beta parameter draws
   BetaHPDQuantiles: refers to HPD quantile intervals.  Difference between HPD (High Posterior Density)
   and Symmetric intervals is that symmetric intervals are the marginal quantiles of the posterior,
   (so .025, .975 with .025 posterior probability on each side), determined by the user.
   In contrast, an HPD interval need not take the center of the posterior probability, it takes the shortest
   contiguous region with high posterior probability that covers (1-alpha) of the posterior.
   This could be the whole left side of the posterior, or the whole right side.  It is guaranteed
   to be shorter in length than the symmetric interval.
   
   BetaSymmetricUnshrinkQuantiles, BetaHPDUnshrinkQuantiles: Quantiles without near zero shrinkage.  
     These have better frequency confidence for when true parameters are near zero.
   
   TauSymmetricQuantiles, TauHPDQuantiles: refers to Tau parameter draws
   
   PiASymmetricQuantiles, PiAHPDQuantiles: refers to PiA parameter draws

   SigmaSymmetricQuantiles, SigmaHPDQuantiles: refers to Tau parameter draws
   
}
\usage{
BayesSpikeRegression <- function(X=NULL,Y=NULL, BetaStart = NULL,
  IndexFirstRandomEffect = 1, tauEndList=NULL,
  tauStartValues = NULL, PiAStart = .5, dfTauStart = -1, MStart = -1,
  dfTNoise = 0, Verbose = 0,
  DependenciesTau = NULL, DependenciesFixed=NULL,
  DoMax = 1, 
  PiAPrior = c(-1,-1), HowSample = 3,
  NumSpliceSampleReps = 5, SpliceMove= 1, CauchyEpsilon = .00001,
  MyPS = BayesSpike:::PriorStructure(.5,1),  tauFixed = 40,
  TypeFixedPrior = 1, DoRNGState = 1,
  SigmaPrior = c(2,1), InitKKs = 0, DoRecord = c(0,0,0,0,0,0,0),
  NumSamples = 1000, MaxIters = 1000, MaxGibbsIters = 1000,
  MaximizeMeCauchyTotalIters = 100,
  ttStart = 0,  NumChains = 3,
  EarlyEndStep = -1, EarlyEndtt = -1, FileSave = "MyS",
  SaveDir = .DefaultFileDir,  FileName = "ABSChain",
  NewWrite = 1, tauPriordf = 1, tauPriorMean = 1, 
  PutRNG = TRUE, Run = TRUE,
  CodaTableNames = NULL, OnChainIter = 1, RStart = 3,
  NoNoiseBetaStart = FALSE, AFD = NULL, NoShrinkVariables = NULL,
  NoShrinkTau =NULL, StartRunProbVector = -100,
  PriorProbFixed=NULL, PriorProbTau = NULL, dfRobit = -1, TemperatureList = NULL,
  burnin = NULL, EEMergeEvery = NULL, DoEEProbSort = 0, 
  EEProbSortWidth = -1, PrintIter = 200, DoLogitPostProb = FALSE, DoLogitPreProb=FALSE, ...)
}
%- maybe also 'usage' for other objects documented here.
\arguments{

  \item{KeepPosteriorQuantiles}{Member of \code{\link{BayesSpikeR5}} object.  
    Set to determine what intervals are recorded.  Numbers should be within \code{[0,1]} }


}
\details{
   All sub coda elements, like \code{SubCodaList}, are accessible elements of \code{\link{BayesSpikeCpp}} object as
   well as \code{\link{BayesSpikeR5}} objects.  They are in \link[coda]{mcmc.list} format.
   
   This is implemented as a \code{\link{BayesSpikeR5}} accessible object.  To generate from
   a \code{\link{BayesSpikeCpp}} simply use {\code{MyBayesSpikeSppOb$TSR5$BetaSymmetricQuantiles}},
    etc.
 
   By default, \code{\link{BayesSpikeRegression}()} does not record
   Gibbs sampler chains in RAM memory at all, instead writing to file buffers using
   \code{\link{SaveDir}}.  If directories are provided, this will write all draw information.
   
   Accessing these members causes the object to load these in from harddrive.
}
\value{

   \item{\code{SubCodaList}}{Is a mcmc.list of Beta Vector Draws (potentially smaller than
    all p draws if \code{SubSetCoords} is set).}
   \item{\code{TauCodaList}}{Is a mcmc.list of Tau Vector Draws (potentially smaller than
    all RandomEffects draws if \code{SubSetTau} is set).}
  \item{\code{PiACodaList}}{ Is mcmc.list of \eqn{\boldsymbol{\pi}^2_{
    \mbox{\tiny{$\mathcal{A}$}}} }{piA^2}  Draws}
  \item{\code{SigmaCodaList}}{ Is mcmc.list of \eqn{\sigma^2}{sigma^2}  Draws}
  \item{\code{YCodaList}}{ Is mcmc.list of Y draws.  Only valid for Logistic regression draws of Y}
  \item{\code{WeightCodaList}}{Is mcmc.list of weight draws.  Useful in logistic regression and t regression}
  \item{\code{ProbCodaList}}{Posterior Probability Draws}
  \item{DoLongCI}{To save Long Intervals, and get BetaSymmetricLongQuantiles and BetaHPDLongQuantiles,
  this must be true in \code{\link{BayesSpikeRegression}} call.
    The "Long" Buffer is a storage of gibbs samples that are all non-zero for all p Beta coefficients
    This can only be saved on a file (Not stored in Coda List even if DoRecord[1] == 1).  This draws a nonzero
    Beta_j even if sampler itself drew a zero Beta_j.  This is used for robust confidence intervals for
    coefficients near zero.  These confidence intervals are overly wide, though they benefit from shrinkage on the other coefficients.
    See \code{\link{SubCodaList}} for more details, as well as \code{\link{BetaSymmetricLongQuantiles}}
    }
  \item{CpBuffLongCI}{Integer, input to \code{\link{BayesSpikeRegression}}, How long should Long (No shrinkage to Zero) Buffer should be of size}
  \item{DoLogitPostProb}{Attempts to match Logistic data with a Gaussian distribution and generate alternate Importance sampling weights afterwards}
  \item{DoLogitPreProb}{Attempts to match Logistic data with a Robit distribution (slower) and generate alternative Importance sampling}
    
   This information can rapidly clog memory, so saving to compressed files with 
   \code{\link{SaveDir}} is considered a valuable alternative when \eqn{p}{p}
   is large.  In this case, the option of using \code{\link{ReturnSubCodaFromFiles}} must be used, which requires a user to choose a subset
   of paramters to reload.  

    \code{\link{BayesSpikeRegression}} serves as a wrapper function to write and read these files.
    Setting \code{NewWrite=0} will by default set \code{\link{BayesSpike}} to attempt to read currently written
    files rather than start new chains.  If the files are only half written, then BayesSpike
    will read in current chains and attempt to append until the chains are finished.
    If chains are fully finished, \code{\link{BayesSpikeRegression}} will simply read in the files.

}
\references{ Diallel Paper, pending BayesSpike submission }
\author{ Alan Lenarcic, Will Valdar }
\note{ 
  "TBSRoo"  is a class using R.oo which we would like to deprecate in favor of 
  an R5 class, "\code{\link{TBSR5}}"  or "\code{\link{BayesSpikeR5}}" is  the R5 storage class.
}
\seealso{ \code{\link{BayesSpikeRegression}}, \code{\link{BayesSpikeFromAutoDiallel}}, 
  \code{\link{BayesDiallel}}, \code{\link{coda}},
  \code{\link{Rcpp}}, \code{\link{R.oo}}, \code{\link{methods::ReferenceClasses}},
  \code{\link{SubCodaList}}, \code{\link{CodaList}}
  }
\examples{

library(BayesSpike);
try(require(lattice, quietly=TRUE, warn.conflicts=FALSE), silent=TRUE);
try(require(coda, quietly=TRUE, warn.conflicts=FALSE), silent=TRUE);
try(require(R.methodsS3, quietly=TRUE, warn.conflicts=FALSE), silent=TRUE);
try(require(R.oo, quietly=TRUE, warn.conflicts=FALSE), silent=TRUE);
try(require(corpcor, quietly=TRUE, warn.conflicts=FALSE), silent=TRUE);
require(BayesDiallel, quietly = TRUE, warn.conflicts=FALSE);
require(R.oo, warn.conflicts=FALSE, quietly=TRUE);

 try(library(AlanDirectories), silent=TRUE)
 try(AlanDirectores:::SetSaveHomes(),silent=TRUE);
 try(SetSaveHomes());
 SaveDir = BSSaveDir;  ## Save Dir set by default, or set to ones own accessible harddrive space.
  
  NewWrite = 1; dfRobit = 7; dfRobit = -1;
  nop = 4; NoTau = 0;
  if (NoTau == 0) {
    FirstRandom =5 + nop+1; tauEndList = FirstRandom + c(7,14,22,28);
    CFirstRandom = FirstRandom -1;  CtauEndList = tauEndList -1;
    PiAPrior = c(5, nop, 10,10); PiAStart = c(5/(nop+5), 10/20); 
  } else {
    FirstRandom = -1;  tauEndList = NULL; CFirstRandom = -1; CtauEndList = NULL;
    PiAPrior = c(15, nop+10);  PiAStart = c(15 / (nop+25));
  }
  if (dfRobit >= 0) {
    n = 500;
    Sigma = 3;
  } else {
    n= 60;
    Sigma = 6;
  }
  dfTNoise = -1; ##dfTNoise = 30;  #dfTNoise = 0;
  Beta = 2*c(15,-15,0,15,15,rep(0,nop),-7,4,-9,12,-3,5,-4,.3, 0,0,0,0,0,0,0,4,-5,-6,7,-4,-2,1,.75,0,0,0,0,0,0);
  Beta = Beta / 5;

  SaveDir = paste(SaveDir, "//n", n, "p", length(Beta),  "dfR", dfRobit,
    "tEL", paste(tauEndList, collapse=""),
     sep=""); dir.create(SaveDir, showWarnings=FALSE);
     
  Verbose = 0;  InitKKs = 10;
  pTot = length(Beta);
  X = matrix(rnorm(n * pTot), n, pTot);
  EY = X %*% Beta;
  if (!is.null(dfRobit) && dfRobit == 0) {
    Y = EY + rnorm(n);  YY = Y;
    Z = Y; Z[Y > 0] = 1;  Z[Y < 0] = 0;
  } else if (is.null(dfRobit) || dfRobit < 0) {
    Y = EY + rnorm(n);  YY = Y;
  } else {
    Y = EY  + rt(n, dfRobit);
    Z = Y;  Z[Y > 0] = 1;  Z[Y < 0] = 0;
  }
  if (length(X[1,]) <= 400) {
    XtY = t(X) %*% Y;
    XtX = t(X) %*% X;
    XtResid = XtY - XtX %*% Beta;
    YResidSq = sum((Y-X %*% Beta)^2);  OutYResidSq = 0 * YResidSq;
  }
  
  if (is.null(dfRobit) || dfRobit < 0) {
    dfRobit = NULL;  YY = Y
  }  else {
    YY = Z;
  }
  
  ##BetaStart = MyEM2Lasso$ReturnBetas;
BetaStart = Beta;

PriorProbTau = c(.2,.8,.01,.99);
PriorProbFixed = rep(.5, FirstRandom-1);
t1 = proc.time();
TemperatureList = c(8.0, 4.0,2.0,1.0,1.0,1.0,1.0);
##TemperatureList = c(1.0,1.0)
TemperatureList = NULL;
ABS = BayesSpikeRegression(Y=YY,X=X, BetaStart = BetaStart,
  IndexFirstRandomEffect = FirstRandom, tauEndList=tauEndList,
  tauStartValues = NULL, PiAStart = PiAStart, dfTauStart = -1, MStart = -1,
  dfTNoise = dfTNoise, Verbose = 2,
  DependenciesTau = NULL, DependenciesFixed=NULL,
  DoMax = 1, dfRobit = dfRobit,
  PiAPrior = PiAPrior, HowSample = 3,
  NumSpliceSampleReps = 5, SpliceMove= 1, CauchyEpsilon = .00001,
  MyPS = PriorStructureR5$new(.5,1),  tauFixed = 800,
  TypeFixedPrior = 1, DoRNGState = 1,
  SigmaPrior = c(1,Sigma^2), InitKKs = 10, DoRecord = c(1,1,1,1,0, 1,1),
  NumSamples = 200, MaxIters = 200, MaxGibbsIters = 500,
  MaximizeMeCauchyTotalIters = 100,
  ttStart = 0,  NumChains = 4, FileSave = "MyS",
  SaveDir = SaveDir,  FileName = "ABSChain",
  NewWrite = 1, tauPriordf = 1, tauPriorMean = 1, 
  CodaTableNames = NULL, Run = TRUE,
  EarlyEndStep = -1, EarlyEndtt = -1, RStart = 0,
  StartRunProbVector = 100, PriorProbTau = PriorProbTau, 
  PriorProbFixed=PriorProbFixed,
  TemperatureList = TemperatureList, DoEEProbSort = 1, EEMergeEvery = 10,
  EEProbSortWidth = .5, DoLogitPostProb = FALSE);

ABS$TBSR5$KeepPosteriorQuantiles <- c(.5, .25, .75, .05, .95, .025, .975, .01, .99, .005, .995);
ABS$TBSR5$BetaSymmetricQuantiles;
ABS$TBSR5$BetaSymmetricUnshrinkQuantiles;
ABS$TBSR5$BetaHPDUnshrinkQuantiles;
ABS$TBSR5$SigmaSymmetricQuantiles;
ABS$TBSR5$TauHPDUnshrinkQuantiles;



## Load in R packages
try(require(lattice, quietly=TRUE, warn.conflicts=FALSE), silent=TRUE);
try(require(coda, quietly=TRUE, warn.conflicts=FALSE), silent=TRUE);
try(require(R.methodsS3, quietly=TRUE, warn.conflicts=FALSE), silent=TRUE);
try(require(R.oo, quietly=TRUE, warn.conflicts=FALSE), silent=TRUE);
try(require(corpcor, quietly=TRUE, warn.conflicts=FALSE), silent=TRUE);
require(BayesDiallel, quietly = TRUE, warn.conflicts=FALSE);
require(R.oo, warn.conflicts=FALSE, quietly=TRUE);

###############################################################################
## First Example Piximus Diallel Mouse Data.
data(PiximusData);
##  Data is in "Piximus.Data"
##  Models are in "Examples.Piximus.Models"
##  tau.Prior is in "Examples.Piximus.tau.Prior.Info"
####################################
###### Run the Algorithm->
AFD = DiallelAnalyzer(data = Piximus.Data, father.strain="father.strain.name",
   mother.strain="mother.strain.name", phenotype="MouseWeight", is.female="is.female",
   sep="", FixedEffects = NULL,
   RandomEffects = NULL, 
   Models=Example.Piximus.Models, sigmasq.start = 1,  numChains = 5,  lengthChains=2500,
   burnin = 1,
   DIC.Only=FALSE,  tauPriorFile = Example.Piximus.tau.Prior.Info,
   SaveAFDFile = "SaveAFDBackUpPiximusData.RData");

## If SaveAFDFile saved a copy of AFD
if (FALSE) {
  library(R.oo);  library(BayesDiallel);
  load("SaveAFDBackUpPiximusData.RData");
}
AFD$ListElements;  ## List of Elements available to AFD
AFD$ListFunctions; ## List of Functions available to AFD  

AO = AFD$AllDiallelObs[[1]];
AO$ListElements  ## List of Elements available to AFD

## Chains are the first version, they are preshrunk towards group means.  You should
##   often use these by default;
summary(AO$cent.chains);   ## summary of the chains;
plot(AO$cent.chains);      ## Use Coda MCMC to plot the many member of chains consider "ask"/"wanted"
plot.hpd(AO$cent.chains);  ## Plot Hpd intervals for members of "chains" object.  Consider "ask"/"wanted"
summary(AO$raw.chains);   ## summary of the chains;
plot(AO$raw.chains);      ## Use Coda MCMC to plot the many member of chains consider "ask"/"wanted"
plot.hpd(AO$raw.chains);  ## Plot Hpd intervals for members of "chains" object.  Consider "ask"/"wanted"
  
## raw.chains are the "unshrunk version"
## Get a summary of the Coda Chains for first Diallel Model
summary(AFD$AllDiallelObs[[1]]$raw.chains)
plot(AFD$AllDiallelObs[[1]]$raw.chains);
plot.hpd(AFD$AllDiallelObs[[1]]$raw.chains);

##########################################################################
##  BayesSpike Selection uses Prior distributions to select a valid model from
##   subset of other models.  "tauPriorFile" can have an extra row "Prob"
##   with probabilities, if one wants to select certain groups with different
##   prior probabilities.  Default "Prob" will be .5
##
##  See library(BayesSpike) for more details on this selection process.
##
## Experimental, might not work if you don't have directory write access
if (length(list.files("C:")) > 0) {
  try(dir.create("C:/Stat"));  try(dir.create("C:/Stat/BayesSpikeSaves"));
  BSSaveDir = "C:/Stat/BayesSpikeSaves"
} else if (length(list.files("~/Documents")) > 0) {
  try(dir.create("~/Documents/Stat"));  try(dir.create("~/Documents/Stat/BayesSpikeSaves"));
  BSSaveDir = "~/Documents/Stat/BayesSpikeSaves"
} else if (length(list.files("~/")) > 0) {
 try(dir.create("~/Stat"));  try(dir.create("~/Stat/BayesSpikeSaves"));
  BSSaveDir = "~/Stat/BayesSpikeSaves"
}
AFD2 = DiallelAnalyzer(data = Piximus.Data, father.strain="father.strain.name",
   mother.strain="mother.strain.name", phenotype="MouseWeight", is.female="is.female",
   sep="", FixedEffects = NULL,
   RandomEffects = NULL, 
   Models=Example.Piximus.Models, sigmasq.start = 1,  numChains = 5,  lengthChains=2500,
   burnin = 1,
   DIC.Only=FALSE,  tauPriorFile = Example.Piximus.tau.Prior.Info,
   DoBayesSpike = TRUE, BSSaveDir = BSSaveDir);
   
## Get a summary of the Coda Chains for first Diallel Model
summary(AFD2$BSAFD$CodaList)
plot(AFD2$BSAFD$CodaList);
plot.hpd(AFD2$BSAFD$CodaList);

}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{ methods }
\keyword{ ts }% __ONLY ONE__ keyword per line
