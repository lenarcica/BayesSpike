#################################################################################  BayesSpikeR5.R####        Alan Lenarcic####  Defines BayesSpikeR5 class which acts as R controlled reference.####  Functions that access saved data files are featured prominently at the ##  bottom of the document, including code to read compressed MIP files.StableHPDinterval <- function(MCMCThing, prob=.05) {  library(coda);  if (length(MCMCThing) == 0) {    if (NCOL(MCMCThing) >= 1) {      AR <- (matrix(0, NCOL(MCMCThing),2));      try(rownames(AR) <- colnames(MCMCThing));      return(AR);    }    return(c(0,0));  }  ART <- NULL;  if (!is.mcmc(MCMCThing) && !is.list(MCMCThing)) {    try(MCMCThing <- suppressWarnings(as.mcmc(MCMCThing)), silent=TRUE);  }  try(ART <- HPDinterval(MCMCThing, prob=prob), silent=TRUE);  if (is.null(ART)) {    ART <- matrix(0, NCOL(MCMCThing), 2);    rownames(ART) <- colnames(MCMCThing);    for (jj in 1:NCOL(MCMCThing)) {      BBT <- NULL;      try(BBT <- HPDinterval(MCMCThing[,jj], prob=prob), silent=TRUE);      if (!is.null(BBT) && !all(is.na(BBT)) && length(BBT) == 2) {        ART[jj,] <- BBT;      }    }  } else {    return(ART);  }  return(ART);}if (FALSE) {  ## Test for Load;  library(AlanDirectories);  AlanDirectories:::SetSaveHomes();  source(paste(DropHome, "//BayesSpike2//BayesSpike//R//BayesSpikeR5.R", sep=""));}PriorStructureR5 = setRefClass("PriorStructureR5",  fields = list(Chdf = "numeric", taubarnu = "numeric",   MaxX = "numeric",  StartX = "numeric", NumPos = "numeric",  DoLog = "logical", DoSqrt = "logical",   PriorOftau = "ANY", X = "ANY"),  methods = list(    initialize = function(Chdf=1,taubarnu=-1, PriorFunc=NULL,      MaxX = 500, StartX = 0, NumPos = 100000, DoLog = FALSE, DoSqrt = FALSE,      ...) {          PriorXScaling = c( (MaxX - StartX) / NumPos, 1, StartX,0);    if (DoLog == TRUE) {      X <<- exp(StartX + (1:(NumPos-1))/NumPos * MaxX);      PriorXScaling[2] = -1;    } else if (DoSqrt == TRUE) {      X <<- (StartX + (1:(NumPos-1))/NumPos * MaxX)^2;      PriorXScaling[2] = 2;    } else {      X <<- StartX + (1:(NumPos-1))/NumPos * MaxX;    }    if (is.null(PriorFunc)) {      if (Chdf == -1) {        Chdf <<- 1;  taubarnu <<- 1;      }      PriorOftau <<- NULL;  X <<- NULL;     }  else {      PriorOftau <<- PriorFunc(X);    }    MaxX <<- MaxX;  StartX <<- StartX;  NumPos <<- NumPos;    DoLog <<- DoLog;  DoSqrt <<- DoSqrt;        .self;  },  finalize = function() {     return;  }));if (FALSE) {  library(AlanDirectories);  SetSaveHomes();  source(paste(DropHome, "//BayesSpike2/BayesSpike/R/BayesSpikeR5.r", sep=""));    }        BayesSpikeR5 = setRefClass("BayesSpikeR5",  fields = list(.X = "matrix", X=function(){ if (length(.X) == 0) {    return(NULL);   }   return(.self$.X);},   .Y = "vector",  Y=function() {    if (is.null(.Y) || length(.Y) == 0) { return(NULL); }    return(.self$.Y);  }, .Z = "vector", Z = function() {     if (is.null(.Z) || length(.Z) == 0) {return(NULL); }    return(.self$.Z) },  BetaStart = "vector",  Beta = "vector",  sBeta = function() {    ABT = NULL;    if (is.null(.self$ABayesSpikeCL)) { return(.self$BetaStart); }    try(ABT <- .self$ABayesSpikeCL$Beta, silent=TRUE)    if (!(is.null(ABT))) {      return(ABT);    }    return(.self$BetaStart);  },  OnBeta = function() {    ABT = NULL;    if (is.null(.self$ABayesSpikeCL)) { return(.self$BetaStart); }    try(ABT <- .self$ABayesSpikeCL$Beta, silent=TRUE)    if (!(is.null(ABT))) {      return(ABT);    }    return(.self$BetaStart);  },  .NumBayesSpikeOb = "integer",  tauEndList = "vector", sOnTau = "vector", FirstRandom = "numeric",  OldCodaNames = "vector",  FirstCLN = "vector",  CFirstRandom = function() {if (FirstRandom <= 0) { return(-1); }    return(.self$FirstRandom-1);  },  CtauEndList = function() { if (is.null(.self$tauEndList)) {     return(NULL);    }   if (length(.self$tauEndList) <= 0 || .self$tauEndList[1] == -1) { return(-1); }   return(.self$tauEndList-1); },  IndexFirstRandomEffect = function() { return(.self$FirstRandom); },  CodaTable = "ANY", CodaList = "ANY",  NInstance = "integer",  tauFixed = "numeric", TypeFixedPrior = "integer",  HowSample = "numeric", OnSigma = "numeric", OnPiA = "numeric",  PiAStart = "numeric",  RegionWidth = "integer",  PiAPrior = "vector", SigmaPrior = "vector", dfRobit = "numeric",  DoRecord = "vector", dfTNoise = "numeric", InitFlags = "vector",  MaxGibbsIters = "numeric", NumChains = "numeric", DependenciesTau = "list",  DependenciesFixed = "list", NumSamples=function(){return(.self$MaxGibbsIters);}, SpliceMove = "ANY",  CauchyEpsilon = "numeric", MaxIters = function(){return(.self$MaximizeMeCauchyTotalIters);},  MaximizeMeCauchyTotalIters = "numeric",  OnChainIter = "integer",  AllEigenVectors="list", AllEigenValues="list",  tauPriordf = "numeric", tauPriorMean = "numeric", ttStart = "integer",  EarlyEndStep ="numeric", EarlyEndtt = "numeric", DoSave = "logical",  DoSaveTBSR5 = "logical",  FileSave = "character",  PreRunMaxGibbsIters = "integer",  SaveDir = "character", Savedir = function() {     return(.self$SaveDir); }, FileName = "character",  NewWrite = "numeric",  DoMax = "numeric", PutRNG = "numeric", MyPS = "ANY",  CodaTableNames = "vector",  RStart = "numeric", Verbose = "numeric",   ListSaveFiles = "vector", ##ListAllSaveFiles = "vector",  TempCoda = "vector", TempCodaIDs = "numeric",  AFD="ANY",  ListChainIters = "list",   FillFilePostProbBuffer = "character",  LengthPostProbBuffer = "integer",  NoShrinkFixed = "vector",  NoShrinkRandom = "vector",  NoShrinkFixedPrior="vector", NoShrinkRandomPrior ="vector",  DoLogitPostProb = "logical",   .AlterWeightFiles = "ANY",  DefaultWriteNewProbBuffer = "logical",  WriteYBuffer = "logical", NewYBufferWrite = "logical",  WriteWeightBuffer="logical", NewWeightBufferWrite= "logical",  LengthYBuffer = "integer", LengthWeightBuffer = "integer",  FullFileYBuffer = "character", FullFileWeightBuffer = "character",  FullFileBetaAllDraw = "character",  EEDoSort = "logical", StartOldEELoad = "integer",  FullFileD = "character", FullFileI = "character",  FullFileiTLoc = "character",  FullFileiT = "character",  FullFiledT = "character", FullFileP = "character",  FullFileProb="character", FullFileiLoc="character",  DoLongCI = "logical", CpBuffLongCI = "integer", AverageIIWeight = "ANY",  OnTau = function() { if (!is.null(.self$ABayesSpikeCL)) {    return(.self$ABayesSpikeCL$OnTau); }    return(.self$sOnTau); },  tau = function() { if (!is.null(.self$ABayesSpikeCL)) {    return(.self$ABayesSpikeCL$OnTau); }    return(.self$sOnTau); },  AllTempCodaLists = "list",  OldFile = "character", OnFile="character",  DoChainIters = "integer",  LengthPiACodaBuffer = "integer", LengthSigCodaBuffer = "integer",  AlterWeightFlag = "logical", AlterdfTNoise = "numeric",   AlterdfRobit = "numeric",  KillMyTBSR5 = function() {    try(.self$AllTempCodaLists <- list());    try(.self$sOnTau <- rep(0,0), silent=TRUE);  try(.self$FullFileD <- "", silent=TRUE);     try(.self$FullFileI <- "", silent=TRUE);    try(.self$FullFileiT <- "", silent=TRUE);  try(.self$.AlterWeightFiles <- NULL);    try(.self$CodaTable <- NULL);  try(.self$CodaList <- NULL);    try(.self$.MIP <- NULL); try(.self$AllTempCodaLists <- list());    try(.self$AllEigenVectors <- list(), silent=TRUE);  try(.self$FullFileYBuffer <- rep(0,0), silent=TRUE);    ##try(.self$.CodaSubList <- list());      try(.self$.SigmaCodaList <- list(), silent=TRUE);    try(.self$.TauCodaList <- NULL);  try(.self$.AlterWeightCodaList <- list(), silent=TRUE);    try(.self$SubSetCoords <- rep(0,0), silent=TRUE);    try(.self$.ProbCodaList <- list(), silent=TRUE);     try(.self$.YCodaList <- list(), silent=TRUE);    try(.self$.WeightCodaList <- list(), silent=TRUE);    try(.self$.KeepPosteriorQuantiles <- rep(0,0), silent=TRUE);    try(.self$.BetaSymmetricQuantiles <- rep(0,0), silent=TRUE);    try(.self$.BetaSymmetricUnshrinkQuantiles <- rep(0,0), silent=TRUE);    try(.self$.SigmaSymmetricQuantiles <- rep(0,0), silent=TRUE);    try(.self$.TauSymmetricQuantiles <- rep(0,0), silent=TRUE);    try(.self$.TauHPDQuantiles <- rep(0,0), silent=TRUE);    try(.self$.BetaHPDQuantiles<- rep(0,0), silent=TRUE);    try(.self$.BetaHPDUnshrinkQuantiles <- rep(0,0), silent=TRUE);    try(.self$.SigmaHPDQuantiles <- rep(0,0), silent=TRUE);    try(.self$.PiASymmetricQuantiles <- rep(0,0), silent=TRUE);    try(.self$.PiAHPDQuantiles <- rep(0,0), silent=TRUE);    try(.self$.X <- matrix("numeric",0,0), silent=TRUE); try(.self$.Y <- rep(0,0), silent=TRUE);     try(.self$.Z <- rep(0,0), silent=TRUE);    try(.self$BetaStart <- rep(0,0), silent=TRUE);    try(.self$PreRunMaxGibbsIters <- rep(0,0), silent=TRUE);    try(.self$.BeingDestroyed <- 1);    try(.self$PreRunMaxGibbsIters <- NULL, silent=TRUE);    if (.self$Verbose > 1) {       print("KillMyTBSR5: Conclude having deleted many elements"); flush.console();    }    try(.self$ABayesSpikeCL <- NULL, silent=TRUE);    if (.self$Verbose > 1) {       print("KillMyTBSR5: Complete"); flush.console();    }  },   AlterWeightdfTNoise = function(AA = NULL) {    if (!is.null(AA) && is.numeric(AA) && length(AA) == 1) {      .self$AlterdfTNoise <- AA;      return(AA);    }    return(.self$AlterdfTNoise);  },  AlterWeightdfRobit = function(AA = NULL) {    if (!is.null(AA) && is.numeric(AA) && length(AA) == 1) {      .self$AlterdfRobit <- AA;      return(AA);    }    return(.self$AlterdfRobit);  },  .MIP = "ANY",  MIP = function() {    if (is.null(.MIP) || length(.MIP) == 0) {      try(library(coda));      .self$GenerateMIP();    }    return(.MIP);  },  AlterWeightFile = "character", .AlterWeightCodaList = "ANY",  AlterWeightCodaList = function(AA = NULL) {    if (!is.null(AA) && is.list(AA)) {      try(.self$.AlterWeightCodaList <- AA);      if (!is.null(.self$ABayesSpikeCL)) {        try(.self$ABayesSpikeCL$AlterWeightCodaList <- AA);      }      return(1);    }    return(.self$ABayesSpikeCL$AlterWeightCodaList);  },  ##.CCodaSubVector = "ingeter";  ##CodaSubVector = function(AA = NULL) {  ##  if (!is.null(AA) && is.vector(AA)) {  ##    AA = sort(unique(as.integer(AA[AA >= 1.0 && AA <= .self$p])));  ##    try(.self$.CodaSubVector <- as.integer(AA -1));  ##    if (!is.null(.self$ABayesSpikeCL)) {  ##      try(.self$ABayesSpikeCL$CodaSubVector <- .self$.CodaSubVector);  ##    }   ##    return(1);       ##  }  ##  if (length(.self$.CCodaSubVector) <= 0) { return(NULL); }  ##  return(.self$.CCodaSubVector);  ##},  ##.CodaSubList = "ANY",  ##CodaSubList = function(AA = NULL) {  ##  if (!is.null(AA) && is.vector(AA)) {  ##    AA = sort(unique(as.integer(AA[AA >= 1.0 && AA <= .self$p])));  ##    try(.self$.CodaSubVector <- as.integer(AA -1));  ##    if (!is.null(.self$ABayesSpikeCL)) {  ##      try(.self$ABayesSpikeCL$CodaSubVector <- .self$.CodaSubVector);  ##    }   ##    return(1);       ##  }  ##  if (!is.null(.self$ABayesSpikeCL)) {  ##    return(.self$ABayesSpikeCL$CodaSubList);  ##  }  ##  return(.self$.CodaSubList);    ##},  AlterWeightList = function(AA = NULL) {    if (!is.null(AA) && is.list(AA)) {      try(.self$.AlterWeightCodaList <- AA);      if (!is.null(.self$ABayesSpikeCL)) {        try(.self$ABayesSpikeCL$AlterWeightCodaList <- AA);      }    }    return(.self$AlterWeightCodaList);  },    LengthAlterWeightBuffer = "integer", AlterWeightTemperature="numeric",  .SigmaCodaList = "ANY", SigmaCodaList = function() {    if (!is.null(.self$.SigmaCodaList) && length(.self$.SigmaCodaList) > 0) {      return(.SigmaCodaList);    }    .self$GenerateSigmaCodaList();    return(.self$.SigmaCodaList);  },  .TauCodaList = "ANY", TauCodaList = function() {    if (!is.null(.self$.TauCodaList) && length(.self$.TauCodaList) > 0) {      return(.TauCodaList);    }    .self$GenerateTauCodaList();    return(.self$.TauCodaList);    },  .PiACodaList = "ANY", PiACodaList = function() {    if (!is.null(.self$.PiACodaList) && length(.self$.PiACodaList) > 0) {      return(.PiACodaList);    }    .self$GeneratePiACodaList();    return(.self$.PiACodaList);  },  .ProbCodaList = "ANY", ProbCodaList = function() {    if (!is.null(.self$.ProbCodaList) && length(.self$.ProbCodaList) > 0) {      return(.ProbCodaList);    }    .self$GenerateProbCodaList(.self$DoLogitPostProb);    return(.self$.ProbCodaList);  },  PostProbCodaList = function() { .self$ProbCodaList; },  PriorProbTau = "ANY", PriorProbFixed = "ANY",  CNoShrinkFixed = function() {    if (is.null(NoShrinkFixed) || !is.numeric(NoShrinkFixed) ||      NoShrinkFixed[1] == -1 || length(NoShrinkFixed) <= 0) {      return(NULL);      }    return(NoShrinkFixed-1);  },  CNoShrinkRandom = function() {    if (is.null(NoShrinkRandom) || !is.numeric(NoShrinkRandom) ||      NoShrinkRandom[1] == -1 || length(NoShrinkRandom) <= 0) {      return(NULL);      }    return(NoShrinkRandom-1);  },  .BeingDestroyed="numeric",  n="numeric", p="numeric",  ABayesSpikeCL = "ANY",    RandomInfoList = "list",  MBS = function(aMBS = NULL) {    if (!is.null(aMBS)) {      ##.self$ABayesSpikeCL <- aMBS;      print("No You Can't attach a new AMBS to me."); flush.console();      return(1);    } else {      return(.self$ABayesSpikeCL);    }  },   DoEEProbSort = "numeric",   TemperatureList = "vector", TemperatureDecreasingRate="numeric",   Tempii = function(aTempii = NULL) {     if (is.null(.self$ABayesSpikeCL)) {       print("Can't give or set Tempii because its MBS is NULL.");       flush.console(); return(-1);     }     if (is.null(aTempii)) {       return(.self$ABayesSpikeCL$Tempii);     } else {       .self$ABayesSpikeCL$Tempii <- aTempii;       return(.self$ABayesSpikeCL$Tempii);     }     return(.self$ABayesSpikeCL$Tempii);   },   Temperatureii = function(aTempii = NULL) {     if (is.null(.self$ABayesSpikeCL)) {       print("Can't give or set Tempii because its MBS is NULL.");       flush.console(); return(-1);     }     if (is.null(aTempii)) {       return(.self$ABayesSpikeCL$Tempii);     } else {       .self$ABayesSpikeCL$Tempii <- aTempii;       return(.self$ABayesSpikeCL$Tempii);     }     return(.self$ABayesSpikeCL$Tempii);   },   SubsetCoords = function() {return(.self$SubSetCoords);},   SubSetTau = "vector",    SubsetTau = function() { return(SubSetTau);},   .YCodaList = "ANY", .WeightCodaList = "ANY",   YCodaList = function() {     if (is.null(.self$.YCodaList)) {       .self$GenerateYCodaList();     }     return(.YCodaList);   },   .KeepPosteriorQuantiles = "numeric",   .BetaSymmetricQuantiles = "matrix",   .BetaSymmetricUnshrinkQuantiles = "matrix",   .SigmaSymmetricQuantiles = "vector",   .TauSymmetricQuantiles = "matrix",   .TauHPDQuantiles = "matrix",   .BetaHPDQuantiles = "matrix",   .BetaHPDUnshrinkQuantiles = "matrix",   .SigmaHPDQuantiles = "vector",   .PiASymmetricQuantiles = "matrix",   .PiAHPDQuantiles = "matrix",   KeepPosteriorQuantiles = function(Input = NULL) {     if (!is.null(Input) && is.numeric(Input) && length(Input) >= 0) {       try(.self$.KeepPosteriorQuantiles  <- Input);       try(.self$.BetaSymmetricQuantiles <- matrix(0,0,0));       try(.self$.BetaSymmetricUnshrinkQuantiles <- matrix(0,0,0));       try(.self$.SigmaSymmetricQuantiles <- matrix(0,0,0));       try(.self$.TauSymmetricQuantiles <- matrix(0,0,0));       try(.self$.BetaHPDQuantiles <- matrix(0,0,0));                                   try(.self$.BetaHPDUnshrinkQuantiles <- matrix(0,0,0));         try(.self$.TauHPDQuantiles <- matrix(0,0,0));          try(.self$.TauSymmetricQuantiles <- matrix(0,0,0));                                   try(.self$.PiASymmetricQuantiles <- matrix(0,0,0));        } else if (!is.null(Input)) {       print("Set Keep PosteriorQuantiles, input is insufficient!");       flush.console();     }     return(.self$.KeepPosteriorQuantiles);   },   HPDQuantiles = function() {     if (length(.self$.KeepPosteriorQuantiles) == 0) {       return(vector("numeric",0));     }     AHPD <- c();     if (.5 %in% .self$.KeepPosteriorQuantiles) {       AHPD <- .5;     }     AST <- sort(.self$.KeepPosteriorQuantiles[.self$.KeepPosteriorQuantiles < .5], decreasing=TRUE);     AHPD <-  (1-2*AST)     return(AHPD);   },   SigmaSymmetricQuantiles = function() {     if (is.null(.self$.SigmaSymmetricQuantiles)  ||       length(.self$.SigmaSymmetricQuantiles) <= 0) {       .self$GenerateSigmaQuantiles();       }     return(.self$.SigmaSymmetricQuantiles);   },   SigmaHPDQuantiles = function() {     if (is.null(.self$.SigmaHPDQuantiles)  ||       length(.self$.SigmaHPDQuantiles) <= 0) {       .self$GenerateSigmaQuantiles();       }     return(.self$.SigmaHPDQuantiles);   },   PiASymmetricQuantiles = function() {     if (is.null(.self$.PiASymmetricQuantiles)  ||       length(.self$.PiASymmetricQuantiles) <= 0) {       .self$GeneratePiAQuantiles();       }     return(.self$.PiASymmetricQuantiles);   },   PiAHPDQuantiles = function() {     if (is.null(.self$.PiAHPDQuantiles)  ||       length(.self$.PiAHPDQuantiles) <= 0) {       .self$GeneratePiAQuantiles();       }     return(.self$.PiAHPDQuantiles);   },   BetaSymmetricQuantiles = function() {     if (is.null(.self$.BetaSymmetricQuantiles)  ||       length(.self$.BetaSymmetricQuantiles) <= 0) {       .self$GenerateBetaQuantiles();       }     return(.self$.BetaSymmetricQuantiles);   },   BetaHPDQuantiles = function() {     if (is.null(.self$.BetaHPDQuantiles)  ||       length(.self$.BetaHPDQuantiles) <= 0) {       .self$GenerateBetaQuantiles();       }     return(.self$.BetaHPDQuantiles);   },   BetaSymmetricUnshrinkQuantiles = function() {     if (is.null(.self$.BetaSymmetricUnshrinkQuantiles)  ||       length(.self$.BetaSymmetricUnshrinkQuantiles) <= 0) {       .self$GenerateBetaQuantiles();       }     return(.self$.BetaSymmetricUnshrinkQuantiles);   },   BetaHPDUnshrinkQuantiles = function() {     if (is.null(.self$.BetaHPDUnshrinkQuantiles)  ||       length(.self$.BetaHPDUnshrinkQuantiles) <= 0) {       .self$GenerateBetaQuantiles();       }     return(.self$.BetaHPDUnshrinkQuantiles);   },   BetaUnshrinkSymmetricQuantiles = function() {     if (is.null(.self$.BetaSymmetricUnshrinkQuantiles)  ||       length(.self$.BetaSymmetricUnshrinkQuantiles) <= 0) {       .self$GenerateBetaQuantiles();       }     return(.self$.BetaSymmetricUnshrinkQuantiles);   },   BetaUnshrinkHPDQuantiles = function() {     if (is.null(.self$.BetaHPDUnshrinkQuantiles)  ||       length(.self$.BetaHPDUnshrinkQuantiles) <= 0) {       .self$GenerateBetaQuantiles();       }     return(.self$.BetaHPDUnshrinkQuantiles);   },   BetaSymmetricUnshrunkQuantiles = function() {     if (is.null(.self$.BetaSymmetricUnshrinkQuantiles)  ||       length(.self$.BetaSymmetricUnshrinkQuantiles) <= 0) {       .self$GenerateBetaQuantiles();       }     return(.self$.BetaSymmetricUnshrinkQuantiles);   },   BetaHPDUnshrunkQuantiles = function() {     if (is.null(.self$.BetaHPDUnshrinkQuantiles)  ||       length(.self$.BetaHPDUnshrinkQuantiles) <= 0) {       .self$GenerateBetaQuantiles();       }     return(.self$.BetaHPDUnshrinkQuantiles);   },   TauSymmetricQuantiles = function() {     if (is.null(.self$.TauSymmetricQuantiles)  ||       length(.self$.TauSymmetricQuantiles) <= 0) {       .self$GenerateTauQuantiles();       }     return(.self$.TauSymmetricQuantiles);   },   TauHPDQuantiles = function() {     if (is.null(.self$.TauHPDQuantiles)  ||       length(.self$.TauHPDQuantiles) <= 0) {       .self$GenerateTauQuantiles();       }     return(.self$.TauHPDQuantiles);   },   WeightList = function() {     if (is.null(.self$.WeightCodaList)) {       .self$GenerateWeightCodaList();     }     return(.WeightCodaList);   },   WeightCodaList = function() {     if (is.null(.self$.WeightCodaList)) {       .self$GenerateWeightCodaList();     }     return(.WeightCodaList);   },    .SubSetCoords = "integer",   .SubCodaLongList = "ANY",   FullBetaAllDraw = "character",   SubCodaLongList = function(AA = -999) {     if (is.null(AA)) {       try(.self$.SubCodaLongList <- NULL);     } else if (length(AA) == 1 && round(AA) > -1000 && round(AA) < -998) {       return(.self$.SubCodaLongList);     } else if (is.null(.self$.SubCodaLongList) || length(.self$.SubCodaLongList) <= 0 ||       (length(.self$.SubCodaLongList) == 1 &&         length(.self$.SubCodaLongList[[1]]) == 1 &&         .self$.SubCodaLongList[[1]][1] == -1)) {       .self$LoadSubCodaLongList();     }     return(.self$.SubCodaLongList);   },   .BetaSymmetricLongQuantiles = "matrix",   BetaSymmetricLongQuantiles = function() {     if (is.null(.self$.BetaSymmetricLongQuantiles)  ||       length(.self$.BetaSymmetricLongQuantiles) <= 0) {       .self$GenerateBetaLongQuantiles();       }     return(.self$.BetaSymmetricLongQuantiles);   },   .BetaHPDLongQuantiles = "matrix",   BetaHPDLongQuantiles = function() {     if (is.null(.self$.BetaHPDLongQuantiles)  ||       length(.self$.BetaHPDLongQuantiles) <= 0) {       .self$GenerateBetaLongQuantiles();       }     return(.self$.BetaHPDLongQuantiles);   },   .SubCodaList = "ANY", .SubProbCodaList = "ANY",   .DoProb = "numeric",    DoProb = function(AA = NULL) {     if (is.null(AA)) {       return(AA);     } else if (is.numeric(AA) && length(AA) >= 1 && AA[1] <= -.5) {       try(.self$.DoProb <- -1.0)      } else if (is.numeric(AA) && length(AA) >= 1 && AA[1] > -.5 && AA[1] <= .5) {       try(.self$.DoProb <- 0.0);     } else if (is.numeric(AA) && length(AA) >= 1) {       try(.self$.DoProb <- 1.0);     } else if (is.logical(AA) && length(AA) >= 1 && !is.na(AA[1]) && AA[1] == TRUE) {       try(.self$.DoProb <- 1.0);     } else if (is.logical(AA) && length(AA) >= 1) {       try(.self$.DoProb <- 0.0);     }   },  .DoAllTemp = "numeric",    DoAllTemp = function(AA = NULL) {     if (is.null(AA)) {       return(AA);     } else if (is.numeric(AA) && length(AA) >= 1 && AA[1] <= -.5) {       try(.self$.DoAllTemp <- -1.0)      } else if (is.numeric(AA) && length(AA) >= 1 && AA[1] > -.5 && AA[1] <= .5) {       try(.self$.DoAllTemp <- 0.0);     } else if (is.numeric(AA) && length(AA) >= 1) {       try(.self$.DoAllTemp <- 1.0);     } else if (is.logical(AA) && length(AA) >= 1 && !is.na(AA[1]) && AA[1] == TRUE) {       try(.self$.DoAllTemp <- 1.0);     } else if (is.logical(AA) && length(AA) >= 1) {       try(.self$.DoAllTemp <- 0.0);     }   },   .DoPostBuff = "numeric",    DoPostBuff = function(AA = NULL) {     if (is.null(AA)) {       return(AA);     } else if (is.numeric(AA) && length(AA) >= 1 && AA[1] <= -.5) {       try(.self$.DoPostBuff <- -1.0)      } else if (is.numeric(AA) && length(AA) >= 1 && AA[1] > -.5 && AA[1] <= .5) {       try(.self$.DoPostBuff <- 0.0);     } else if (is.numeric(AA) && length(AA) >= 1) {       try(.self$.DoPostBuff <- 1.0);     } else if (is.logical(AA) && length(AA) >= 1 && !is.na(AA[1]) && AA[1] == TRUE) {       try(.self$.DoPostBuff <- 1.0);     } else if (is.logical(AA) && length(AA) >= 1) {       try(.self$.DoPostBuff <- 0.0);     }   },   .DoILoc = "numeric",    DoILoc = function(AA = NULL) {     if (is.null(AA)) {       return(AA);     } else if (is.numeric(AA) && length(AA) >= 1 && AA[1] <= -.5) {       try(.self$.DoILoc <- -1.0)      } else if (is.numeric(AA) && length(AA) >= 1 && AA[1] > -.5 && AA[1] <= .5) {       try(.self$.DoILoc <- 0.0);     } else if (is.numeric(AA) && length(AA) >= 1) {       try(.self$.DoILoc <- 1.0);     } else if (is.logical(AA) && length(AA) >= 1 && !is.na(AA[1]) && AA[1] == TRUE) {       try(.self$.DoILoc <- 1.0);     } else if (is.logical(AA) && length(AA) >= 1) {       try(.self$.DoILoc <- 0.0);     }   },   SubCodaList = function(AA = -9999) {     if (!is.null(AA) && is.numeric(AA) && length(AA) == 1 && as.integer(AA) < 0) {       if (length(.self$MBS$CSubSetCoords) >= 1 &&          (is.null(.self$.SubCodaList) || length(.self$.SubCodaList) <= 0)) {         .self$LoadSubCodaList(DoProb=.self$.DoProb);            }       return(.self$.SubCodaList);     } else if (is.null(AA) || length(AA) <= 0) {       try(.self$.SubCodaList <- NULL, silent=TRUE);       if (is.null(.self$MBS) || is.null(.self$MBS$CSubSetCoords) ||         length(.self$MBS$CSubSetCoords) <= 0) {         try(.self$MBS$SubCodaList <- NULL, silent=TRUE);       } else if (!is.null(.self$MBS) && !is.null(.self$MBS$SubCodaList) && length(.self$MBS$SubCodaList) >= 0) {         try(.self$MBS$SubCodaList <- NULL, silent=TRUE);       }       return(NULL);     } else if (!is.null(AA) && length(AA) >= 1) {       print("TBSR5: Set SubCodaList: I'm not letting you manually set SubCodaList");  flush.console();       return(1);         }      return(.self$.SubCodaList);   },   SubProbCodaList   = function(AA = -9999) {     if (!is.null(AA) && is.numeric(AA) && length(AA) == 1 && as.integer(AA) < 0) {       if (length(.self$.SubProbCodaList) >= 1 &&          (is.null(.self$.SubProbCodaList) || length(.self$.SubProbCodaList) <= 0)) {         .self$GenerateSubProbCodaList;            }       return(.self$.SubProbCodaList);     } else if (is.null(AA) || length(AA) <= 0) {       try(.self$.SubProbCodaList <- NULL, silent=TRUE);       if (is.null(.self$MBS) || is.null(.self$MBS$CSubSetCoords) ||         length(.self$MBS$CSubSetCoords) <= 0) {         try(.self$.SubProbCodaList <- NULL, silent=TRUE);       } else if (!is.null(.self$.SubProbCodaList) && !is.null(.self$.SubProbCodaList) && length(.self$.SubProbCodaList) >= 0) {         try(.self$.SubProbCodaList <- NULL, silent=TRUE);       }       return(NULL);     } else if (!is.null(AA) && length(AA) >= 1) {       print("TBSR5: Set SubCodaList: I'm not letting you manually set SubCodaList");  flush.console();       return(1);         }      return(.self$.SubProbCodaList);   },   OtherSubCoda = "ANY", SubYList = "integer",   .SubCodaVector = "integer",   SubCodaVector = function(AA = NULL) {     if (!is.null(AA) && length(AA) >= 1) {       if (is.null(.self$MBS)) {         print("Will Not set SubCodaVector until MBS is Allocated!");         flush.console();         return(-1);       }       ##try(.self$.SubSetCoords <- as.integer(sort(unique(       ##  as.integer(AA[AA >= 1 && AA <- .self$p] -1) ))));       try(.self$MBS$SubSetCoords <- AA);       return(1);     }     if (length(.self$.SubSetCoords) <= 0) { return(NULL); }     return(.self$.SubSetCoords + 1);   },   SubSetCoords = function(AA = -9999) {     if (!is.null(AA) && is.numeric(AA) && length(AA) == 1 && as.integer(AA) < 0) {       if (length(.self$.SubSetCoords) <= 0) { return(NULL); }       return(.self$.SubSetCoords + 1);     } else if (is.null(AA) || length(AA) <= 0) {       try(.self$.SubSetCoords <- as.integer(NULL));       try(.self$.SubCodaList <- NULL, silent=TRUE);       try(.self$.SubProbCodaList <- NULL, silent=TRUE);       if (!is.null(.self$MBS)) {         try(.self$MBS$SubCodaLongList <- NULL, silent=TRUE);         try(.self$MBS$SubCodaList <- NULL, silent=TRUE);         try(.self$MBS$SubSetCoords <- NULL);       }       try(.self$.SubCodaLongList <- NULL, silent=TRUE);       return(NULL);     }     AA <- sort(unique(round(AA[AA >= 1 && AA <= .self$p])));     if (length(AA) <= 0 || is.null(AA)) {        print("Hey, SubSetCoords, you supplied a bad coordinate set!");        return(NULL);     }     if (!is.null(AA) && length(AA) >= 1) {             if (is.null(.self$MBS)) {         print("Will Not set SubCodaVector until MBS is Allocated!");         flush.console();         return(-1);       }       ##try(.self$.SubSetCoords <- as.integer(sort(unique(       ##  as.integer(AA[AA >= 1 && AA <- .self$p] -1) ))));             try(.self$.SubSetCoords <- as.integer(NULL));       .self$.SubCodaLongList <- NULL;       .self$.SubCodaList <- NULL;       if (!is.null(.self$MBS)) {         try(.self$MBS$CSubSetCoords <- as.integer(AA-1), silent=TRUE);         try(.self$.SubSetCoords <- as.integer(AA-1));         try(.self$MBS$SubCodaList <- NULL, silent=TRUE);         try(.self$MBS$SubCodaLongList <- NULL, silent=TRUE);       }       return(1);           }       if (length(.self$.SubSetCoords) <= 0) { return(NULL); }       return(.self$.SubSetCoords + 1);   }),  methods = list(    initialize = function( X=-1, Y=-1, BetaStart = -1,    tauEndList = NULL, sOnTau = NULL,  FirstRandom = 0,    tauFixed=1000, TypeFixedPrior = 0, HowSample = 3,      tauPriordf = 1, tauPriorMean =1,  NumChains = 3,    OnSigma = 1, OnPiA = .5, PiAStart = .5, PiAPrior = c(1,1), SigmaPrior = c(1,1),      NoShrinkFixed=NULL, NoShrinkFixedPrior = NULL,      NoShrinkRandom=NULL, NoShrinkRandomPrior=NULL,      DoEEProbSort = 0,  NInstance = 1,      TemperatureList = NULL, RandomInfoList=NULL,      TemperatureDecreasingRate = 1.0,      DoSave = TRUE, DoSaveTBSR5 = TRUE,      FileSave = "MyS",  LengthPostProbBuffer = 100,      SaveDir = get(".DefaultFileDir", BAYESSPIKENAMESPACE),     FileName = "ABSChain",  NewWrite = 1,    DoRecord = rep(0,7),    MaxGibbsIters = 1000, NumSamples = 1000,    CauchyEpsilon = .00001, MaxIters = 100,     AFD=NULL, PutRNG = 1, DependenciesTau = NULL,    MaximizeMeCauchyTotalIters = 100,    AlterWeightFlag = FALSE, LengthAlterWeightBuffer = 300,  DependenciesFixed = NULL, DefaultWriteNewProbBuffer = TRUE,  EarlyEndStep = -1, EarlyEndtt = -1,  ttStart = 0, InitFlags = c(0,1,2,3),  CodaTableNames = -1,   DoMax = 1,  dfTNoise = -1,  ListChainIters = NULL,  Verbose = 0, MyPS = BayesSpike::PriorStructureR5$new(.5,1),  RStart = 0, TempCoda = NULL, TempCodaIDs = NULL, Z=-1,  DoLogitPostProb = FALSE,   WriteYBuffer = FALSE, NewYBufferWrite = TRUE,  WriteWeightBuffer=FALSE, NewWeightBufferWrite= TRUE,  LengthYBuffer=100, LengthWeightBuffer = 100,  RegionWidth = -1,  SubYList = vector("integer",0), SubSetTau = vector("integer",0),   SubSetCoords = vector("integer", 0),  dfRobit = -1, EEDoSort = TRUE,  PreRunMaxGibbsIters = 20,  LengthPiACodaBuffer = 100, LengthSigCodaBuffer = 100,  StartOldEELoad = 50,DoChainIters = -1, AlterWeightTemperature = 1.0,  PriorProbTau = NULL, PriorProbFixed = NULL, SpliceMove = SpliceMove,  ListSaveFiles = vector("character",0),   ##ListAllSaveFiles = vector("character",0),   KeepPosteriorQuantiles = c(.5,.25,.75,.025,.975,.01,.99),  DoLongCI = FALSE, CpBuffLongCI = -1,  ...) {    ATextT1 <- " t1 = proc.time(); ";    try(eval(parse(text=ATextT1)), silent=TRUE);    try(.self$.NumBayesSpikeOb <- as.integer(1));    if (is.null(TypeFixedPrior)) {       MyPartT <- "try(TypeFixedPrior <- 1);"       try(eval(parse(text=MyPartT)), silent=TRUE);    }    try(.self$TypeFixedPrior <- as.integer(round(TypeFixedPrior)));    if (is.logical(Verbose) && Verbose == TRUE) {       Verbose <<- 1;  t1 = proc.time();    } else if (is.logical(Verbose) && Verbose == FALSE)     {       Verbose <<- 0;    } else {      Verbose <<- Verbose;    }    if (.self$Verbose > 0) {      print("BayesSpikeR5: Starting Initialize R5 Class.");      flush.console();    }      if (length(X) <= 0 || !is.numeric(X) || length(X) == 1) {      tryCatch("Error: X not given to BayesSpikeR5");     }      if (length(Y) <= 0 || !is.numeric(Y) || length(Y) == 1)  {      tryCatch("Error: Y not given to BayesSpikeR5")    }    if (!is.matrix(X)) {      tryCatch("Error: BayesSpikeR5, give X in form of a matrix");    }    if (is.null(dim(X)) || dim(X)[1] != length(Y)) {      tryCatch("Error: BayesSpikeR5, dims of X and Y are incompatible");        }    if (.self$Verbose > 1) {      print("BayesSpikeR5: Apply X and Y.");      flush.console();    }    .self$.X <- X;  .self$.DoProb <- -1.0;  .self$.DoPostBuff = -1.0;    .self$.DoILoc = -1.0;    if (dfRobit >= 0) {       try(.self$dfRobit <- dfRobit);      if (all(round(Y,1) %in% c(0,1))) {        try(.self$.Z <- round(Y,1));        try(.self$.Y <- round(Y,1) * 2 -1);      } else if (all(round(Y,1) %in% c(-1,1))) {        try(.self$.Z <- (round(Y,1) + 1)/2);        try(.self$.Y <- Y);      } else {        print(paste("Hey, dfRobit is given as ", dfRobit, " but ",          "maxmin(", min(Y), ", ", max(Y), ")", sep=""));        flush.console();        try(.self$.Y <- NULL);  try(.self$.Z <- NULL);        return(.self);      }    } else {      try(.self$.Y <- Y);      try(.self$.Z <- vector("numeric",0));    }    try(.self$.DoAllTemp <- -1);    try(.self$n <- length(.self$Y)); try(.self$p <- dim(X)[2]);     if (is.null(LengthPostProbBuffer)) {      try(.self$LengthPostProbBuffer <- as.integer(0));    } else {        try(.self$LengthPostProbBuffer <-         as.integer(round(LengthPostProbBuffer)));    }    if (dim(.self$X)[1] != .self$n) {      print(paste("Error, TBSR5, Y is length=", length(.self$Y),      ", but dim(.self$X) = (", paste(dim(.self$X), collapse=", "), ")", sep=""));      tryCatch("Go Seek this error!");    }    if (.self$Verbose > 2) {      print("BayesSpikeR5: Apply BetaStart. "); flush.console();    }    if (.self$p <= 0) {      print("BayesSpikeR5: ERROR ERROR ERROR ERROR ERROR ERROR");      print(paste("BayesSpikeR5: No way are we working with .self$p = ", .self$p));      flush.console();      tryCatch("BayesSpike R5 Error !")    }    if (is.null(BetaStart) || length(BetaStart) <= 0 ||      (is.numeric(BetaStart) && length(BetaStart) == 1 && BetaStart[1] == -1)) {      try(.self$BetaStart <- rep(0, .self$p));      try(.self$Beta <- rep(0,.self$p) + .self$BetaStart);    } else if (length(BetaStart) == 1 && BetaStart[1] > 0) {      try(.self$BetaStart <- rnorm(p,0,1) * sqrt(BetaStart));      try(.self$Beta <- rep(0,.self$p) + .self$BetaStart);    } else {      if (is.null(BetaStart) || length(BetaStart) <= 0) {        try(.self$BetaStart <- rep(0, .self$p));      } else if (length(BetaStart) == .self$p) {        try(.self$BetaStart <- BetaStart);      } else if (length(BetaStart) < .self$p) {        try(.self$BetaStart <- c(          BetaStart, rep(0, .self$p - length(BetaStart)) ));      } else {        try(.self$BetaStart <- BetaStart[1:.self$p]);      }      try(.self$Beta <- rep(0,.self$p) + .self$BetaStart);    }    if (is.null(.self$Beta) || !is.numeric(.self$Beta) ||      length(.self$Beta) != .self$p) {      try(.self$Beta <- rep(0,.self$p));    }      if (length(tauPriordf) != 1) {         tryCatch("Error: BayesSpikeR5: only supports single tauPriordf");      }      if (!is.numeric(MaxGibbsIters) && (MaxGibbsIters == 1000 &&        is.numeric(NumSamples) && NumSamples[1] > 0 )) {        try(.self$MaxGibbsIters <- as.integer(round(NumSamples[1])));        } else if (is.numeric(MaxGibbsIters)) {        try(.self$MaxGibbsIters <- as.integer(round(MaxGibbsIters[1])));      } else {        try(.self$MaxGibbsIters <- as.integer(round(1000)));      }    if (.self$Verbose > 0) {      print("BayesSpikeR5: Set Priors.");      flush.console();    }    try(.self$.BeingDestroyed <- -1);    try(.self$.MIP <- NULL);    try(.self$NInstance <- as.integer(1));    try(.self$TypeFixedPrior <- as.integer(round(TypeFixedPrior)));    try(.self$tauPriordf <-       as.numeric(tauPriordf));    ## NInstance <<- NInstance;    try(.self$tauPriorMean <- as.numeric(tauPriorMean));    try(.self$OnSigma <- as.numeric(OnSigma));    try(.self$PiAStart <- as.numeric(PiAStart));    try(.self$PreRunMaxGibbsIters <- as.integer(PreRunMaxGibbsIters));    if (is.null(OnPiA) || length(OnPiA) <= 0) {      MyTryT <- "OnPiA <- .5; "      try(eval(parse(text=MyTryT)));    }    try(.self$OnPiA <- as.numeric(OnPiA));    if (is.null(.self$OnPiA)) {      try(.self$OnPiA <- as.numeric(.5));    }    if (length(.self$OnPiA) == 1 &&       (.self$OnPiA <= 0.0 || .self$OnPiA >= 1.0)) {      try(.self$OnPiA <- as.numeric(.5));    }    try(.self$RegionWidth <- as.integer(RegionWidth));      if (is.null(PiAPrior) || length(PiAPrior) <= 0) {        if (length(OnPiA) == 2) {          try(.self$PiAPrior <- as.numeric(c(2,2,2,2)));        } else {          try(.self$PiAPrior <- as.numeric(c(2,2)));        }      } else if (length(OnPiA) == 1 && length(PiAPrior) >= 3) {        try(.self$PiAPrior <- as.numeric(PiAPrior[1:2]));      } else {          try(.self$PiAPrior <- as.numeric(PiAPrior));       }      if (length(PiAPrior) <= 0) {        try(.self$PiAPrior <- as.numeric(c(2,2)));      } else if (length(PiAPrior) == 1) {        try(.self$PiAPrior <- as.numeric(c(PiAPrior[1], PiAPrior[1])));      }      try(.self$SigmaPrior <- as.numeric(SigmaPrior));        try(.self$ttStart <- as.integer(1));            if (.self$Verbose >= 3) {      print("BayesSpikeR5: Set Temperature.");      flush.console();    }    if (is.null(TemperatureList)) {      try(.self$TemperatureList <- vector("numeric",0));    } else {      try(.self$TemperatureList <- TemperatureList);    }      if (!is.null(TemperatureDecreasingRate) && is.numeric(TemperatureDecreasingRate) &&        TemperatureDecreasingRate[1] <= 1.0 && TemperatureDecreasingRate[1] > 0.0) {        try(.self$TemperatureDecreasingRate <- TemperatureDecreasingRate);        } else {        try(.self$TemperatureDecreasingRate <- 1.0);      }    try(.self$SpliceMove <- SpliceMove);    try(.self$.SigmaCodaList <- NULL);      try(.self$.PiACodaList <- NULL);    try(.self$DoEEProbSort <- DoEEProbSort);       try(.self$HowSample <- as.integer(3));        try(.self$InitFlags <- InitFlags);       if (!is.null(MyPS) && !is.null(MyPS$Chdf) &&        is.numeric(MyPS$Chdf)  && !is.null(MyPS$taubarnu) &&         is.numeric(MyPS$taubarnu)) {         try(.self$MyPS <- MyPS, silent=TRUE);         }      try(.self$DoMax <- DoMax);       try(.self$RStart <- RStart);        if (is.null(RandomInfoList) || !is.list(RandomInfoList)) {        if (is.numeric(RandomInfoList)) {          try(.self$RandomInfoList <- as.list(RandomInfoList));        } else {          try(.self$RandomInfoList <- list())        }      } else {        try(.self$RandomInfoList <- RandomInfoList);      }      if (is.null(ListChainIters) || !is.list(ListChainIters)) {        if (is.numeric(ListChainIters) || is.integer(ListChainIters)) {          try(.self$ListChainIters <- as.list(ListChainIters));        } else {          try(.self$ListChainIters <- list())        }      } else {        try(.self$ListChainIters <- ListChainIters);      }      try(.self$LengthPiACodaBuffer <- as.integer(round(LengthPiACodaBuffer)));      try(.self$LengthSigCodaBuffer <- as.integer(round(LengthSigCodaBuffer)));      try(.self$.ProbCodaList <- NULL);  try(.self$AllTempCodaLists <- list());    try(.self$FullFileD <- "");     try(.self$FullFileI <- "");    try(.self$DefaultWriteNewProbBuffer <- DefaultWriteNewProbBuffer);        TryToSetText = "    try(.self$DoLongCI <- as.logical(DoLongCI));    try(.self$FullFileBetaAllDraw <- \"\");    if (CpBuffLongCI <= 0 && .self$DoLongCI == TRUE) {      if (p < 1000) {        try(.self$CpBuffLongCI <- as.integer(max(          ceiling(.self$MaxGibbsIters/10), 10)));      } else {        try(.self$CpBuffLongCI <- as.integer(max(ceiling(5*10^6/p), 1)));      }    } else {       try(.self$CpBuffLongCI <- as.integer(CpBuffLongCI));    }     if (length(.self$CpBuffLongCI) == 0) {      try(.self$CpBuffLongCI <- as.integer(10));    }    ";    try(eval(parse(text=TryToSetText)));         if (.self$Verbose >= 3) {      print("BayesSpikeR5: Set dfTNoise/Robit.");      flush.console();    }    if (is.null(dfTNoise) || !is.numeric(dfTNoise)) {      try(.self$dfTNoise <- -1);    } else {      try(.self$dfTNoise <- dfTNoise);    }    if (is.null(dfRobit) || !is.numeric(dfRobit)) {      try(.self$dfRobit <- -1);    } else {      try(.self$dfRobit <- dfRobit);    }    if (.self$Verbose >= 3) {      print("BayesSpikeR5: Set Alternate Weights.");      flush.console();    }    if (AlterWeightFlag == TRUE  &&      (.self$dfTNoise >= 0.0 || .self$dfRobit >= 0.0)) {      try(.self$AlterWeightFlag <- TRUE);      try(.self$AlterdfTNoise <- .self$dfTNoise);       try(.self$AlterdfRobit <- .self$dfRobit);      try(.self$dfRobit <- -1);  try(.self$dfTNoise <- -1);      if (LengthAlterWeightBuffer > 1.0) {        try(.self$LengthAlterWeightBuffer <- as.integer(          round(LengthAlterWeightBuffer)), silent=TRUE);      } else {        try(.self$LengthAlterWeightBuffer <-           as.integer(100), silent=TRUE);      }      if (is.numeric(AlterWeightTemperature) && AlterWeightTemperature > 0.0) {        try(.self$AlterWeightTemperature <- AlterWeightTemperature);      } else {        try(.self$AlterWeightTemperature <- as.numeric(1.0));      }     try(.self$AlterWeightFile <- "");      try(.self$.AlterWeightCodaList <- NULL);          } else {      try(.self$AlterWeightFlag  <- FALSE);      try(.self$AlterdfTNoise <- -1);        ##try(.self$AlterdfTRobit <- -1);      try(.self$AlterWeightFile <- "");      try(.self$.AlterWeightCodaList <- NULL);      try(.self$LengthAlterWeightBuffer <- as.integer(0), silent=TRUE);    }      if (.self$Verbose > 1) {      print("BayesSpikeR5: Assign tauEndList.");      flush.console();    }        try(.self$EEDoSort <- as.logical(EEDoSort));    if (StartOldEELoad  > .self$MaxGibbsIters) {      try(.self$StartOldEELoad <- as.integer(1));    } else {      try(.self$StartOldEELoad <- as.integer(round(StartOldEELoad)));    }    try(.self$OnChainIter <- as.integer(0))    ##try(.self$.CodaSubList <- NULL);    ##try(.self.CCodaSubVector <- as.integer(NULL));        ##  try(tauEndList <<- tauEndList);       if (length(tauEndList) > 0 && length(sOnTau) > 0 && length(sOnTau) < length(tauEndList)) {        try(.self$sOnTau <- c(sOnTau, rep(0, length(sOnTau) - length(tauEndList)) ));        }  else if (length(tauEndList) > 0 && length(sOnTau) >= length(tauEndList)) {        try(.self$sOnTau <- sOnTau[1:length(tauEndList)]);      } else if (length(tauEndList) > 0) {        try(.self$sOnTau <- rep(0, length(tauEndList)));      } else {        try(.self$sOnTau <- vector("numeric", 0));      }      if (is.null(tauEndList)) {        try(.self$FirstRandom <- p);          try(.self$tauEndList <- vector("numeric",0));      } else if (FirstRandom >= 0 && length(tauEndList) >=1 && FirstRandom > tauEndList[1]) {        print(paste("Error: tauEndList[1] = ", tauEndList[1],           " but FirstRandom = ", FirstRandom, sep=""));  flush.console();        try(.self$FirstRandom <- p);         try(.self$tauEndList <- vector("numeric", 0));        tryCatch("Error; returning because FirstRandom exceeds tauEndList!");      } else if (FirstRandom == 0  && length(tauEndList) >= 1) {        try(.self$FirstRandom <- 1);          try(.self$tauEndList <- as.vector(tauEndList+1));      } else if (FirstRandom >= 0 && length(tauEndList) >= 1) {        try(.self$FirstRandom <- as.integer(FirstRandom));         try(.self$tauEndList <- as.vector(tauEndList));      } else {        try(.self$FirstRandom <- as.integer(p));         try(.self$tauEndList <- vector("numeirc", 0));      }      if (.self$FirstRandom == 0) {        try(.self$tauFixed <- NULL);      } else if (.self$FirstRandom == 1) {         try(.self$tauFixed <- -1);      } else if (.self$FirstRandom == p &&         is.null(tauEndList) || length(tauEndList) <= 0) {        if (is.null(tauFixed)) {          try(.self$tauFixed <- rep(1, .self$p));        } else if (length(tauFixed) == p) {          try(.self$tauFixed <- as.numeric(tauFixed));        } else if (length(tauFixed) == 1) {          try(.self$tauFixed <- tauFixed[1]);        } else if (length(tauFixed) == 3) {          try(.self$tauFixed <- tauFixed);        } else if (length(tauFixed) < .self$p && length(tauFixed) >= 2) {          try(.self$tauFixed <- tauFixed );        } else {          try(.self$tauFixed <- 40);        }      } else if (.self$FirstRandom > 1 && is.null(tauFixed)) {        try(.self$tauFixed <- rep(40, .self$FirstRandom-1));      } else if (.self$FirstRandom > 1 &&         length(tauFixed)>= 1 && length(tauFixed) > .self$FirstRandom -1) {        try(.self$tauFixed <- tauFixed);       } else if (length(tauFixed) >= .self$FirstRandom) {        try(.self$tauFixed <- tauFixed);      } else if (length(tauFixed) >= 1 && .self$FirstRandom < 0 &&        length(tauFixed) > .self$p) {        try(.selftauFixed <- tauFixed);      } else if (length(tauFixed) >= 1 && .self$FirstRandom < 0) {        try(.self$tauFixed <- c(tauFixed));      } else {        try(.self$tauFixed <- rep(1000, .self$FirstRandom-1));      }      try(.self$CodaTable <- matrix(0,0,0));        try(.self$CodaList <- NULL);                   try(.self$NewWrite <- NewWrite);      try(.self$DoSaveTBSR5 <- as.logical(DoSaveTBSR5));      try(.self$DoSave <- TRUE);      if (is.logical(DoSave)) {        try(.self$DoSave <- as.logical(DoSave));        if (DoSave == FALSE) {          try(.self$SaveDir <- "NOSAVE");          try(.self$FileName <- "");          try(.self$FileSave <- "");           try(.self$DoSave <- FALSE);        } else {          NewSaveDir <- sub("\\\\", "/", as.character(SaveDir));          ##eval(parse(text=MyEvalState));          try(.self$SaveDir <- as.character(NewSaveDir));          FileNameChangeText <-   "          if (FileName == \"ABSChain\") {            FileName <- paste(FileName, \"n\", .self$n,            \"p\", .self$p, \"RNum\", floor(runif(1,0,100)), \"Go\", sep=\"\");          }";          try(eval(parse(text=FileNameChangeText)));          try(.self$FileName <- as.character(FileName));          try(.self$FileSave <- as.character(FileSave) );           try(.self$DoSave <- TRUE);        }      } else if (is.null(DoSave)) {         try(.self$DoSave <- FALSE);         try(.self$SaveDir <- "NOSAVE");        try(.self$FileName <- "");        try(.self$FileSave <- "");      } else if (is.numeric(DoSave) && DoSave <= 0.0) {         try(.self$DoSave <- FALSE);        try(.self$SaveDir <- "NOSAVE");        try(.self$FileName <- "");        try(.self$FileSave <- "");       } else {          try(.self$DoSave <- TRUE);         NewSaveDir <- sub("\\\\", "/", as.character(SaveDir));        ##eval(parse(text=MyEvalState));        try(.self$SaveDir <- as.character(NewSaveDir));           FileNameChangeText <-   "          if (FileName == \"ABSChain\") {            FileName <- paste(FileName, \"n\", .self$n,            \"p\", .self$p, \"RNum\", floor(runif(1,0,100)), \"Go\", sep=\"\");          }";          try(eval(parse(text=FileNameChangeText)));        try(.self$FileName <- as.character(FileName) );         try(.self$FileSave <- as.character(FileSave) );       }      if (.self$Verbose >= 1) {        print("Now Assigning SubSetCoords and setting up SubCodaList. ");        flush.console();      }      if (!is.null(SubSetCoords) && length(SubSetCoords) >= 1) {        MyTxt = "        SubSetCoords = sort(unique(round(SubSetCoords)));        SubSetCoords = SubSetCoords[SubSetCoords >= 1 && SubSetCoords <= p];        try(.self$.SubSetCoords <- as.integer(SubSetCoords-1));        ";        eval(parse(text=MyTxt));      } else {        try(.self$.SubSetCoords <- vector("integer", 0));      }      if (!is.null(SubSetTau) && length(SubSetTau) >= 1) {        MyTxt = "        SubSetTau = sort(unique(round(SubSetTau)));        SubSetTau = SubSetTau[SubSetTau >= 1 && SubSetTau <= length(tauEndList)];        try(.self$.SubSetTau <- as.integer(SubSetTau-1));        ";        eval(parse(text=MyTxt));      } else {        try(.self$SubSetTau <- vector("integer", 0));       }      try(.self$.SubCodaVector <- as.integer(NULL));      try(.self$.SubCodaList <- NULL); try(.self$.SubProbCodaList <- NULL);       try(.self$.SubCodaLongList <- NULL);      if (.self$Verbose >= 1) {        print("Finished setting up SubSetCoords. ");        flush.console();      }      if (!is.logical(DoLogitPostProb)) {        try(.self$DoLogitPostProb <- FALSE);      } else {        try(.self$DoLogitPostProb <- DoLogitPostProb);      }            try(.self$PriorProbTau <- PriorProbTau);      try(.self$PriorProbFixed <- PriorProbFixed);            try(.self$OnFile <- "");  try(.self$OldFile <-"");      try(.self$NumChains <- NumChains);      try(.self$DoRecord <- DoRecord);      if (MaximizeMeCauchyTotalIters <= 0) {         try(.self$MaximizeMeCauchyTotalIters <- 20);       }  else {         try(.self$MaximizeMeCauchyTotalIters <- MaximizeMeCauchyTotalIters); }      if (CauchyEpsilon <= 0) {        try(.self$CauchyEpsilon <- .00001);} else{        try(.self$CauchyEpsilon <- CauchyEpsilon);      }    if (.self$Verbose > 1) {      print("BayesSpikeR5: Assign AFD and PutRNG.");      flush.console();    }         try(.self$AFD <- AFD);       if (is.logical(PutRNG) && PutRNG == TRUE) {        try(.self$PutRNG <- as.numeric(1.0));      } else if (is.logical(PutRNG) && PutRNG == FALSE) {        try(.self$PutRNG <- as.numeric(0.0));      } else {        try(.self$PutRNG <- as.numeric(PutRNG));      }      if (is.null(DependenciesTau)) {        try(.self$DependenciesTau <- list())      } else if (!is.list(DependenciesTau)) {        try(.self$DependenciesTau <- as.list(DependenciesTau));      } else {        try(.self$DependenciesTau <- DependenciesTau);       }      if (is.null(DependenciesFixed)) {        try(.self$DependenciesFixed <- list())      } else if (!is.list(DependenciesFixed)) {        try(.self$DependenciesFixed <- as.list(DependenciesFixed));      } else {        try(.self$DependenciesFixed <- DependenciesFixed);       }      if (is.null(ListSaveFiles)) {        try(.self$ListSaveFiles <- vector("character",0))      } else if (!is.list(ListSaveFiles)) {        try(.self$ListSaveFiles <- as.vector(ListSaveFiles));      } else {        try(.self$ListSaveFiles <- ListSaveFiles);       }     ## if (is.null(ListAllSaveFiles)) {     ##   try(.self$ListAllSaveFiles <- vector("character",0))     ## } else if (!is.list(ListAllSaveFiles)) {     ##   try(.self$ListAllSaveFiles <- as.vector(ListAllSaveFiles));     ## } else {     ##   try(.self$ListAllSaveFiles <- ListAllSaveFiles);      ## }      try(.self$EarlyEndStep <- as.integer(EarlyEndStep));       try(.self$EarlyEndtt <- as.integer(EarlyEndtt));      try(.self$tauPriordf <- as.numeric(tauPriordf));       try(.self$tauPriorMean <- as.numeric(tauPriorMean));       try(.self$ttStart <- as.integer(ttStart));      try(.self$CodaTableNames <- as.character(CodaTableNames));      try(.self$DoChainIters <- as.integer(DoChainIters));            if (!exists("TempCoda") || is.null(TempCoda)) {        try(.self$TempCoda <- vector("numeric",0));      } else {        try(.self$TempCoda <- as.vector(TempCoda));       }      if (!exists("TempCodaIDs") || is.null(TempCodaIDs)) {        try(.self$TempCodaIDs <- vector("numeric", 0));      } else {        try(.self$TempCodaIDs <- as.numeric(TempCodaIDs) );      }      if (is.null(NoShrinkFixed)) {        try(.self$NoShrinkFixed <- vector("numeric",0));        try(.self$NoShrinkFixedPrior <- vector("numeric",0));      } else if (is.logical(NoShrinkFixed)  && NoShrinkFixed == FALSE) {        try(.self$NoShrinkFixed <- vector("numeric",0), silent=TRUE);          try(.self$NoShrinkFixedPrior  <- vector("numeric",0), silent=TRUE);      } else if (is.logical(NoShrinkFixed) && NoShrinkFixed == TRUE) {        if (.self$FirstRandom >= 1) {          try(.self$NoShrinkFixed <- (1:(.self$FirstRandom-1)),            silent=TRUE);          try(.self$NoShrinkFixedPrior <-             rep(100, length(.self$NoShrinkFixed)),            silent=TRUE);        } else {          try(.self$NoShrinkFixed <- 1:p,silent=TRUE);          try(.self$NoShrinkFixedPrior <- rep(100, p), silent=TRUE);        }      } else {        try(.self$NoShrinkFixed <- NoShrinkFixed, silent=TRUE);         try(.self$NoShrinkFixedPrior <- as.vector(NoShrinkFixedPrior), silent=TRUE);      }      if (is.null(NoShrinkRandom)) {        try(.self$NoShrinkRandom <- vector("numeric",0));        try(.self$NoShrinkRandomPrior <- vector("numeric",0));      } else if (is.logical(NoShrinkRandom)  && NoShrinkRandom == FALSE) {        try(.self$NoShrinkRandom <- vector("numeric",0), silent=TRUE);          try(.self$NoShrinkRandomPrior  <- vector("numeric",0), silent=TRUE);      } else if (is.logical(NoShrinkRandom) && NoShrinkRandom == TRUE) {        if (length(.self$tauEndList) >= 1) {          try(.self$NoShrinkRandom <- (1:(length(.self$tauEndList)-1)),            silent=TRUE);          try(.self$NoShrinkRandomPrior <-             rep(100, length(.self$NoShrinkRandom)),            silent=TRUE);        }       } else {        try(.self$NoShrinkRandom <- NoShrinkRandom, silent=TRUE);         try(.self$NoShrinkRandomPrior <- as.vector(NoShrinkRandomPrior), silent=TRUE);      }    if (.self$Verbose > 0) {      print("BayesSpikeR5: Finished NoshrinkTau, now onto set into ListOb.");      flush.console();    }        ##########################################################################    ##  Default Quantile System      if (is.null(KeepPosteriorQuantiles) || !is.numeric(KeepPosteriorQuantiles)) {     try(.self$.KeepPosteriorQuantiles <- c(.5,.25,.75,.05,.95,.025,.975,.01,.99));   } else {     try(.self$.KeepPosteriorQuantiles <- KeepPosteriorQuantiles);   }   try(.self$.BetaSymmetricQuantiles <- matrix(0,0,0));   try(.self$.BetaSymmetricUnshrinkQuantiles <- matrix(0,0,0));   try(.self$.TauSymmetricQuantiles <- matrix(0,0,0));   try(.self$.SigmaSymmetricQuantiles <- vector("numeric",0));   try(.self$.PiASymmetricQuantiles <- matrix(0,0,0));   try(.self$.BetaHPDQuantiles <- matrix(0,0,0));   try(.self$.BetaHPDUnshrinkQuantiles <- matrix(0,0,0));   try(.self$.TauHPDQuantiles <- matrix(0,0,0));   try(.self$.SigmaHPDQuantiles <- vector("numeric",0));   try(.self$.PiAHPDQuantiles <- matrix(0,0,0));       #################################################################    ##  Code here locks MyR to the BAYESSPIKENAMESPACE environment;    ##     ##BAYESSPIKENAMESPACE <- environment()    if (FALSE) {    if (NInstance > 0) {      try(eval(parse(text=GetG0Text(".ListBayesSpikeOb", "globalenv()"))));      if (NInstance > length(.ListBayesSpikeOb)) {        try(.self$NInstance <-  as.integer(length(.ListBayesSpikeOb)+1) );      }  else {        try(.self$NInstance <- as.integer(round(NInstance)) );      }      try(.ListBayesSpikeOb[[.self$NInstance]] <- .self);      try(eval(parse(text=LockGText(".ListBayesSpikeOb", "globalenv()"))));    } else {      try(eval(parse(text=GetG0Text(".ListBayesSpikeOb", "globalenv()"))));      try(.self$NInstance <- as.integer(length(.ListBayesSpikeOb)+1) );      try(.ListBayesSpikeOb[[.self$NInstance]] <- .self);      try(eval(parse(text=LockGText(".ListBayesSpikeOb", "globalenv()"))));     }      try(eval(parse(text=GetG0Text(".NumBayesSpikeOb", "globalenv()"))));    try(.self$.NumBayesSpikeOb <- as.integer(0 + 1));    try(eval(parse(text=LockGText(".NumBayesSpikeOb", "globalenv()"))));    }    if (is.null(.self$X)) {      print("After new BayesSpikeR5: X is null!"); flush.console();    }    if (is.null(.self$.X)) {      print("After new BayesSpikeR5: .X is Null!"); flush.console();    }    ##print("BayesSpikeR5 Finish"); flush.console();    if (.self$Verbose > 0) {      t2 = proc.time();      APrintText = "      t2 = t2[1:3];  t1 = t1[1:3];      print(paste(\" BayesSpikeR5, took (\", paste(round(t2-t1, 4), collapse=\", \"),        \") to finish. \", sep=\"\"));      ";      try(eval(parse(text=APrintText)));    }    if (is.null(.self$sOnTau) || length(.self$sOnTau)  <= 0 ||      length(.self$sOnTau) <= 0 || is.null(.self$tauEndList)      || length(.self$tauEndList) <= 0) {      try(.self$DoRecord[2] <- 0); try(.self$DoRecord[7] <- 0);     }    eval(parse(text=GetG0Text(".ListBayesSpikeOb", "globalenv()")));        if (.self$dfRobit >=0  &&         ((is.logical(WriteYBuffer) && WriteYBuffer == TRUE) ||         (is.numeric(WriteYBuffer) && WriteYBuffer >.1)         ) ) {      try(.self$WriteYBuffer <- as.logical(TRUE));      if ((is.logical(NewYBufferWrite) && NewYBufferWrite == FALSE) ||        (is.numeric(NewYBufferWrite) && NewYBufferWrite >= 0.0)) {        try(.self$NewYBufferWrite <- as.logical(FALSE), silent=TRUE);      } else {        try(.self$NewYBufferWrite <- as.logical(TRUE), silent=TRUE);      }     }  else {       try(.self$WriteYBuffer <- FALSE, silent=TRUE);       try(.self$NewYBufferWrite <- TRUE, silent=TRUE);    }    if ((.self$dfRobit > 0 || .self$dfTNoise > 0) &&         ((is.logical(WriteWeightBuffer) && WriteWeightBuffer == TRUE) ||         (is.numeric(WriteWeightBuffer) && WriteWeightBuffer >.1)        )) {      try(.self$WriteWeightBuffer <- as.logical(TRUE), silent=TRUE);      if ((is.logical(NewWeightBufferWrite) && NewWeightBufferWrite == FALSE) ||        (is.numeric(NewWeightBufferWrite) && NewWeightBufferWrite == 0.0)) {        try(.self$NewWeightBufferWrite <- as.logical(FALSE), silent=TRUE);      } else {        try(.self$NewWeightBufferWrite <- TRUE);      }     }  else {       try(.self$WriteWeightBuffer <- as.logical(FALSE), silent=TRUE);         try(.self$NewWeightBufferWrite <- as.logical(TRUE), silent=TRUE);    }    if (!is.numeric(LengthYBuffer) || LengthYBuffer <= 0) {       try(.self$LengthYBuffer <- as.integer(100), silent=TRUE);    } else { try(.self$LengthYBuffer <-       as.integer(round(LengthYBuffer)),      silent=TRUE);}    if (!is.numeric(LengthWeightBuffer) || LengthWeightBuffer <= 0){       try(.self$LengthWeightBuffer <- as.integer(100),        silent=TRUE);    } else {      try(.self$LengthWeightBuffer <- as.integer(round(LengthWeightBuffer)),        silent=TRUE);    }    try(.self$AverageIIWeight <- NULL);    try(.self$.YCodaList <- NULL);  try(.self$.WeightCodaList <- NULL);    if (!exists("SubYList")) { try(.self$SubYList <- vector("integer",0));     } else if (!is.integer(SubYList)) {      try(.self$SubYList <- as.integer(SubYList), silent=TRUE);    } else {      try(.self$SubYList <- SubYList, silent=TRUE);    }    .self;  ## return self.    },    FullCopy = function() {    ##'Save the current object on the file    ##    in R external object format.    ##   '    if (.self$Verbose >= 1) {      print("Starting TBSR5 FullCopy ."); flush.console();    }            MyST <- "PiAStart <- .5";  eval(parse(text=MyST));       MyST <- "DoLogitNonePostPreProb <- 0"; eval(parse(text=MyST));    if (is.null(.self$ABayesSpikeCL)) {     aa = .self;  StartRunProbVector = NULL;     EEMergeEvery = FALSE;      ATT <- "DoEEProbSort <- .self$DoEEProbSort;       sOnTau = .self$sOnTau; RunSumBeta <- NULL;  RunMoreZero = NULL;       RunLessZero <- NULL;       AlterWeightFiles = NULL;       tauFixed = .self$tauFixed; CodaList = NULL;       try(CodaList <- .self$CodaList, silent=TRUE);       OnPiA = .self$OnPiA;       try(RunMoreZero <- NULL);  try(RunLessZero <- NULL);       try(RunSumBeta <- NULL);       try(RunProbVector <- NULL);  try(TotEveryProbVector <- NULL);       try(StartRunProbVector <- NULL);       try(RegionWidth <- -1);  try(RunProbRegionVector <- NULL);       DoRecord = .self$DoRecord; OnSigma = .self$OnSigma;        try(dfTNoise <- .self$dfTNoise, silent=TRUE);          try(dfRobit <- .self$dfRobit, silent=TRUE);        try(HowSample <- .self$HowSample, silent=TRUE);          try(Tempii <- .self$Tempii, silent=TRUE);        try(AllEigenValues <- .self$AllEigenValues, silent=TRUE);        try(AllEigenVectors <- .self$AllEigenVectors, silent=TRUE);        try(TimePartsList <- NULL);        try(AlterWeightFiles <- .self$.AlterWeightFiles, silent=TRUE);        try(PiAStart <- .self$PiAStart);        try(DoLogitNonePostPreProb <- 0);        gPrior <- 0.0;     ";     eval(parse(text=ATT));     EEProbSortWidth = 0; PrintIter <- 0;     try(OtherNameCodaList <- NULL);     CenteredColumns <- NULL; DeCenteredCodaList <- NULL;    } else {      aa = .self$MBS;      aMBS <- .self$ABayesSpikeCL      StartRunProbVector = .self$MBS$StartRunProbVector;      EEMergEEvery = FALSE;   RunMoreZero <- NULL;  RunLessZero <- NULL;      RunSumBeta <- .self$MBS$RunSumBeta;      RunMoreZero <- .self$MBS$RunMoreZero;  RunLessZero <- .self$MBS$RunLessZero;      APT <- "      try(PiAStart <- .self$PiAStart);      try(RegionWidth <- .self$MBS$RegionWidth);      ";      eval(parse(text=APT));      try(RunProbRegionVector <- .self$MBS$RunProbRegionVector);      EEProbSortWidth = 0; PrintIter <- 0;      try(EEMergeEvery <- .self$MBS$EEMergeEvery, silent=TRUE);      CenteredColumns <- NULL;      DeCenteredCodaList <- NULL;       try(DoLogitNonePostPreProb <- .self$MBS$DoLogitNonePostPreProb);      try(CenteredColumns <- .self$MBS$CenteredColumns);      try(TimePartsList <- .self$MBS$RsTimePartsList);      if (!is.null(CenteredColumns) && length(CenteredColumns) >= 1 &&        !is.null(.self$MBS$CodaList) && length(.self$MBS$CodaList) >= 1  &&        sum(abs(.self$MBS$CodaList[[1]])) >= .01) {        try(DeCenteredCodaList <- .self$MBS$DeCenteredCodaList);              }      ATT = "          try(RunProbVector <- NULL);  try(TotEveryProbVector <- NULL);        try(StartRunProbVector <- NULL);         try(RegionWidth <- -1);  try(RunProbRegionVector <- NULL);        try(RegionWidth <- .self$ABayesSpikeCL$RegionWidth);        try(RunSumBeta <- .self$ABayesSpikeCL$RunSumBeta);        try(RunMoreZero <- .self$ABayesSpikeCL$RunMoreZero);        try(RunLessZero <- .self$ABayesSpikeCL$RunLessZero);        try(AlterWeightFiles <- .self$.AlterWeightFiles)        try(RunProbRegionVector <- .self$ABayesSpikeCL$RunProbRegionVector)           try(RunProbVector <- .self$ABayesSpikeCL$RunProbVector);        try(TotEveryProbVector <- .self$ABayesSpikeCL$TotEveryProbVector);        try(StartRunProbVector <- .self$ABayesSpikeCL$StartRunProbVector);        try(AllEigenValues <- .self$ABayesSpikeCL$AllEigenValues, silent=TRUE);        try(AllEigenVectors <- .self$ABayesSpikeCL$AllEigenVectors, silent=TRUE);        DoEEProbSort = FALSE;        try(PiAStart <- .self$PiAStart);        try(DoEEProbSort <- .self$DoEEProbSort, silent=TRUE);        sOnTau = aMBS$sOnTau;        tauFixed = aMBS$tauFixed;        CodaList = NULL;        gPrior <- 0.0; try(gPrior <- .self$ABayesSpikeCL$gPrior);        try(CodaList <- aMBS$CodaList, silent=TRUE);        OnPiA = aa$OnPiA;        DoRecord = aMBS$DoRecord; OnSigma = aa$OnSigma;        dfTNoise = aMBS$dfTNoise;  dfRobit = aa$dfRobit;        HowSample = aMBS$HowSample;        Tempii = aMBS$Tempii;        RunSumBeta = aMBS$RunSumBeta;  RunLessZero=aMBS$RunLessZero;        RunMoreZero = aMBS$RunMoreZero;        try(TimePartsList <- aMBS$TimePartsList);        try(OtherNameCodaList <- aMBS$OtherNameCodaList);        try(AllEigenValues <- aMBS$AllEigenValues, silent=TRUE);        try(AllEigenVectors <- aMBS$AllEigenVectors, silent=TRUE);      ";      eval(parse(text=ATT));      try(EEProbSortWidth <- .self$MBS$EEProbSortWidth, silent=TRUE);      try(PrintIter <- .self$MBS$PrintIter, silent=TRUE);    }  InitiateTime <- NULL;  try(InitiateTime <- .self$ABayesSpikeCL$InitiateTime);  SecondInitiateTime <- NULL;  try(SecondInitiateTime <- .self$ABayesSpikeCL$SecondInitiateTime);  CompleteTime <- NULL;  try(CompleteTime <- .self$ABayesSpikeCL$CompleteTime);    MyList <- list(.X = .self$.X, .Y = .self$.Y, .Z = .self$.Z,      BetaStart = .self$BetaStart, Beta = .self$Beta,      tauEndList = .self$tauEndList, sOnTau = sOnTau,      FirstRandom = .self$FirstRandom, OldCodaNames = .self$OldCodaNames,      FirstCLN = .self$FirstCLN,  CodaTable = .self$CodaTable, CodaList = CodaList,   ##CodaSubList = .self$.CodaSubList, CCodaSubVector = .self$.CCodaSubVector,   NInstance = .self$NInstance, tauFixed = tauFixed,   TypeFixedPrior = .self$TypeFixedPrior,  HowSample = HowSample, OnSigma = OnSigma, OnPiA = OnPiA,  PiAStart=PiAStart,  PiAPrior = .self$PiAPrior, SigmaPrior = .self$SigmaPrior,   dfRobit = dfRobit,  DoRecord = DoRecord, dfTNoise = dfTNoise,   InitFlags = .self$InitFlags,  MaxGibbsIters = .self$MaxGibbsIters, NumChains = .self$NumChains,  DependenciesTau = .self$DependenciesTau,  DependenciesFixed = .self$DependenciesFixed,   CauchyEpsilon = .self$CauchyEpsilon,  AllEigenVectors = AllEigenVectors, PreRunMaxGibbsIters = .self$PreRunMaxGibbsIters,  AllEigenValues=AllEigenValues, DoLogitNonePostPreProb = DoLogitNonePostPreProb,  MaximizeMeCauchyTotalIters = .self$MaximizeMeCauchyTotalIters,  tauPriordf = .self$tauPriordf, tauPriorMean = .self$tauPriorMean,   ttStart = .self$ttStart, TimePartsList = TimePartsList,  EarlyEndStep = .self$EarlyEndStep, EarlyEndtt = .self$EarlyEndtt,   DoSave = .self$DoSave,  DoSaveTBSR5 = .self$DoSaveTBSR5,  FileSave = .self$FileSave, SaveDir = .self$SaveDir,   FileName = .self$FileName,  NewWrite = .self$NewWrite,  DoMax = .self$DoMax, PutRNG = .self$PutRNG, MyPS = .self$MyPS,    CodaTableNames = .self$CodaTableNames,  RStart = .self$RStart, Verbose = .self$Verbose,   ListSaveFiles = .self$ListSaveFiles,   ##ListAllSaveFiles = .self$ListAllSaveFiles,   TempCoda = .self$TempCoda,   TempCodaIDs = .self$TempCodaIDs,    ListChainIters = .self$ListChainIters,       FillFilePostProbBuffer = .self$FillFilePostProbBuffer,    LengthPostProbBuffer = .self$LengthPostProbBuffer,    NoShrinkFixed = .self$NoShrinkFixed,    NoShrinkRandom = .self$NoShrinkRandom,    NoShrinkFixedPrior = .self$NoShrinkFixedPrior,    NoShrinkRandomPrior = .self$NoShrinkRandomPrior,      DoLogitPostProb = .self$DoLogitPostProb,     DefaultWriteNewProbBuffer = .self$DefaultWriteNewProbBuffer,    WriteYBuffer = .self$WriteYBuffer, NewYBufferWrite = .self$NewYBufferWrite,    WriteWeightBuffer=.self$WriteWeightBuffer,     NewWeightBufferWrite= .self$NewWeightBufferWrite,    LengthYBuffer = .self$LengthYBuffer,     LengthWeightBuffer = .self$LengthWeightBuffer,    FullFileYBuffer = .self$FullFileYBuffer,     FullFileWeightBuffer = .self$FullFileWeightBuffer,    SpliceMove = .self$SpliceMove,    EEDoSort = .self$EEDoSort,     StartOldEELoad = .self$StartOldEELoad,    FullFileD = .self$FullFileD,     FullFileI = .self$FullFileI,    InitiateTime = InitiateTime,    SecondInitiateTime = SecondInitiateTime,    CompleteTime = CompleteTime,    StartRunProbVector = StartRunProbVector,    AllTempCodaLists = .self$AllTempCodaLists,    OldFile = .self$OldFile, OnFile=.self$OnFile,    DoChainIters = .self$DoChainIters,    LengthPiACodaBuffer = .self$LengthPiACodaBuffer,     LengthSigCodaBuffer = .self$LengthSigCodaBuffer,    AlterWeightFlag =.self$AlterWeightFlag,     AlterdfTNoise = .self$AlterdfTNoise,     AlterdfRobit = .self$AlterdfRobit,    .MIP = .self$.MIP,  MaxIters = .self$MaxIters,    EEMergeEvery = EEMergeEvery, DoEEProbSort = DoEEProbSort,    PrintIter = PrintIter,    EEProbSortWidth = EEProbSortWidth,    AlterWeightFile = .self$AlterWeightFile,    .AlterWeightCodaList = .self$.AlterWeightCodaList,    LengthAlterWeightBuffer = .self$LengthAlterWeightBuffer,        AlterWeightTemperature=.self$AlterWeightTemperature,    .SigmaCodaList = .self$.SigmaCodaList,     .TauCodaList = .self$.TauCodaList,     .PiACodaList = .self$.PiACodaList,     .ProbCodaList = .self$.ProbCodaList,     PriorProbTau = .self$PriorProbTau, PriorProbFixed = .self$PriorProbFixed,    n=.self$n, p=.self$p,    RandomInfoList = .self$RandomInfoList,   DoEEProbSort = .self$DoEEProbSort,   TemperatureList = .self$TemperatureList,    TemperatureDecreasingRate=.self$TemperatureDecreasingRate,   Tempii = Tempii,   LengthPostProbBuffer = .self$LengthPostProbBuffer,   SubSetCoords = .self$SubSetCoords,   SubSetTau = .self$SubSetTau,    .YCodaList = .self$.YCodaList,    .AlterWeightFiles = AlterWeightFiles,   .WeightCodaList = .self$.WeightCodaList,   SubCodaList = .self$.SubCodaList,    FullFileBetaAllDraw = .self$FullFileBetaAllDraw,   SubCodaLongList = .self$.SubCodaLongList,   BetaSymmetricLongQuantiles = .self$.BetaSymmetricLongQuantiles,   BetaHPDLongQuantiles = .self$.BetaHPDLongQuantiles,   OtherSubCoda = .self$OtherSubCoda,   CpBuffLongCI = .self$CpBuffLongCI,   OtherNameCodaList = OtherNameCodaList,   DoLongCI = .self$DoLongCI,   SubCodaVector = .self$.SubCodaVector, SubYList = .self$SubYList,   KeepPosteriorQuantiles = .self$.KeepPosteriorQuantiles,   BetaSymmetricQuantiles = .self$.BetaSymmetricQuantiles,   BetaSymmetricUnshrinkQuantiles = .self$.BetaSymmetricUnshrinkQuantiles,   SigmaSymmetricQuantiles = .self$.SigmaSymmetricQuantiles,   TauSymmetricQuantiles = .self$.TauSymmetricQuantiles,   PiASymmetricQuantiles = .self$.PiASymmetricQuantiles,   BetaHPDQuantiles = .self$.BetaHPDQuantiles,   BetaHPDUnshrinkQuantiles = .self$.BetaHPDUnshrinkQuantiles,   SigmaHPDQuantiles = .self$.SigmaHPDQuantiles,   TauHPDQuantiles = .self$.TauHPDQuantiles,   PiAHPDQuantiles = .self$.PiAHPDQuantiles,   StartRunProbVector = StartRunProbVector,   TotEveryProbVector = TotEveryProbVector,    RunProbVector = RunProbVector, RunLessZero=RunLessZero,   RunMoreZero=RunMoreZero, RunSumBeta=RunSumBeta,   RegionWidth = RegionWidth,   RunProbRegionVector = RunProbRegionVector,   CenteredColumns = CenteredColumns,    DeCenteredCodaList = DeCenteredCodaList, gPrior = gPrior   );    return(MyList);  },   unsave=function(IReallyWantToDoThis=FALSE) {    if (IReallyWantToDoThis == FALSE) {      print("UnSave: Sorry I ReallyWantToDoThis is FALSE we won't continue!");      flush.console(); return(-1);    }    if (IReallyWantToDoThis != TRUE) {      print("UnSave: Sorry I ReallyWantToDoThis is not TRUE we won't continue!");      flush.console(); return(-1);    }    if (.self$SaveDir == ""  || !is.character(.self$SaveDir) || .self$SaveDir%in% c("NOSAVE", "NoSave")) {      print("UnSave: Sorry, no SaveDir!");      return(-1);    }    Oldwd <- getwd();    MyGo = 0;    MyEvalText <-    "    setwd(.self$SaveDir);    MyGo = 1; "    try(eval(parse(text=MyEvalText)));    if (MyGo == 0) {      print("UnSave: Directory Does Not Exist, Leaving. "); flush.console();      return(-1);    }    ACount <- 0;    MyLL <- unlist(list.files());    if (length(MyLL) == 0) {      print("UnSave: Nothing in Dir!");      return(0);    }    if (any(MyLL == "FinalOutputSave")) {      try(unlink(paste("FinalOutputSave//SaveTBSR5.RData", sep="")))      try(unlink(paste("FinalOutputSave//PartSaveListTBSR5.RData", sep="")))      try(unlink("FinalOutputSave"));      ACount <- ACount+2;    }    if(length(MyLL) >= 1) {    for (ii in 1:length(MyLL)) {      if (substr(MyLL[ii],nchar(MyLL[ii])-nchar(".bin")+1, nchar(MyLL[ii])) == ".bin") {        try(unlink(MyLL[ii]));        ACount <- ACount+1;      }    }    }    LSS <- unlist(list.files(.self$SaveDir));    if ("FinalOutputSave" %in% LSS) {      try(unlink(paste(.self$SaveDir, "//", "FinalOutputSave", sep="")));    }    if (!(.self$SaveDir %in% c("~/SpikeTest", "SpikeTest", "c:/Users/AlanX230/Documents",      "C:/Users/AlanX230/Documents", "C:/Users/AlanX230/Dropbox",      "C:/Users/AlanX230/Dropbox")) && substr(.self$SaveDir, 1, nchar("/netscr/alenarc/BayesSpikeSaves")) ==       "/netscr/alenarc/BayesSpikeSaves" &&       nchar(.self$SaveDir) > nchar("/netscr/alenarc/BayesSpikeSaves")) {      try(unlink(.self$SaveDir, recursive=TRUE));        }    try(unlink(.self$SaveDir));    try(setwd(Oldwd));    return(ACount);  },   save = function(file = NULL) {     if (.self$Verbose >= -3) {      try(print("BayesSpikeR5.r() TBSR5:save() Starting to Save, tt=", .self$MBS$tt, "/",       .self$MBS$MaxGibbsIters, ", numActive=", .self$MBS$NumActive));       flush.console();    }    TryTTS <- "    if (.self$DoSaveTBSR5 == FALSE) {      print(\"Hey: You originally said don't save me!  DoSaaveTBSR5 = FALSE\"); flush.console();    }    ";    try(eval(parse(text=TryTTS)));    ADir <- paste(.self$SaveDir, "//FinalOutputSave/", sep="");    try(dir.create(ADir, showWarnings=FALSE, recursive=TRUE));    MyList <- .self$FullCopy();    Listfile <- paste(ADir, "//", "PartSaveListTBSR5.RData", sep="");    if (.self$Verbose >= -2) {      print("Save to Listfile before anything."); flush.console();      print(paste("Saving Listfile to ", Listfile, sep=""));      flush.console();    }    try(base::save(MyList=MyList, file = Listfile));    if (.self$Verbose >= -2) {      print("Saved Listfile, now to SaveTBSR5"); flush.console();      flush.console();    }    AFile <- paste(ADir, "//", "SaveTBSR5.RData", sep="");    file = AFile;    base::save(.self, file = file);    if (.self$Verbose >= -2) {      print("Saved self"); flush.console();      flush.console();    }  },  finialize = function() {    if (!is.null(.self$Verbose) && .self$Verbose > 0) {      print("BayesSpikeRoo Is about to be removed from memory");       flush.console();    }    if (!is.null(.self$ABayesSpikeCL)  &&       .self$ABayesSpikeCL$BeingDestroyed == 0) {      if (.self$Verbose > 0) {        print(paste("TBSR5:finalize, we're going to try to call ",          "ABayesSpikeCL's destructor", sep=""));         flush.console();      }      if (!is.null(.self$ABayesSpikeCL$AFD)) {        if (Verbose >= 1) {          print("TBSR5: try to delete AFD in ABayesspikeCL"); flush.console();        }        try(finalize(.self$ABayesSpikeCL$AFD));        .self$ABayesSpikeCL$AFD = NULL;        if (!is.null(.self$AFD)) {          try(finalize(.self$AFD));          .self$AFD = NULL;        }      }      ##rm(.self$ABayesSpikeCL);      .self$ABayesSpikeCL$DeleteMe();      try(ABayesMe <- .self$ABayesSpikeCL);      try(.self$ABayesSpikeCL <- NULL, silent=TRUE);      if (.self$Verbose > 0) {        print("TBSR5: about to call finalize on ABayesSpikeCL.");         flush.console();      }      try(ABayesMe$finalize());      ABayesMe <- NULL; rm(ABayesMe);      gc();    }    if (Verbose >= 1) {      print("TBSR5: delete MyPS"); flush.console();    }    try(finalize(.self$MyPS));  }    ))############################################################################  The following locks a few elements of a BayesSpikeR5 object such that if they##   are set once they are done.##BayesSpikeR5$lock(".X", ".Y", "tauEndList",   "FirstRandom",   "n", "p")   AttachInputList <- function (ReInputList) {  MyText = "    X = ReInputList$.X;  "}  ##########################################################################  SetupSaveFile()####  R5 R levle functionf or setting up save file location for compression.####BayesSpikeR5$methods(  SetupSaveFile = function(   SaveDir=-1, FileName = "ABSChain", chainiter=1,  Starttt = 0, NewWrite = 1, NewTWrite = 1, DoEEProbSort = -1,   DefaultWriteNewProbBuffer = TRUE, ...) {  if (.self$Verbose >= 0) {    print(paste("BayesSpikeCpp.h: TBSR5:SetupSaveFile(currentSaveDir=\"", .self$SaveDir, "\"",      ", setting up for filename = \"", FileName, "\"", sep="")); flush.console();  }  if (.self$DoSave == FALSE) {     if (.self$Verbose >=-1) {      print("TBSR5:SetupSaveFile: DoSave is FALSE, not saving files to Harddrive."); flush.console();    }    if (is.null(.self$MBS$CodaList) || length(.self$MBS$CodaList) <= 0) {      print("TBSR5:SetupSaveFile: Note, that Coda List is also not set up!");      flush.console();    }    return(3);   }  if (.self$Verbose >= -1) {    print(paste("BayesSpikeCpp.h: TBSR5: Setting DoEEProbSort")); flush.console();  }   if (DoEEProbSort == FALSE) {     .self$DoEEProbSort = 0;   } else if (DoEEProbSort == TRUE) {     .self$DoEEProbSort = 1;   } else if (is.numeric(DoEEProbSort) && DoEEProbSort[1] ==0) {     .self$DoEEProbSort = 0;   } else if (is.numeric(DoEEProbSort) && DoEEProbSort[1] > 0) {     .self$DoEEProbSort = 1;   }   if(.self$Verbose >= -1) {    print("BayesSpikeCpp.h; SetupSaveFiles: Looking what ListSaveFiles is. set to null vector if necessary"); flush.console();   }   if (length(.self$ListSaveFiles) <= 0 || is.null(.self$ListSaveFiles)) {     try(.self$ListSaveFiles <- vector("character",0) );   }  ## if (is.null(.self$ListAllSaveFiles)) {  ##   try(.self$ListAllSaveFiles <- vector("character",0) );  ## }   if(.self$Verbose >= -1) {    print("BayesSpikeCpp.h; SetupSaveFiles: Looking what ListChainIters is."); flush.console();   }   if (is.null(.self$ListChainIters) || length(.self$ListChainIters) <= 0) {     .self$ListChainIters = list();   }   if (.self$Verbose >= -1) {     print("BayesSpikeCpp.h:SetupSaveFiles: Look at DefaultWriteNewProbBuffer"); flush.console();   }   if (.self$DefaultWriteNewProbBuffer == FALSE) {     aDefaultWriteNewProbBuffer = FALSE;   }  else {     aDefaultWriteNewProbBuffer = DefaultWriteNewProbBuffer;   }   if (.self$Verbose >= -1) {     print("BayesSpikeCpp.h:SetupSaveFiles: Testing nullity of SaveDir"); flush.console();   }   if (is.null(SaveDir) || !is.character(SaveDir) || SaveDir[1] == -1) {      if (.self$Verbose >= -1) {        print("BayesSpikeCpp.h:SetupSaveFiles: SaveDir input is NULL, thinking how to set it in BAYESSPIKENAMESPACE");        flush.console();      }     if (!is.null(.self$SaveDir) && is.character(.self$SaveDir) &&       .self$SaveDir != "") {       ##SaveDir = .self$SaveDir     } else {        if (.self$Verbose >= -1) {          print("BayesSpikeCpp.h:SetupSaveFiles: SaveDir input is NULL, seeking it in BAYESSPIKENAMESPACE");          flush.console();        }        if (!exists(".DefaultFileDir", BAYESSPIKENAMESPACE)) {          print("SetupSaveFile::  Uh Oh, want to use .DefaultFileDir, but it does not exist!"); flush.console();        }        try(eval(parse(text=GetG0Text(".DefaultFileDir"))));        if (is.null(.DefaultFileDir) || is.numeric(.DefaultFileDir)) {          .DefaultFileDir <- "";        }        if (.self$Verbose >= -1) {          print("BayesSpikeCpp.h: About to set SaveDir to .DefaultFileDir"); flush.console();        }        try(.self$SaveDir <- .DefaultFileDir);     }   } else if (is.character(.self$SaveDir)) {    if (.self$Verbose >= 0) {      print(paste("BayesSpikeR5.r SetupSaveFile():  Now we know it: .self$SaveDir = ", .self$SaveDir, sep=""));      flush.console();    }    if (nchar(SaveDir) >= 2 && SaveDir == .self$SaveDir) {        MyTry <- "SaveDir <- \"\";";  try(eval(parse(text=MyTry)));    }     ##.self$SaveDir = SaveDir;   }   if (.self$Verbose >= -1) {     print("BayesSpikeR5.r:SetupSaveFile(): Have Started to create SaveDir"); flush.console();     print(paste("BayesSpikeR5.r:SetupSaveFile() Starting to create SaveDir = ", .self$SaveDir, sep="")); flush.console();   }   if (nchar(.self$SaveDir) == 0) {    print(paste("BayesSpikeR5.r: SetupSaveFile(): Clearly nchar .self$SaveDir is null, this cannot be done. ")); flush.console();   } else {     print(paste("BayesSpikeR5:SetupSaveFile() .self$SaveDir has ", nchar(.self$SaveDir), " characters", sep="")); flush.console();   }   RTE = NULL;   try(RTE <- dir.create(.self$SaveDir, showWarnings=FALSE, recursive=TRUE));   if (is.null(RTE)) {     print(paste(" Looks like we had an error trying to create directory: ", as.character(.self$SaveDir)));     flush.console();     print(paste(" Getting .DefaultDir. ",sep="")); flush.console();     try(eval(parse(text=GetG0Text(".DefaultFileDir", BAYESSPIKENAMESPACE))));     ##print(paste("  Note that .DefaultFileDir = ",      ##  get(".DefaultFileDir", BAYESSPIKENAMESPACE), sep=""));      print(paste(".DefaultFileDir is ", .DefaultFileDir, sep=""));      flush.console();   }   aMBS = NULL;   if (.self$Verbose >= -1) {     print("BayesSpikeR5.r:SetupSaveFile() extracting MBS"); flush.console();   }   try(aMBS <- .self$ABayesSpikeCL);   if (is.null(aMBS)) {     print("TBSR5$SetupSaveDir: you started with aMBS is real NULL!");     flush.console();     return(-1);   }   if (Verbose >= -1) {     print("BayesSpikeR5.r:SetupSaveFile(): extracted MBS: checking Being Destroyed."); flush.console();   }   if (is.null(aMBS$BeingDestroyed)  || !is.numeric(aMBS$BeingDestroyed)) {     print("TBSR5$SetupSaveDir: Bad stuff aMBS does not have BeingDestroyed!");     flush.console();     print(paste("ERROR: names(aMBS) = (",       paste(names(aMBS), collapse=", "), ")", sep="")); flush.console();     print("Oh Doh Does this also cause a memory explosion!"); flush.console();     return(-1);   }   if (is.numeric(aMBS$BeingDestroyed) && aMBS$BeingDestroyed==1) {     print(paste("TBSR5$SetupSaveDir: On start, Oh no, looks like aMBS has been",       "close to being destroyed, ",       "not good, not continuing.\n"));  flush.console();     aMBS = NULL;      return(-1);   }   if (.self$Verbose >= -1) {    print(paste("BayesSpikeR5.r:SetupSaveFile() extracted MBS, now setting Savedir to ", .self$SaveDir, sep=""));    flush.console();   }   try(aMBS$SaveDir <- .self$SaveDir);   if (.self$DoSave == FALSE ||      (is.character(.self$SaveDir) && .self$SaveDir == "NOSAVE") ||     is.null(.self$SaveDir) ||      (is.numeric(.self$SaveDir) && .self$SaveDir == -1)) {     if (.self$Verbose >= 0) {       print("SetupSaveFile: About to NULL out Files."); flush.console();     }     try(.self$FullFileI <- "");     try(.self$FullFileD <- "");     try(.self$FullFileiT <- "");     try(.self$FullFiledT <-"");     try(.self$FullFileP <- "")     try(.self$FullFileProb <- "");       try(.self$FullFileILoc <- "");     try(.self$ABayesSpikeCL$NoSave <- 1);     try(.self$ABayesSpikeCL$DoSave <- 0);          try(.self$FullFileYBuffer <- NULL);       try(.self$FullFileWeightBuffer <- NULL);     try(.self$FillFilePostProbBuffer <- NULL);          try(.self$FullFileI <- "");  try(.self$FullFileD <- "");     try(.self$FullFileiT <- "");  try(.self$FullFiledT <- "");     try(.self$FullFileP <- "");   try(.self$FillFilePostProbBuffer <- "");     try(.self$FullFileBetaAllDraw <- "");     ##.self$ListSaveFiles[length(.self$ListSaveFiles) + 1] <- NULL;     try(.self$ListChainIters[[length(.self$ListChainIters) + 1]] <- chainiter);     if (is.null(aMBS)) {       print("Warning Attempt to set CodafileNames fails because aMBS is NULL!");       flush.console();       return(-1);     }     try(aMBS$SetCodaFileNames(NULL, NULL, 0));          try(aMBS$SetCodaILocAndProbFile(NULL,NULL,0));     try(aMBS$SetupProbBufferFile(NULL,0));     try(aMBS$SetupYBuffer(NULL,0));     try(aMBS$SetupWeightBuffer(NULL,0));   } else {     if (.self$Verbose >= -1) {       print(paste("BayesSpikeR5.r:SetupSaveFiles() Going to set files to SaveDir = ", .self$SaveDir, " and IDiT Files!",         sep="")); flush.console();     }     if (.self$Verbose >= 0) {       print("SetupSaveDir: Setup back OldDFile."); flush.console();     }     ##if (!is.null(aMBS) && !is.null(aMBS$sCodaDFile) && aMBS$Temperature != 1.0) {     ##  try(aMBS$sCodaOldDFile <-                          ##    paste(aMBS$sCodaDFile, sep=""));     ##}     ##if (!is.null(aMBS$sCodaIFile)  && aMBS$Temperature != 1.0) {     ##  try(aMBS$sCodaOldIFile <-      ##    paste(aMBS$sCodaIFile, sep=""));     ##}        RunOnFileNameText <- "     if (!is.null(FileName) && is.character(FileName) && nchar(FileName) >= 2 &&         (length(unlist(strsplit(FileName, \":\"))) >= 2 ||           length(unlist(strsplit(FileName, \"/\"))) >= 2 ||          length(unlist(strsplit(FileName, \"\\\\\\\\\"))) >= 2 ||          length(unlist(strsplit(FileName, \"\\\\.\"))) >= 2)) {       if (!is.null(aMBS$SaveDir) && is.charcter(aMBS$SaveDir) &&          nchar(aMBS$SaveDir) >= 1) {          FileName <- paste(unlist(strsplit(FileName, \":\")), collapse=\"\");           FileName <- paste(unlist(strsplit(FileName, \"/\")), collapse=\"\");           FileName <- paste(unlist(strsplit(FileName, \"\\\\\\\\\")), collapse=\"\");         }       FileName <- paste(unlist(strsplit(FileName, \"\\\\.\")), collapse=\"\");      }     ";     eval(parse(text=RunOnFileNameText));     if (.self$Verbose >= -1) {       print(paste("BayesSpikeR5.r:SetupSaveFile(): after RunOnFileNameText, FileName = ", FileName, sep="")); flush.console();     }     if (!is.null(.self$FileName) && is.character(.self$FileName) && nchar(.self$FileName) >= 2 &&         (length(unlist(strsplit(.self$FileName, ":"))) >= 2 ||           length(unlist(strsplit(.self$FileName, "/"))) >= 2 ||          length(unlist(strsplit(.self$FileName, "\\\\"))) >= 2 ||          length(unlist(strsplit(.self$FileName, "\\."))) >= 2)) {       if (!is.null(aMBS$SaveDir) && is.charcter(aMBS$SaveDir) &&          nchar(aMBS$SaveDir) >= 1) {          try(.self$FileName <- paste(unlist(strsplit(.self$FileName, ":")), collapse=""));           try(.self$FileName <- paste(unlist(strsplit(.self$FileName, "/")), collapse=""));           try(.self$FileName <- paste(unlist(strsplit(.self$FileName, "\\\\")), collapse=""));         }       try(.self$FileName <- paste(unlist(strsplit(.self$FileName, "\\.")), collapse=""));      }     if (is.null(FileName) || FileName == "") {       try(aFileName <- .self$FileName);  try(.self$OnFile <- aFileName);     } else {       try(aFileName <- FileName);  try(.self$OnFile <- aFileName);     }        if (!is.null(aMBS$TemperatureList) && length(aMBS$TemperatureList) > 1       && aMBS$Tempii > 0) {       if (.self$Verbose >= -1) {         print("BayesSpkeR5.r:SetupSaveFile: Setup FileNames: Set .OldFile."); flush.console();       }       OldFileName <- paste(aFileName, "T", aMBS$Tempii-1, "C", sep="");       try(.self$OldFile <- OldFileName);       } else {       if (.self$Verbose >= 2) {         print("BayesSpkeR5.r:SetupSaveFile: Set .OldFile."); flush.console();       }       OldFileName = NULL;   try(.self$OldFile <- "");     }     if (.self$Verbose >= -1) {       print("BayesSpikeR5.r:SetupSaveFile(): Set aFileName [OnFile]."); flush.console();     }     tTemperatureList <- aMBS$TemperatureList;     tTempii <- aMBS$Tempii;     if (!is.null(tTemperatureList) && length(tTemperatureList) > 1       && tTempii < length(tTemperatureList)-1) {       aFileName <- paste(aFileName, "T", tTempii, "C", sep="");     } else {       aFileName <- FileName;     }     try(.self$OnFile <- aFileName);     if (.self$Verbose >= -1) {       print(paste("SetupSaveDir(Temperature investigated and OnFile set to", .self$OnFile, ") Set FullFileI, FullFileD.", sep="")); flush.console();     }     try(.self$FullFileI <- paste(.self$SaveDir,       "//", aFileName, chainiter, "I.bin", sep=""))     try(.self$FullFileD <- paste(.self$SaveDir,       "//", aFileName, chainiter, "D.bin", sep=""));     if (.self$DoLongCI == TRUE) {       try(.self$FullFileBetaAllDraw <- paste(.self$SaveDir, "//",         aFileName, chainiter, "LongBeta.bin", sep=""));     }     if (is.null(.self$sOnTau) || length(.self$sOnTau) <= 0 ||       is.null(.self$tauEndList) || length(.self$tauEndList) <= 0) {       MyParseTT <- "         FullFileiT <- NULL;  FullFiledT <- NULL;       ";       try(eval(parse(text=MyParseTT)))       Atrytext <- "       try(FullFileiTLoc <- NULL);"       try(eval(parse(text=Atrytext)));       try(.self$FullFileiTLoc <- "");     } else {       MyParseTT <- "         FullFileiT <- paste(.self$SaveDir, \"//\", aFileName, chainiter, \"iT.bin\", sep=\"\")          FullFiledT <- paste(.self$SaveDir, \"//\", aFileName, chainiter, \"dT.bin\", sep=\"\")       ";       try(eval(parse(text=MyParseTT)));        Atrytext <- "       FullFileiTLoc <- paste(.self$SaveDir, \"//\", aFileName, chainiter, \"iTLoc.bin\", sep=\"\");        ";       try(eval(parse(text=Atrytext)));       try(.self$FullFileiTLoc <- as.character(FullFileiTLoc));     }         if (.self$Verbose >= 2) {       print("SetupSaveDir: Set FullFileP, FullFileProb, FullFileiLoc."); flush.console();     }     MyTryMakeFullFiles <- "       try(FullFileP <- paste(.self$SaveDir, \"//\", aFileName, chainiter, \"P.bin\", sep=\"\"))         try(FullFileProb <- paste(.self$SaveDir, \"//\", aFileName, chainiter, \"Prob.bin\", sep=\"\"))       try(FullFileiLoc <- paste(.self$SaveDir, \"//\", aFileName, chainiter, \"iLoc.bin\", sep=\"\"))     ";     try(eval(parse(text=MyTryMakeFullFiles)));     if (.self$Verbose >= 2) {       print("SetupSaveDir: Setting FillFilePostProbBuffer."); flush.console();     }     try(.self$FillFilePostProbBuffer <- paste(.self$SaveDir,       "//", aFileName, chainiter, "PostBuff.bin", sep=""));          if (.self$Verbose >= 2) {       print("SetupSaveDir: Set FullFileiT, FullFiledT."); flush.console();     }     ##.self$FullFileI = FullFileI;  .self$FullFileD = FullFileD;     try(.self$FullFileiT <- as.character(FullFileiT));     try(.self$FullFiledT <- as.character(FullFiledT));     if (!is.null(FullFileiTLoc)) {       try(.self$FullFileiTLoc <- as.character(FullFileiTLoc));     } else {       try(.self$FullFileiTLoc <- "");     }         if (.self$Verbose >= 2) {       print("SetupSaveDir: Set .self$FullFileP."); flush.console();     }     try(.self$FullFileP <- as.character(FullFileP));     if (.self$Verbose >= 2) {       print(paste("SetupSaveDir: Set .self$FullFileProb to ", FullFileProb, sep=""));        flush.console();     }     MyTestEvalText <- "       ##print(\"About to Really Set FullFileProb!\"); flush.console();       try(.self$FullFileProb <- as.character(FullFileProb));       ##print(\"Really Just Set FullFileProb!\"); flush.console();       ";     try(eval(parse(text=MyTestEvalText)));     ##print("Well, going to see where Verbose has gone."); flush.console();     MyTText <- "       NowVerbose = NULL;       try(NowVerbose <- .self$Verbose[1]);     "     ##print("Try and Load Verbose");     try(eval(parse(text=MyTText)));     ##print("Well what is Now Verbose? "); flush.console();     if (is.null(NowVerbose) || !is.numeric(NowVerbose) || length(NowVerbose) <= 0) {        print("Weird: at setup FullFileProb we got a NowVerbose go wrong error"); flush.console();        print(paste("We have .self$Verbose is ", self$Verbose, sep="")); flush.console();     }     if (NowVerbose >= 1) {        print("SetupSaveDir: We have setup FullFileProb and have NowVerbose, off to FullFileiLoc.");        flush.console();     }     if (.self$Verbose[1] >= 2) {       print("SetupSaveDir: Now Set .self$FullFileiLoc."); flush.console();     }     try(.self$FullFileiLoc <- as.character(FullFileiLoc));     ##.self$FillFilePostProbBuffer = FillFilePostProbBuffer;      if (.self$Verbose >= -1) {       print("BayesSpikeR5.r:SetupSaveFiles(): Add FileName to ListSaveFiles."); flush.console();     }        if (length(aMBS$TBSR5$ListSaveFiles) <= 0) {        try(aMBS$TBSR5$ListSaveFiles <-          as.vector(paste(.self$SaveDir, "//", FileName, chainiter, sep="")));      } else if (!(paste(.self$SaveDir, "//", FileName, chainiter, sep="") %in%         aMBS$TBSR5$ListSaveFiles)) {       try(aMBS$TBSR5$ListSaveFiles <-          c(aMBS$TBSR5$ListSaveFiles,          paste(.self$SaveDir, "//", FileName, chainiter, sep="")));     }     if (.self$Verbose >= 2) {       print("SetupSaveDir: Update ListSave Files."); flush.console();     }      if (length(.self$ListSaveFiles) <= 0) {        try(.self$ListSaveFiles <-          as.vector(paste(.self$SaveDir, "//", FileName, chainiter, sep="")));      }  else if (!(paste(.self$SaveDir, "//", FileName, chainiter, sep="") %in%         .self$ListSaveFiles)) {       try(.self$ListSaveFiles <- c(.self$ListSaveFiles,          paste(.self$SaveDir, "//", FileName, chainiter, sep="")));     }         if (.self$Verbose >= 2) {       print("SetupSaveDir: UpdateListChainIters."); flush.console();     }      .self$ListChainIters[[length(.self$ListChainIters) + 1]] =  chainiter;     if (.self$Verbose >= 2) {       print("Setting CodaFileNames FullFileI and FullFileD."); flush.console();     }          if (.self$Verbose >= -1) {       print("About to set FullFileI and FullFileD into CodaFileNames"); flush.console();     }     try(aMBS$SetCodaFileNames(       paste(.self$FullFileI, sep=""), paste(.self$FullFileD, sep=""), chainiter));     if (.self$Verbose >= 1) {       print("Setting SetupProbBufferFile."); flush.console();     }     try(aMBS$SetupProbBufferFile(.self$FillFilePostProbBuffer,       .self$LengthPostProbBuffer+0.0));     if (.self$Verbose >= 1) {       print(" -- Finished Setting ProbBuffer File"); flush.console();     }     if (aDefaultWriteNewProbBuffer == TRUE) {       if (.self$Verbose >= 1) {          print(" -- But FillFilePostProbBuffer == TRUE so set NewPostProbWrite = 1"); flush.console();       }       try(unlink(.self$FillFilePostProbBuffer));       try(aMBS$NewPostProbWrite <- 1);     }            if (.self$WriteYBuffer == TRUE) {       if (.self$Verbose >= 1) {          print(" -- WriteYBuffer is true, setup to write Y Buffer."); flush.console();       }       YFile = paste(.self$SaveDir, "//",          FileName, chainiter, "YBuff.bin", sep="");       if (.self$LengthYBuffer <= 0) {          try(.self$LengthYBuffer <- as.integer(100), silent=TRUE); }       if (.self$Verbose >= 1) {         print(paste("SetSaveFile; Setting SetupYBuffer , length ",           .self$LengthYBuffer, sep=""));   flush.console();       }       try(aMBS$SetupYBuffer( YFile,.self$LengthYBuffer));       if (.self$Verbose >= 1)  {         print(paste("SetSaveFile: After SetupYBuffer, LengthYBuffer = ",           .self$LengthYBuffer, sep=""));       }       if (.self$NewYBufferWrite == FALSE) {         try(aMBS$NewYBufferWrite <- as.integer(0), silent=TRUE);       }                                                 }     if (.self$WriteWeightBuffer == TRUE) {       WeightFile = paste(.self$SaveDir, "//", FileName, chainiter, "WBuff.bin", sep="");       if (.self$Verbose >= 1) {         print(paste("SetSaveFile; Setting SetupWeightBuffer , length ",           .self$LengthWeightBuffer, sep=""));    flush.console();       }       if (.self$LengthWeightBuffer <= 0) { .self$LengthWeightBuffer = 100; }       try(aMBS$SetupWeightBuffer( WeightFile,.self$LengthWeightBuffer));       if (.self$NewWeightBufferWrite == FALSE) {         try(aMBS$NewWeightBufferWrite <- as.integer(0), silent=TRUE);       }     }        if (.self$AlterWeightFlag == TRUE) {       .self$AlterWeightFile <- paste(.self$SaveDir, "//", FileName, chainiter, "AWF.bin", sep="");       if (is.null(LengthAlterWeightBuffer)          || !is.numeric(LengthAlterWeightBuffer) ||         LengthAlterWeightBuffer <= 0) {         try(.self$LengthAlterWeightBuffer <-            as.integer(300), silent=TRUE);         } else {         try(.self$LengthAlterWeightBuffer <-            as.integer(LengthAlterWeightBuffer), silent=TRUE);       }       if (.self$Verbose >= 1) {         print(paste("SetSaveFile; Setting SetupAlterWeight Buffer, length ",           .self$LengthWeightBuffer, sep=""));    flush.console();       }       aMBS$SetupAlterWeightBuffer(.self$AlterWeightFile,          .self$LengthAlterWeightBuffer, .self$AlterdfTNoise, .self$AlterdfRobit);       if (.self$Verbose >= 1) {         try(print(paste("SetSaveFile; AlterWeightBuffer has been setup to length ",           .self$LengthWeightBuffer, sep="")));    flush.console();       }       ##.self$ABayesSpikeCL$Verbose <- 2;       if (!is.null(.self$AverageIIWeight) && length(.self$AverageIIWeight) == .self$n) {         if (.self$Verbose >= 1) {           try(print(paste("SetSaveFile: Putting AverageIIWeight into iiWeight", sep="")));    flush.console();         }         OldVerbose <- .self$ABayesSpikeCL$Verbose;         .self$ABayesSpikeCL$Verbose <- 5;         try(.self$ABayesSpikeCL$iiWeight <- .self$AverageIIWeight);         .self$ABayesSpikeCL$Verbose <- OldVerbose;         if (.self$Verbose >= 1) {           try(print("SetSaveFile: successfully filled AverageIIWeight.")); flush.console();         }       }       try(aMBS$AlterWeightTemperature <- .self$AlterWeightTemperature);       if (.self$Verbose >= 1) {         try(print(paste("SetSaveFile; AlterWeightBuffer Average Weight is set up ",           .self$LengthWeightBuffer, sep="")));    flush.console();       }     }         if (is.null(.self$LengthPiACodaBuffer) || .self$LengthPiACodaBuffer <= 0) {         try(.self$LengthPiABuffer <- as.integer(100), silent=TRUE);       }     if (.self$Verbose >= 1) {        print(paste("BayesSpikeR5.r:SetSaveFile; Setting PiACoda to length ",           .self$LengthPiACodaBuffer, sep=""));    flush.console();     }     try(aMBS$SetupPiACodaBuffer( paste(.self$SaveDir, "//",        FileName, chainiter, "PiABuff.bin", sep=""),.self$LengthPiACodaBuffer));      if (.self$Verbose >= -1) {        print(paste("BayesSpikeR5.r:SetSaveFile; SPiACodaBuffer is setup. At Length ",           .self$LengthPiACodaBuffer, sep=""));    flush.console();     }                      if (.self$AlterWeightFlag == TRUE) {        if (.self$Verbose >= -1) {          print("BayesSpikeR5.r:SetSaveFile: AlterWeightFlag is being set."); flush.console();        }       try(aMBS$dfRobit <- -1);       try(aMBS$AlterdfRobit <- .self$AlterdfRobit);     }     if (aMBS$dfRobit < 0) {       if (is.null(.self$LengthSigCodaBuffer) || .self$LengthSigCodaBuffer <= 0) {         try(.self$LengthSigCodaBuffer <- as.integer(100), silent=TRUE);       }       if (.self$Verbose >= -1) {        print(paste("BayesSpikeR5.SetSaveFile: about to setup SigCodaBuffer to length ", .self$LengthSigCodaBuffer, sep=""));        flush.console();       }       try(aMBS$SetupSigCodaBuffer( paste(.self$SaveDir, "//",          FileName, chainiter, "SigBuff.bin", sep=""),.self$LengthSigCodaBuffer));        if (.self$Verbose >= -1) {           try(print(paste("SetSaveFile; sSigmaBuffer now length ",           .self$LengthSigCodaBuffer, sep="")));    flush.console();       }      }         if (TRUE) {         ATry = 0;        if (!is.null(.self$sOnTau)  && length(.self$sOnTau) >= 1) {          if (.self$Verbose >= 1) {             print(paste("BayesspikeR5.r:  Setting CodaT file name: ",               .self$FullFileiT, sep=""));  flush.console();          }          try(ATry <- aMBS$setCodaTFile(            paste(.self$FullFileiT, sep=""),            paste(.self$FullFiledT, sep=""),            paste(FullFileiTLoc, sep="")));          } else {           try(ATry <- aMBS$setCodaTFile(           NULL, NULL, NULL));         }         try(aMBS$NewTWrite  <- NewTWrite);      if (ATry!=1) {         print(paste("SetCodaTFile, we have an Error, FullFileiT = ", .self$FullFileiT,           "  and FullFiledT = ", .self$FullFiledT, sep=""));         print("SetupSaveDir: Will return -1 in Error!"); flush.console();         return(-1);       }     } else if (.self$DoRecord[2] == 1  &&        !(is.null(.self$tauEndList) || length(.self$tauEndList) <= 0)      ) {       ATry = 0;       if (is.null(aMBS)) {         print(paste("SetupSaveDir: How is this going to go, we want ",           "to SetCodaTFile, but that ain't gonna happen, MBS is NULL!", sep=""));         flush.console();       }       if (aMBS$Verbose > 1) {         print("SetupSaveDir: Going to setCodaTFile."); flush.console();       }       if (!is.null(.self$sOnTau) && length(.self$sOnTau) >= 1 && aMBS$CodaTisSetup == 0) {         try(ATry <- aMBS$setCodaTFile(           paste(.self$FullFileiT, sep=""),           paste(.self$FullFiledT, sep=""),           paste(FullFileiTLoc, sep="")));       } else {         try(ATry <- aMBS$setCodaTFile(         NULL, NULL, NULL));       }       try(ATry <- aMBS$NewWriteT(1));       if (ATry!=1) {         print(paste("SetCodaTFile, we have an Error, FullFileiT = ", .self$FullFileiT,           "  and FullFiledT = ", .self$FullFiledT, sep=""));         print("SetupSaveDir: Will return -1 in Error!"); flush.console();         return(-1);       }       try(aMBS$NewWrite  <- NewWrite);     } else {       if (aMBS$Verbose > 1) {         print("SetupSaveDir: Going to set CodaTFile to NULL."); flush.console();       }       try(ATry <- aMBS$setCodaTFile(         NULL, NULL, NULL));       try(ATry <- aMBS$NewWriteT(0));       if (aMBS$Verbose > 1) {         print("SetupSaveDir:  Successfully set CodaTFile to NULL.");          flush.console();       }     }     if ( (.self$DoRecord[3] == 1  || .self$DoRecord[4] == 1) &&        (!is.null(.self$OnPiA) || !is.null(.self$OnSigma)) ) {        if (aMBS$Verbose >= 1) {          try(print(paste("SetupSaveDir: Setup CodaPFile to ",             .self$FullFileP, sep=""))); flush.console();        }        try(aMBS$CodaPFile <- paste(.self$FullFileP, sep=""));        if (aMBS$Verbose > 1) {          print("SetupSaveDir: Done setting up CodaPFile."); flush.console();        }     }                                              if (aMBS$Verbose > 2) {       print("SetupSaveDir: Setting SetCodaILocAndProbFile"); flush.console();     }     try(aMBS$SetCodaILocAndProbFile(paste(.self$FullFileiLoc, sep=""),       paste(.self$FullFileProb, sep=""),       aMBS$MaxGibbsIters));     if (.self$DoLongCI == TRUE) {       try(aMBS$SetupRsCodaBetaAllDrawBuffer(.self$FullFileBetaAllDraw,         ((.self$p+1)*.self$CpBuffLongCI) )        );     }     if (!is.null(OldFileName)) {        OFullFileI = paste(.self$SaveDir, "//", OldFileName, chainiter, "I.bin", sep="")        OFullFileD = paste(.self$SaveDir, "//", OldFileName, chainiter, "D.bin", sep="")         if (is.null(.self$sOnTau) || length(.self$sOnTau) <= 0 ||          is.null(.self$tauEndList) || length(.self$tauEndList) <= 0) {          OFullFileiT = NULL;  OFullFiledT = NULL;        } else {         OldFullFileiT = paste(.self$SaveDir, "//", OldFileName, chainiter, "iT.bin", sep="")          OldFullFiledT = paste(.self$SaveDir, "//", OldFileName, chainiter, "dT.bin", sep="")         }        OFullFileP = paste(.self$SaveDir, "//", OldFileName, chainiter, "P.bin", sep="")          OFullFileProb = paste(.self$SaveDir, "//", OldFileName, chainiter, "Prob.bin", sep="")         OFullFileiLoc = paste(.self$SaveDir, "//", OldFileName, chainiter, "iLoc.bin", sep="")                try(.self$ABayesSpikeCL$sCodaOldJFile <- OFullFileD);        try(.self$ABayesSpikeCL$sCodaOldIFile <- OFullFileI);        AStartOldEELoad = .self$StartOldEELoad;        if (AStartOldEELoad > .self$ABayesSpikeCL$LengthTempDraws[(.self$Tempii+1)-1]) {          AStartOldEELoad <- 1;        }        FEEDoSort = as.integer(.self$EEDoSort);        try(.self$ABayesSpikeCL$SetCodaOldLocAndProbFile(          OFullFileiLoc, OFullFileProb,          AStartOldEELoad, .self$ABayesSpikeCL$LengthTempDraws[(.self$Tempii+1)-1]-AStartOldEELoad,           .self$ABayesSpikeCL$LengthTempDraws[(.self$Tempii+1)-1],           FEEDoSort));                 }     if (aMBS$Verbose > 2) {       print("SetupSavedir: Finished."); flush.console();     }   }  if (.self$Verbose >= 0) {    print(paste("SetupSaveDir: Setting initial tt. :", Starttt, sep="")); flush.console();  }  aMBS$tt = Starttt;   if (.self$Verbose >= 2) {    print("SetupSaveDir: Just setting up final values."); flush.console();  }  if (FALSE) {  eval(parse(text=GetG0Text(".ListBayesSpikeOb", "globalenv()")));  .ListBayesSpikeOb[[.self$NInstance]]$FullFileI <- .self$FullFileI;  .ListBayesSpikeOb[[.self$NInstance]]$FullFileD <- .self$FullFileD;  .ListBayesSpikeOb[[.self$NInstance]]$FullFileiT <- .self$FullFileiT;  .ListBayesSpikeOb[[.self$NInstance]]$FullFiledT <- FullFiledT;  .ListBayesSpikeOb[[.self$NInstance]]$FullFileP <- FullFileP;  .ListBayesSpikeOb[[.self$NInstance]]$FullFileiLoc <- FullFileiLoc;  .ListBayesSpikeOb[[.self$NInstance]]$FullFileProb <- FullFileProb;  eval(parse(text=LockGText(".ListBayesSpikeOb", "globalenv()")));    }  if (.self$Verbose >= 0) {    print("SetupSaveDir: Done Setting up."); flush.console();  }  return(1); });BayesSpikeR5$methods(  GenerateCLN = function() {   try(library(coda));   Count = 0;  CLN = c();  if (.self$DoRecord[1] > 0) {    if (Verbose > 0) {      print(paste("GenerateCLN: DoRecord 1 greater than 0."));        flush.console();    }    Count = Count + .self$p    if (!is.null(names(.self$sBeta)) && length(names(.self$sBeta)) == .self$p) {      CLN = c(CLN,       addname(Names=names(.self$sBeta),         FN=paste("Beta:", 1:length(.self$sBeta),  sep="")));    } else {      CLN = c(CLN, paste("Beta:", 1:length(.self$sBeta), sep=""));    }  }  if (length(.self$tauEndList) > 0 && .self$DoRecord[2] > 0) {    if (Verbose > 0) {      print(paste("GenerateCLN: DoRecord 2 greater than 0."));        flush.console();    }    Count = Count + length(.self$tauEndList);    if (!is.null(names(.self$sOnTau))) {      CLN = c(CLN,       addname(Names=names(.self$sOnTau),         FN=paste("tau:", 1:length(.self$sOnTau), sep="")));    } else {      CLN = c(CLN, paste("tau:", 1:length(.self$sOnTau), sep=""));    }  } else {  }  if (.self$DoRecord[3] > 0) {    Count = Count + length(.self$OnSigma);    CLN = c(CLN, "Sigma:1")  }  if (.self$DoRecord[4] > 0) {    Count = Count + length(.self$OnPiA);    if (!is.null(names(.self$OnPiA))) {      CLN = c(CLN,       addname(Names=names(.self$OnPiA),         FN= paste("PiA:", 1:length(.self$OnPiA),  sep="")));    } else {      CLN = c(CLN, paste("PiA:", 1:length(.self$OnPiA), sep=""));    }  }  if (.self$DoRecord[5] > 0) {    if (length(.self$tauFixed) > 0) {      Count = Count + length(.self$tauFixed);      if (!is.null(names(.self$tauFixed))) {        CLN = c(CLN,         addname(Names=names(.self$tauFixed),           FN=paste("TF:", 1:length(.self$tauFixed), sep="")));      } else {        CLN = c(CLN,          paste("TF:", 1:length(.self$tauFixed), sep=""));      }    }  }  if (.self$DoRecord[6] > 0) {    if (is.null(.self$sOnTau) || length(.self$sOnTau) <= 0 ||      is.null(.self$tauEndList) || length(.self$tauEndList) <= 0) {      Count = Count + .self$p;      if (!is.null(names(.self$sBeta)) &&         length(names(.self$sBeta)) > 0) {        CLN = c(CLN,          addname(Set=.self$sBeta,            FN=paste("ProbFixed:", 1:.self$p,  sep="")));        } else {        CLN = c(CLN,           paste("ProbFixed:", 1:.self$p, sep=""));      }           } else if (.self$CFirstRandom > 0 && .self$CFirstRandom <= .self$p) {      Count = Count + .self$CFirstRandom;      if (!is.null(names(.self$sBeta)) &&         length(names(.self$sBeta)) > .self$CFirstRandom) {        CLN = c(CLN,          addname(Set=.self$sBeta[1:.self$CFirstRandom],            FN=paste("ProbFixed:", 1:.self$CFirstRandom,  sep="")));        } else {        CLN = c(CLN,           paste("ProbFixed:", 1:.self$CFirstRandom, sep=""));      }    }  }  if (.self$DoRecord[7] > 0) {    if (!is.null(.self$tauEndList) && length(.self$tauEndList) > 0) {      Count = Count + length(.self$tauEndList);      if (!is.null(names(.self$sOnTau)) &&         length(names(.self$sOnTau)) > length(.self$sOnTau) ) {        CLN = c(CLN,          addname(Set=.self$sOnTau,            FN=paste("ProbTau:", 1:length(.self$sOnTau), sep="")));        } else {        CLN = c(CLN,           paste("ProbTau:", 1:length(.self$sOnTau), sep=""));      }    }  }  if (Verbose > 0) {    print(paste("After Reads in, Count = ", Count,        ", Now OtherCount starting to setup. ", sep="")); flush.console();  }  if (is.null(CLN) || min(nchar(CLN)) <= 0) {    print("Weird: CLN after all that work is NULL!"); flush.console();  }   try(.self$FirstCLN <- paste(CLN, sep=""));  if (!is.null(.self$MBS)) {    try(.self$MBS$OldCodaNames <- paste(CLN, sep="")); flush.console();    if (!is.null(.self$MBS$CodaList)) {      ARD <- list(NULL, paste(CLN, sep=""));      try(.self$MBS$RenameCodaList(ARD));    }  }  return(list(CLN=CLN, Count = Count));})################################################################################  GenerateCodaTable####   R5 R level function for generating CodaTables for CodaLists.########BayesSpikeR5$methods(  GenerateCodaTable = function( DoRecord = 0, NumChains = 0,    MBS=NULL, Verbose = 0, ...)  {  try(library(coda));  if (is.null(.self$MaxGibbsIters)) {    print("GenerateCodaTable: Please set MaxGibbsIters first"); flush.console();  }  ##AText <- "Verbose = 4;"  ##eval(parse(text=AText));  if (Verbose > 1) {    print(paste("GenerateCodaTable: BayesSpikeR5, setting up, NumChains = ", NumChains,      ", Number Iters = ", .self$MaxGibbsIters, sep="")); flush.console();  }  if (is.null(.self$DoRecord) && length(DoRecord) != 7) {    print("Error: Do Record must be length 7 to make table!");  } else if (length(DoRecord) == 7) {    .self$DoRecord = DoRecord;  } else if (length(.self$DoRecord) != 7) {    print("Error: Do Record must be length 7 to make table!");  } else {    ##DoRecord = .self$DoRecord;  }  if (Verbose >= 2) {    paste(print("BayesSpike:TBSR5:GenerateCodaTable, getting started.  Verbose = ",      Verbose, sep=""));    flush.console();  }  ATT <- .self$GenerateCLN();  if (is.null(ATT) || !is.list(ATT)) {    print("BayesSpike:TBSR5: Error in GenerateCLN!"); flush.console();  }  AttemptAttach <- "  Count <- ATT$Count;  CLN <- ATT$CLN;  ";  try(eval(parse(text=AttemptAttach)));    aMBS = .self$ABayesSpikeCL;  if (is.null(aMBS) && !is.null(.self$ABayesSpikeCL)) {    try(aMBS <- .self$ABayesSpikeCL);  }  if (exists("NumChains") && !is.null(NumChains) && NumChains > 0) {    .self$NumChains = NumChains;  } else if (.self$NumChains > 0) {     ##NumChains = .self$NumChains;   } else {    .self$NumChains = 3;  ##NumChains = 3;  }  if (sum(abs(.self$DoRecord)) == 0) {    .self$CodaTable = NULL;  .self$CodaList = NULL;    try(aMBS$CodaTable <- NULL);    try(aMBS$CodaList <- NULL);      if (.self$Verbose > 0) {      print(paste("GenerateCodaTable: DoRecords are null, ",        "set lists to zero, Returning NULL")); flush.console();    }    return(NULL);  }  if (.self$Verbose > 1) {    print("TBSR5:GenerateCodaTable: Starting to check DoRecord to find Count.");    flush.console();  }  try(.self$OldCodaNames <- paste(CLN, sep=""));  try(.self$FirstCLN <- paste(CLN, sep=""));  if (exists("aMBS") && !is.null(aMBS)) {    ##print(paste("Setting OldCodaNames to ",     ##  paste(CLN, collapse=", "), sep="")); flush.console();    MyTryText = "try(MBS$OldCodaNames <- paste(CLN, sep=\"\"))";    try(eval(parse(text=MyTryText)));  }  OtherCount = -1;  if (is.null(aMBS)) {    print("SetupCodaTable: before get OtherCount, we get NULL aMBS!");    flush.console();  }  try(OtherCount <- aMBS$NeedRecord);  if (is.null(OtherCount) || !is.numeric(OtherCount) || OtherCount == -1) {    print(paste("SetupCodaTable: we have OtherCount = ", OtherCount,       " while we did calculate Count = ", Count, sep=""));    flush.console();    return(-1);  }  if (!is.numeric(Count) || Count < 0) {    print(paste("SetupCodaTable: Bad Count? We have OtherCount = ", OtherCount,       " while we did calculate Count = ", Count, sep=""));    return(-1);  }  if (is.numeric(Count) && is.numeric(OtherCount) && Count != OtherCount) {    print(paste("I expect an error, Count = ", Count, " but OtherCount: ", OtherCount, sep=""))    print(paste("DoRecord: (", paste(.self$DoRecord, collapse =", "), ")", sep=""));    return(-1);  }  if (Verbose >= 2) {    print(paste("GenerateCodaTable:  Now CodaList being setup dim = (",      .self$MaxGibbsIters, ", ", Count, ").  Verbose = ", Verbose,      sep="")); flush.console();  }  .self$CodaList = list();  for (ii in 1:.self$NumChains) {    if (Verbose >= 1) {      print(paste("  Setting up Chain number ", ii, sep="")); flush.console();    }    .self$CodaTable = matrix(0, .self$MaxGibbsIters, Count);    if(!is.null(.self$CodaTableNames)) {      colnames(.self$CodaTable) = .self$CodaTableNames;    } else {      colnames(.self$CodaTable) = CLN;    }    try(.self$CodaTable <- as.mcmc(.self$CodaTable));    try(.self$CodaList[[ii]] <- .self$CodaTable);  }    try(.self$CodaList <- as.mcmc.list(.self$CodaList));  if (!is.null(colnames(.self$CodaList[[ii]])) &&     min(nchar(as.character(colnames(.self$CodaList[[ii]])))) > 0) {    try(.self$OldCodaNames <- paste(colnames(.self$CodaList[[ii]]), sep=""));   }  if (Verbose >= 3) {    print(paste("TBSR5: GenerateCodaTable: ABayesSpikeCL ",      "CodaList being attached to this", sep="")); flush.console();  }  try(aMBS$CodaList <- .self$CodaList);  ##if (!is.null(colnames(aMBS$CodaList[[1]]))) {  ##  try(aMBS$OldCodaNames <- paste(colnames(aMBS$CodaList[[1]]), sep=""));  ##}  if (!is.null(.self$CodaList) && length(.self$CodaList)  > 0) {    try(aMBS$OnCodaTable <- 1, silent=TRUE);  }     ##aMBS$CodaTable = .self$CodaTable;  ##if (!is.null(aMBS)) {   ##  try(aMBS$CodaList <- .self$CodaList);   ##  if (!is.null(colnames(aMBS$CodaList[[1]]) ) &&  ##    min(nchar(colnames(aMBS$CodaList[[1]]))) > 0) {  ##    ART <- paste(colnames(aMBS$CodaList[[1]]), sep="");  ##    try(aMBS$OldCodaNames <- ART);  ##  }  ##}  if (Verbose >= 1) {    print("GenerateCodaTable: Finished Setup of CodaList."); flush.console();  }  if (FALSE) {  eval(parse(text=GetG0Text(".ListBayesSpikeOb", "globalenv()")));  .ListBayesSpikeOb[[.self$NInstance]]$CodaTable <- .self$CodaTable;  .ListBayesSpikeOb[[.self$NInstance]]$CodaList <- .self$CodaList;  eval(parse(text=LockGText(".ListBayesSpikeOb", "globalenv()")));   }   return(1);});#################################################################################  GenerateEigenList####  Having eigenvalues and eigenvectors for each group of parameters is ##  important for quick imputation of P(tau^2_k > 0)##BayesSpikeR5$methods(  GenerateEigenList = function(AnotherBayesSpikeCL = NULL, ...) {    if (is.null(.self$sOnTau) || length(.self$sOnTau) <= 0 ||      is.null(.self$tauEndList) || length(.self$tauEndList) <= 0) {      print("GenerateEigenList: I don't think tauEndList is setup!");      flush.console();      return(1);    }  if (is.null(.self$sOnTau) || length(.self$sOnTau) <= 0 ||    is.null(.self$CtauEndList) || length(.self$tauEndList) <= 0) {    print("GenerateEigenList, why try to do this when it does not exist!");    flush.console();    return(1);  }  aMBS = NULL;  try(aMBS <- .self$ABayesSpikeCL);  if (is.null(aMBS)) {    print("BayesSpikeR5:GenerateEigenList issue, aMBS is NULL!");    flush.console();    return(-1);  }  if (is.null(aMBS$BeingDestroyed) || !is.numeric(aMBS$BeingDestroyed)) {    print("BayesSpikeR5:GenerateEigenList, can't tell what aMBS$BeingDestroyed is!");    flush.console(); return(-1);  }  if (aMBS$BeingDestroyed == 1) {    print("BayesSpikeR5:GenerateEigenList, aMBS is being destroyed!");    flush.console();return(-1);  }  ##if (is.null(.self$ABayesSpikeCL) && !is.null(AnotherBayesSpikeCL)) {  ##  .self$ABayesSpikeCL = AnotherBayesSpikeCL;  ##}  if (is.null(.self$ABayesSpikeCL$tauEndList)) {    print("DeNoieR5$GenerateEigenList: Error, R5 object End list is not null, BayesSpikeCL end list is!");    print(paste("self[TBSR5]$tauEndList = (",      paste( .self$tauEndList, collapse=", "), ")", sep=""));    flush.console(); return(-1);  }  ##ABayesSpikeCL = .self$ABayesSpikeCL;  if (is.null(aMBS) && !is.null(AnotherBayesSpikeCL)) {    print("GenerateEigenList:  Error, no BayesSpikeCL in R5 object, inserting the new one, PSYCH!!.");    ##.self$ABayesSpikeCL = AnotherBayesSpikeCL;    flush.console();   } else if (!is.null(aMBS)) {    if (.self$Verbose > 1) {      print("GenerateEigenList: we will attempt to keep current ABayesSpikeCL");    }  } else {    print("GenerateEigenList: Uh, woah, we've got no BayesSpikeCL to work with!"); flush.console();    tryCatch("Please investigate!");    ##.self$ABayesSpikeCL = AnotherBayesSpikeCL;  }  MSize  = 0;  if (is.null(aMBS)) {    print("GenerateEigenList: Uh woah, we've got no BayesSpikeCL before FirstRandom test!");    flush.console();    flush.console();  }  if (is.null(aMBS$FirstRandom)) {     print("error: GenerateEigenList has no FirstRandom!");     flush.console();     return(NULL);  }  Start = aMBS$CFirstRandom + 1;  if (.self$Verbose > 1) {    print("GenerateEigenList:  Getting X "); flush.console();  }  aX = aMBS$X;   if (.self$Verbose > 1) {    print("GenerateEigenList:  Got X "); flush.console();  }   if (is.null(aX) || is.null(dim(aX)) ||    length(prod(dim(aX))) == 0) {    print("GennerateEigenList, bad aX!"); flush.console();    }  if (NROW(aX) == 0 || NCOL(aX) == 0) {    print("GenerateEigenList: Error, aX has bad dimensions!"); flush.console();    tryCatch("GenerateEigenList: bad aX!");  }  ##tauEndList = .self$ABayesSpikeCL$tauEndList + 1;  if (.self$Verbose > 1) {    print("GenerateEigenList:  Start declaring .self EigenVectors and Values "); flush.console();  }  try(.self$AllEigenVectors <- list());  try(.self$AllEigenValues <- list());  if (.self$Verbose > 1) {    print("GenerateEigenList:  Begin Looping. "); flush.console();  }  if (!is.null(.self$tauEndList) && length(.self$tauEndList) >= 1) {  for (jj in 1:length(.self$tauEndList)) {    End = .self$tauEndList[jj];    if (End -Start <= 0) {      print(paste("Error GenerateEigenList, End=", End, " and Start = ", Start, sep=""));      flush.console();      tryCatch("Error: GenerateEigenList Bad, disordered tauEndList");    }    if (Start < 1) {      print(paste("Error: GenerateEigenList bad, on jj = ", jj,         " we get Start = ", Start, sep=""));      tryCatch("Error: GenreateEigenList, Start was bad!")    }    if (End > NCOL(aX)) {      print(paste("Error: GenerateEigenList bad, on jj = ", jj,         " we get End = ", End, " but dim aX = (",        paste(dim(aX), collapse=", "), ").", sep=""));      tryCatch("Error: GenreateEigenList, End was bad!")    }    if (.self$Verbose >= 4) {      print(paste("GenerateEigenList, jj = ", jj, "/", length(.self$tauEndList),         " and Start = ", Start, " and End =", End, " NCOL(aX) is: ", NCOL(aX), sep="")); flush.console();    }    XXSub = t(aX[,Start:End]) %*% aX[,Start:End];    if (.self$Verbose >= 4) {      print(paste("  GenerateEigenList, jj = ", jj, "/", length(.self$tauEndList),         " and Start = ", Start, " and End =", End, " now take eigen", sep="")); flush.console();    }    EG = eigen(XXSub);    if (.self$Verbose >= 4) {      print(paste("   GenerateEigenList, jj = ", jj, "/", length(.self$tauEndList),         " and Start = ", Start, " and End =", End, " got eigen", sep="")); flush.console();    }    try(.self$AllEigenVectors[[jj]] <- EG$vectors);    try(.self$AllEigenValues[[jj]] <- EG$values);       if (.self$Verbose >= 4) {      print(paste("      GenerateEigenList, jj = ", jj, "/", length(.self$tauEndList),         " and Start = ", Start, " and End =", End, ",  all assigned", sep="")); flush.console();    }      Start = End +1;  }  }  if (.self$Verbose > 3) {    print("TBSR5: Assigning the AllEigenValues"); flush.console();  }  ##.self$AllEigenVectors <- AllEigenVectorList;  ##.self$AllEigenValues <- AllEigenValueList;    if (.self$Verbose > 1) {    print("TBSR5: EigenValues generated assign to .listBayesSpikeOb"); flush.console();  }  if (FALSE) {  #################################################################  ##  Code here locks MyR to the BAYESSPIKENAMESPACE environment;  ##   ##BAYESSPIKENAMESPACE <- environment()  if (FALSE) {  TryO = NULL;  try( TryO <- bindingIsActive(".ListBayesSpikeOb", BAYESSPIKENAMESPACE), silent = TRUE);  if (!is.null(TryO) && (TryO == TRUE || TryO == FALSE)) {   unlockBinding( ".ListBayesSpikeOb" , BAYESSPIKENAMESPACE )  }    eval(parse(text=GetG0Text(".ListBayesSpikeOb", "globalenv()")));  .ListBayesSpikeOb <- get(".ListBayesSpikeOb", BAYESSPIKENAMESPACE);  if (.self$NInstance > 0) {    try(.ListBayesSpikeOb[[.self$NInstance]]$AllEigenVectors <- .self$AllEigenVectors);    try(.ListBayesSpikeOb[[.self$NInstance]]$AllEigenValues <- .self$AllEigenValues);  }  eval(parse(text=LockGText(".ListBayesSpikeOb", "globalenv()")));  }   ##ABayesSpikeCL$TBSRoo = this;  ##try(.self$ABayesSpikeCL$TBSR5 <- .self);  if (length(.ListBayesSpikeOb[[.self$NInstance]]$AllEigenValues)     != length(.self$tauEndList)) {    print("We're going to have an error in eigenvalues!");    print(paste(" Length All EigenValues  has length ", length(.self$AllEigenValues), sep=""));    for (ii in 1:length(.self$AllEigenValues)) {      print(paste("AllEigenValues[", ii, "] = c(",         paste(.self$AllEigenValues[[ii]], collapse=", "),        ")", sep="")); flush.console();    }    print(paste("tauEndList = c(", paste(.self$tauEndList, collapse=", "),      ")", sep="")); flush.console();          return(NULL);           }  }  if (.self$Verbose > 1) {    print("Assigning EigenVectors now to ABayesSpikeCL "); flush.console();  }  if (.self$NInstance > 0) {    try(aMBS$AllEigenVectors <- .self$AllEigenVectors);  }      if (.self$Verbose > 1) {    print("Assigning EigenValues now to ABayesSpikeCL "); flush.console();  }  try(aMBS$AllEigenValues <- .self$AllEigenValues);  if (.self$Verbose > 0) {    print("GenerateEigenValues:  Finishing.");     flush.console();  }  return(1);});BayesSpikeR5$methods(  BayesSpikeCppFromR5 = function() {  TBSR5 = .self;InitFlags <<- c(TBSR5$NInstance, TBSR5$Verbose[1]-1,   InitKKs, TBSR5$CFirstRandom); if (Verbose > 1) {  print(paste("Our initial InitFlags = ", paste(InitFlags, collapse=", "), sep="")); flush.console();}if (is.null(TBSR5)) {  print("BayesSpikeRegression: Failed to generate TBSR5, return error!");  return(-1);}if (is.null(TBSR5$sBeta) || length(TBSR5$sBeta) <= 0) {  print("BayesSpikeRegression: Error, sBeta is NULL, return error!");  return(TBSR5);}TBSR5$InitFlags = InitFlags;if (FALSE) {eval(parse(text=GetG0Text(".ListBayesSpikeOb", "globalenv()" )));if (length(.ListBayesSpikeOb) == 1 && is.numeric(.ListBayesSpikeOb) &&  .ListBayesSpikeOb == 0) {  print("Error: We were not able to find TBSR5 attached to global .ListBayesSpikeOb" ); flush.console();  }}if (Verbose > 1) {  print("BayesSpikeRegression: Recovering TBSR5 from the list"); flush.console();}if (FALSE) {TBSR5 = .ListBayesSpikeOb[[TBSR5$NInstance]];}if (Verbose > 1) {  print("BayesSpikeRegression: Getting BayesSpikeCL");  flush.console();}BayesSpikeCL <- modBayesSpikeCL$BayesSpikeCL;if (is.null(TBSR5$.X)) {  print("Error: TBSR5 did not write correctly, TBSR5$.X is NULL!");  return(TBSR5);}if (!is.null(TBSR5$dfRobit) && TBSR5$dfRobit > 0) {  intY = as.integer(TBSR5$Y);  vY = TBSR5$Y * .8 + .1;  ##try(TBSR5$.Y <- vY);}  else if (!is.null(dfRobit) && dfRobit == 0) {  intY = as.integer(Y);  vY <- Y * .8 + .1;  ##try(.Y <- vY);} else {  vY = TBSR5$.Y;}if (Verbose > 0) {  print("BayesSpikeRegression: Creating Rcpp C++ class"); flush.console();}aMBS <- NULL;try(aMBS <- new( BayesSpikeCL, TBSR5$.X, vY, TBSR5$Beta,   TBSR5$RandomInfoList, TBSR5$InitFlags, globalenv() ));if (is.null(aMBS)) {  eval(parse(text=SetGText("TBSR5", "globalenv()", S=1)));  print(paste("BayesSpikeRegression: Declaring new BayesSpikeCL produced an error. ")); flush.console();  print(" --  We will return to NULL, note that TBSR5 is set to global directory. "); flush.console();  return(TBSR5);}  if (Verbose > 1) {  print("BayesSpikeRegression: We Received MBS, setting the NInstance again");}try(.self$ABayesSpikeCL <- aMBS);try(aMBS$TBSR5 <- .self);if (Verbose > 1) {  print("BayesSpikeRegression: We're about to try to program in MBS to TBSR5!");  flush.console();}try(aMBS$TBSR5$ABayesSpikeCL <- MBS);if (Verbose > 1) {  print(paste("MBS's BayesSpkeNameSpace = ", as.character(is.environment(aMBS$BayesSpikeNameSpace)),    "  and BAYESSPIKENAMESPACE = ", as.character(is.environment(BAYESSPIKENAMESPACE)), sep="")); flush.console();  print(paste(" MBS's NInstance = ", aMBS$NInstance, sep="")); flush.console();  print(paste("  and TBSR5$NInstance = ", TBSR5$NInstance,    " and aMBS$TBSR5$NInstance = ", aMBS$TBSR5$NInstance, sep="")); flush.console();}##MBS$BayesSpikeNameSpace = BAYESSPIKENAMESPACE;  ##MBS$NInstance = TBSR5$NInstance;print("Checking MBS X"); flush.console();if (is.null(aMBS$X)) {  print("Uh Oh Reorge!,  aMBS$X is NULL!");   flush.console();}if (Verbose > 1){  print(paste("  Assigning MBS to TBSR5 ", sep="")); flush.console();}print("Setting Up Features of MBS");##MBS$TBSR5$ABayesSpikeCL = MBS;if (Verbose > 1)  {  print(paste("  Assigning aMBS$HowSample from TBSR5", sep="")); flush.console();}if (is.null(.self$HowSample) || .self$HowSample < 0) { .self$HowSample = 3; }aMBS$HowSample = .self$HowSample;if (Verbose > 2) {  print(paste("aMBS$HowSample  ", aMBS$HowSample, sep="")); flush.console();  }if (Verbose > 0) {  print("BayesSpikeRegression: Set up tauEndList/FirstRandom"); flush.console();}if (Verbose > 0) {  print(paste("BayesSpikeRegression: Setting up CtauEndList = ",    "(", paste(TBSR5$CtauEndList, collapse=", "), ")", sep=""))  flush.console();}aMBS$tauEndList = TBSR5$CtauEndList;aMBS$CFirstRandom = TBSR5$CFirstRandom;if (!is.null(aMBS$tauEndList)) {  aMBS$OnTau = TBSR5$sOnTau;}if (!is.null(dfRobit) && dfRobit >= 0) {  aMBS$SetupIntY(intY, dfRobit);}if (Verbose > 0) {  print("BayesSpikeRegression: Inserting TBSR5 pointer"); flush.console();}##### Inserts info into MBS to be able to destroy TBSR5aMBS$BayesSpikeNameSpace = globalenv();##MBS$TBSR5 = TBSR5;##MBS$Verbose = as.numeric(TBSR5$Verbose[1] -1);if (Verbose > 0) {  print("BayesSpikeRegression: Inserting DoMax"); flush.console();}aMBS$DoMax = DoMax;if (Verbose > 0) {  print("BayesSpikeRegression: GetRNGState?"); flush.console();}if (TBSR5$PutRNG == 1) {  aMBS$RNGState = 1;} else if (isNull(aMBS$TBSR5$PutRNG) || aMBS$TBSR5$PutRNG == 0) {} else {  aMBS$RNGState = 1;}if (is.numeric(PrintIter)) {  aMBS$PrintIter = as.integer(round(PrintIter));}if (Verbose > 0) {  print("BayesSpikeRegression: Generate EigenList"); flush.console();}if (!is.null(TBSR5$sOnTau) && length(TBSR5$sOnTau) > 0 &&  !is.null(TBSR5$tauEndList) && length(TBSR5$tauEndList) > 0 &&  (is.null(TBSR5$AllEigenValues) || length(TBSR5$AllEigenValues) !=     length(TBSR5$tauEndList) || (length(TBSR5$tauEndList) == 1 &&    is.numeric(TBSR5$AllEigenValues) && TBSR5$AllEigenValues[1] <= 0))) {  XE = NULL;  try(XE <- TBSR5$GenerateEigenList());   if (is.null(aMBS$TBSR5)) {    print("BayesSpikeRegression: Error after GenerateEigenList, we've got NULL TBSR5 in MBS!");  }  if (is.null(XE) || (is.numeric(XE) && XE[1] != 1)) {    print(paste("BayesSpikeRegression: GenerateEigenList Error, XE = ", XE, sep="")); flush.console();    return(aMBS$TBSR5);  }} else {  try(aMBS$AllEigenValues <- TBSR5$AllEigenValues);  try(aMBS$AllEigenVectors <- TBSR5$AllEigenVectors);}if (is.null(aMBS)) {  print("BayeSspikeRegression: Error after GenerateEigenList: MBS is NULL");  return(TBSR5);}if (aMBS$BeingDestroyed == 1) {  print("BayesSpikeRegression: Error after GenerateEigenList: MBS Being Destroyed was launched.");  return(TBSR5);}if (Verbose > 1) {  print(paste("BayesSpikeRegression: Finished EigenList with X == ", XE, sep=""));  flush.console();}if (Verbose > 1) {  print(paste("BayesSpikeRegression: Assign TypeFixed Prior", sep=""));  flush.console();}try(aMBS$TypeFixedPrior <- as.integer(aMBS$TBSR5$TypeFixedPrior));aMBS$tt = ttStart;aMBS$NumSamples = NumSamples;if (Verbose > 1) {  print("Assigning MBS$TBSR5$tauFixed "); flush.console();}aMBS$tauFixed = aMBS$TBSR5$tauFixed;aMBS$OnPiA <- aMBS$TBSR5$OnPiA; if (Verbose > 1) {  print("Assigning Now OnSigma "); flush.console();  print(paste("Current OnSigma = ", aMBS$OnSigma, sep=""));}aMBS$OnSigma = aMBS$TBSR5$OnSigma;if (Verbose > 1) {  print("BayesSpikeRegression: assigned OnSigma"); flush.console();}if (is.null(aMBS$OnSigma)) {  print("Uh Oh: after setup, MBS$OnSigma is Null!"); flush.console();  if (is.null(TBSR5$OnSigma)) {    print("TBSR5$OnSigma is null too."); flush.console();    return(TBSR5);  }  return(aMBS)}if (exists("EEMergeEvery") && !is.null(EEMergeEvery) && EEMergeEvery[1] > 0) {  aMBS$EEMergeEvery = ceiling(EEMergeEvery[1]);  }if (exists("EEProbSortWidth") && !is.null(EEProbSortWidth) &&  EEProbSortWidth[1] > 0) {  try(aMBS$EEProbSortWidth <- EEProbSortWidth);    }if (exists("burnin") && !is.null(burnin) && burnin[1] > 0) {  aMBS$burnin = ceiling(burnin[1]);}if (Verbose > 1) {  print(paste("BayesSpikeRegression: Assign PiA/Sigma Priors", sep=""));  flush.console();}if (length(aMBS$TBSR5$PiAPrior) <= 1) {  if (length(aMBS$TBSR5$PiAPrior) == 1) {    c(aMBS$TBSR5$PiAPrior[1], aMBS$TBSR5$PiAPrior[1]);  } else {    aMBS$TBSR5$PiAPrior <- c(2,2);  }}MyC = NULL;MyText = "try(aMBS$PiAPrior <- aMBS$TBSR5$PiAPrior);  MyC = 1;"try(eval(parse(text=MyText)));if (is.null(MyC)) {  print("Set PiAPrior Failed for MBS, here it is back!"); flush.console();  return(aMBS);}MyC = NULL;MyText = "try(aMBS$SigmaPrior <- aMBS$TBSR5$SigmaPrior);  MyC = 1;"try(eval(parse(text=MyText)));if (is.null(MyC)) {  print("Set SigmaPrior Failed for MBS, here it is back!"); flush.console();  return(aMBS);}if (Verbose > 1) {  print(paste("BayesSpikeRegression: MaxIters, CauchyEpsilon", sep=""));  flush.console();}aMBS$MaxIters = MaxIters;  aMBS$CauchyEpsilon = CauchyEpsilon; aMBS$MaximizeMeCauchyTotalIters  = aMBS$TBSR5$MaximizeMeCauchyTotalIters;if (StartRunProbVector >= -1) {  aMBS$SetupRunProbVector(StartRunProbVector);  if (TBSR5$RegionWidth > 1) {    try(aMBS$RegionWidth <- TBSR5$RegionWidth)  }}if (Verbose > 1) {  print(paste("BayesSpikeRegression: tauPriordf = ", TBSR5$tauPriordf,    " and tauPriorMean = ", tauPriorMean, sep=""));  flush.console();}if (!is.null(TBSR5$tauEndList) &&  (length(TBSR5$tauEndList) > 0) &&  (is.null(TBSR5$tauPriordf) || is.null(TBSR5$tauPriorMean)) ) {  print("Please set Priordf and mean for Mixed Selection Regression");  flush.console(); return(TBSR5);}if (Verbose > 1) {  print(paste("Asking about Null ness of tauEndList", sep=""));  flush.console();}if (!is.null(aMBS$TBSR5$tauEndList) && length(aMBS$TBSR5$tauEndList) > 0) {  if (is.null(aMBS) || is.null(aMBS$BeingDestroyed) || aMBS$BeingDestroyed == 1) {    print("BayesSpikeRegression: Error before set tauPriordf.");    return(TBSR5);  }  try(aMBS$tauPriordf <- aMBS$TBSR5$tauPriordf);  try(aMBS$tauPriorMean <- aMBS$TBSR5$tauPriorMean);  if (Verbose > 0) {    print("BayesSpikeRegression: SetupMT()"); flush.console();  }  if (is.null(aMBS) || is.null(aMBS$BeingDestroyed) || aMBS$BeingDestroyed == 1) {    print("BayesSpikeRegression: Error before SetupMT: aMBS Being Destroyed was launched.");    return(TBSR5);  }  try(aMBS$SetupMT());  if (is.null(aMBS) || is.null(aMBS$BeingDestroyed) || aMBS$BeingDestroyed == 1) {    print("BayesSpikeRegression: Error after SetupMT: MBS Being Destroyed was launched.");    return(TBSR5);  }}if (Verbose > 1) {  print(paste("BayesSpikeRegression: Assign DoRecord", sep=""));  flush.console();}if (is.null(.self$sOnTau) || length(.self$sOnTau)  <= 0 ||  length(.self$sOnTau) <= 0 || is.null(.self$tauEndList)   || length(.self$tauEndList) <= 0) {  try(.self$DoRecord[2] <- 0); try(.self$DoRecord[7] <- 0); }try(aMBS$DoRecord <- .self$DoRecord);if (!is.null(aMBS$TBSR5$MaxGibbsIters) && aMBS$TBSR5$MaxGibbsIters > 0) {try(aMBS$MaxGibbsIters <- aMBS$TBSR5$MaxGibbsIters);} else {  try(aMBS$MaxGibbsIters <- aMaxGibbsIters);} if (aMBS$CFirstRandom != 0) {  if (Verbose > 1) {   print("BayesSpikeRegression: Setting up Prob Fixed. "); flush.console();  }  try(MBS$SetupProbFixed());  if (is.null(aMBS) || is.null(aMBS$BeingDestroyed) || aMBS$BeingDestroyed == 1) {    print("BayesSpikeRegression: Error after SetupProbFixed: MBS Being Destroyed was launched.");    return(TBSR5);  }}if (!is.null(aMBS$TBSR5$tauEndList) && length(aMBS$TBSR5$tauEndList) > 0) {  if (Verbose > 1) {    print("BayesSpikeRegression: SetupProbTau."); flush.console();  }  if (is.null(aMBS) || is.null(aMBS$BeingDestroyed) || aMBS$BeingDestroyed == 1) {    print("BayesSpikeRegression: Error before SetupProbTotal: MBS Being Destroyed was launched.");    return(TBSR5);  }  try(aMBS$SetupProbTau()); }try(aMBS$MaxGibbsIters <- aMBS$TBSR5$MaxGibbsIters);if (is.null(aMBS) || is.null(aMBS$BeingDestroyed) ||  (is.numeric(aMBS$BeingDestroyed) && aMBS$BeingDestroyed == 1)) {  print("BayesSpikeRegression: Error before set MBS$dfTNoise, MBS being destroyed.");  flust.console(); return(TBSR5);  }if (is.null(aMBS$TBSR5)) {  print("BayesSpikeRegression: Error before set MBS$dfTNoise, TBSR5 is inaccessible");  flush.console();  return(TBSR5);}if (!is.numeric(aMBS$TBSR5$dfTNoise)) {  print("BayeSpikeRegression: Error before set aMBS$dfTNoise, TBSR5$dfTNoise is not numeric!");  flush.console();  return(TBSR5);}BZ = 0;ATryText = "if (Verbose > 1) {  print(paste(\"BayesSpikeRegression: aMBS$TBSR5$dfTNoise[1] = \",    aMBS$TBSR5$dfTNoise[1], sep=\"\")); flush.console();}if (!is.null(aMBS) && !is.null(aMBS$TBSR5) &&   is.numeric(aMBS$TBSR5$dfTNoise) && length(aMBS$TBSR5$dfTNoise) >= 1 &&  aMBS$TBSR5$dfTNoise[1] > 0) {  if (Verbose > 1) {    print(\"BayesSpikeRegression: Setup dfTNoise\");flush.console();  }  try(aMBS$dfTNoise <- aMBS$TBSR5$dfTNoise);}BZ = 1;";try(eval(parse(text=ATryText)));if (BZ != 1) {  print("BayesSpikeRegression: Issue after attempt to setup dfTNoise for MBS");  flush.console();  return(TBSR5);}if (Verbose > 0) {  print("BayesSpikeRegression: Setup Dependencies"); flush.console();}if (is.null(aMBS) || is.null(aMBS$BeingDestroyed) || (is.numeric(aMBS$BeingDestroyed) &&  aMBS$BeingDestroyed == 1)) {  print("BayesSpikeRegression: Error before check Early End Steps!");  flush.console(); return(TBSR5);  }if (!is.numeric(aMBS$TBSR5$EarlyEndStep)) {  print("BayesSpikeRegression: Check, EarlyEndStep is not numeric in TBSR5!");  flush.console();}if (!is.null(aMBS$TBSR5$EarlyEndStep) && aMBS$TBSR5$EarlyEndStep >= 0)  {  if (Verbose > 1) {    print(paste("BayesSpikeRegression: Setup EarlyEndStep = ",       aMBS$TBSR5$EarlyEndStep, " and EarlyEndtt=",      aMBS$TBSR5$EarlyEndtt, sep="")); flush.console();  }  try(aMBS$EarlyEndStep <- aMBS$TBSR5$EarlyEndStep);  try(aMBS$EarlyEndtt <- aMBS$TBSR5$EarlyEndtt);}if (Verbose > 1) {  print("BayesSpikeRegression: About to insert Dependencies.");  flush.console();}BZ = 0;ATryText = "if (!is.null(MBS$TBSR5$DependenciesTau)  && length(aMBS$TBSR5$DependenciesTau) > 0) {  print(\"BayesSpikeRegression: Setting up aMBS$DependenciesTau.\");  flush.console();  if (length(aMBS$TBSR5$DependenciesTau)  != length(aMBS$tauEndList)) {    print(paste(\"BayesSpikeRegression: issue aMBS$DependenciesTau length = \",      length(aMBS$TBSR5$DependenciesTau), \" but length tauEndList = \",      length(aMBS$tauEndList), sep=\"\")); flush.console();    return(TBSR5);  }  try(aMBS$DependenciesTau <- aMBS$TBSR5$DependenciesTau);  try(aMBS$DependenciesFixed <- aMBS$TBSR5$DependenciesFixed);}BZ = 1;"try(eval(parse(text=ATryText)));if (BZ != 1) {  print("BayesSpikeRegression: Something was awry in setup DependenciesTau.");  flush.console();}if (!is.null(AFD)) {   if (Verbose > 1) {    print("BayesSpikeRegression: Inserting AFD to aMBS.");    flush.console();  }  try(aMBS$AFD <- AFD); }if (OnChainIter <= 0 || OnChainIter > aMBS$TBSR5$NumChains) {  MyTTOnChainIter <- "  OnChainIter = 1;   ";  try(eval(parse(text=MyTTOnChainIter)));}aMBS$TBSR5$OnChainIter = OnChainIter;if (sum(abs(DoRecord) > 0)) {  if (!is.null(aMBS$CodaList) && length(aMBS$CodaList) >= OnChainIter) {  try(aMBS$OnCodaTable <- OnChainIter); }}if (!is.null(SaveDir)  && is.character(SaveDir) &&   !(SaveDir %in% c("", "NoSave", "NOSAVE")) ) {try(dir.create(SaveDir, recursive=TRUE, showWarnings=FALSE));}if (!is.null(aMBS$TBSR5$NoShrinkFixed)) {  try(aMBS$NoShrinkFixed <- aMBS$TBSR5$CNoShrinkFixed);  try(aMBS$NoShrinkFixedPrior <- aMBS$TBSR5$NoShrinkFixedPrior);}if (!is.null(aMBS$TBSR5$NoShrinkRandom)) {  try(aMBS$NoShrinkRandom <- aMBS$TBSR5$CNoShrinkRandom);  try(aMBS$NoShrinkRandomPrior <- aMBS$TBSR5$NoShrinkRandomPrior);}if (Verbose > 0) {  print(paste("BayesSpikeRegression: SetupSaveFile: ", TBSR5$FileName, sep="")); flush.console();}if (is.null(aMBS)) {  print("BayesSpikeRegression, weird, MBS is Null before SetupFile!");  return(TBSR5);}if (is.null(aMBS$BeingDestroyed) || !is.numeric(aMBS$BeingDestroyed) ||  aMBS$BeingDestroyed == 1) {  print("BayesSpikeRegression, weird, MBS is being destroyed before Setup SaveFile.");  flush.console();    return(TBSR5);}if (is.null(aMBS$TBSR5)) {  print("BayesSpikeRegression: Weird, aMBS starts with TBSR5 being NULL!");  return(aMBS);}if (is.null(aMBS$TBSR5$ABayesSpikeCL)) {  print("BayesSpikeRegression: Do, before Save File, aMBS$TBSR5$ABSCL is null!");  try(aMBS$TBSR5$ABayesSpikeCL <- aMBS);}if (is.null(aMBS$TBSR5$ABayesSpikeCL$BeingDestroyed) ||  !is.numeric(aMBS$TBSR5$ABayesSpikeCL$BeingDestroyed)) {  print("BayesSpikeRegression: Don't know if TBSR5$MBS is being destroyed");  flush.console(); return(aMBS);  }if (aMBS$TBSR5$ABayesSpikeCL$BeingDestroyed[1] == 1) {  print(paste("BayesSpikeRegression: Before setup file, we have ",    "aMBS$TBSR5$ABayesspikeCL has problems, find a fix, return MBS.", sep=""));  flush.console();  return(aMBS);  }if (!is.null(aMBS$TBSR5$FileName) && nchar(aMBS$TBSR5$FileName) > 0) {  AD = -1;  try(AD <- aMBS$TBSR5$SetupSaveFile(SaveDir=SaveDir, FileName = TBSR5$FileName,    chainiter = OnChainIter));  if (is.null(AD) || !is.numeric(AD) || AD < 0) {    print("aMBS$TBSR5: Error SetupSaveFile Ended badly!"); flush.console();  }  if (aMBS$Verbose >= 1) {    print("Setup aMBS$TBSR5: finished SetupSaveFile."); flush.console();  }}if (aMBS$Verbose >= 1) {  print("aMBS$NewWrite: setting NewWrite."); flush.console();}try(aMBS$NewWrite <- aMBS$TBSR5$NewWrite);if (aMBS$Verbose >= 1) {  print("Setup aMBS$TBSR5: finished setup New Write."); flush.console();}if (Verbose > 0) {  print(paste("BayesSpikeRegression: Finished SetUpSaveFile and NewWrite.", sep="")); flush.console();}if (TBSR5$Verbose > 1) {  print("BayesSpikeRegression: Setup, setting up PriorProbTau for TBSR5.");  flush.console();}MyEval = NULL;if (!is.null(TBSR5$PriorProbTau) && !is.null(TBSR5$PriorProbFixed)) {  if (TBSR5$Verbose >= 1) {    print("BayesSpikeRegression: About to set PriorProbTau");    flush.console();  }  if (is.null(TBSR5$sOnTau) || length(TBSR5$sOnTau) <= 0 ||    is.null(TBSR5$tauEndList) || length(TBSR5$tauEndList) <= 0) {    TBSR5$PriorProbTau = NULL;   } else if (is.numeric(TBSR5$PriorProbTau) &&    (TBSR5$PriorProbTau[1] < 0 || TBSR5$PriorProbTau[1] > 1.0)) {    TBSR5$PriorProbTau = rep(.5, length(TBSR5$tauEndList));  } else if (length(TBSR5$PriorProbTau) < length(TBSR5$tauEndList)) {    TBSR5$PriorProbTau = rep(TBSR5$PriorProbTau[1], length(TBSR5$tauEndList));  }  if (aMBS$CFirstRandom > 0) {    if (is.numeric(PriorProbFixed) && length(PriorProbFixed) >= 1 && PriorProbFixed[1] > 0) {      TBSR5$PriorProbFixed = rep(.5, aMBS$CFirstRandom);     } else if (length(TBSR5$PriorProbFixed) != aMBS$CFirstRandom) {      TBSR5$PriorProbFixed = rep(unlist(TBSR5$PriorProbFixed)[1], aMBS$CFirstRandom);    }  } else {    TBSR5$PriorProbFixed = NULL;  }  if (aMBS$Verbose >= 2) {    print("BayesSpikeRegression: PriorProbTau and PriorProbFixed being set.");    flush.console();  }  MyText = "if (is.null(TBSR5$sOnTau) || length(TBSR5$sOnTau) <= 0 ||    is.null(TBSR5$tauEndList) || length(TBSR5$tauEndList) <= 0) {      try(TBSR5$PriorProbTau <- NULL);       try(aMBS$PriorProbTau) <= NULL);    } else {      aMBS$PriorProbTau <- TBSR5$PriorProbTau;     }     aMBS$PriorProbFixed <- TBSR5$PriorProbFixed; MyEval <- 1;"  try(eval(parse(text=MyText)));  if (aMBS$Verbose >= 2) {    print("BayesSpikeRegression: Done setting Tau and Fixed.");    flush.console();  }}if (is.null(MyEval)) {  print("MBS: Error, attempt to set PriorProbTau, PriorProbFixed ended in fail"); flush.console();  }if (Verbose > -1) {  print("BayesSpikeRegression: Finished installing PriorProbTau"); flush.console();}aMBS$HowSample = aMBS$TBSR5$HowSample;##MBS$SetupMTForOnii(2);##MBS$MaximizeOn();##XX = (1:400)/10;##MyF= XX * 0;##for (ii in 1:length(XX)) { MyF[ii] = MBS$GiveLOfX(XX[ii])}##MBS$GiveLOfX(1);##MBS$GiveLOfX(.1);##MBS$SampleANewTau(0);if (!is.null(TBSR5$TemperatureList)) {  if (Verbose > -1) {    print("BayesSpikeRegression: Installing a nonNull TemepratureList"); flush.console();  }  try(aMBS$TemperatureList <- TBSR5$TemperatureList);  if (Verbose > -1) {    print("BayesSpikeRegression: TemepratureList Installed"); flush.console();  }  try(aMBS$TemperatureDecreasingRate <- TBSR5$TemperatureDecreasingRate); }##MBS$Verbose = 10;##MBS$EarlyEndStep = -1;  aMBS$EarlyEndtt = -1;if (sum(abs(aMBS$TBSR5$DoRecord) > 0)) {  if (Verbose > -1) {    print("BayesSpikeRegression: DoRecord > 0 so Generating Coda Table"); flush.console();  }  BZ = -1;  ATryText = "  aMBS$TBSR5$GenerateCodaTable(Verbose = Verbose);  BZ = 1;  ";  try(eval(parse(text=ATryText)));  if (is.null(BZ) || !is.numeric(BZ) || BZ != 1) {    print("BayesSpikeRegression: something went wrong trying to generate coda table!.");    flush.console();  }  if (Verbose > -1) {    print("BayesSpikeRegression: Finished Generating Coda Table"); flush.console();  }  }if (Verbose > 1) {  print("BayesSpikeRgression: checking out CodaList."); flush.console();}if (!is.null(aMBS$CodaList)) {  if (Verbose > 1) {    print("BayesSpikeRegression: aMBS$CodaList is not null, Setting STT"); flush.console();  }  eval(parse(text=GetG0Text("STT", S=1)));  try(STT <- OnChainIter:length(aMBS$CodaList));  if (is.numeric(STT) && STT[1] == 0) {    try(STT <- 1:aMBS$TBSR5$NumChains);  }  ##if (!is.null(colnames(aMBS$CodaList[[1]])) &&  ##  min(nchar(as.character(colnames(aMBS$CodaList[[1]])))) > 0) {  ##  try(aMBS$OldCodaNames <- paste(colnames(aMBS$CodaList[[1]]), sep=""));    ##}  try(eval(parse(text=SetGText("STT", S=1))));  try(aMBSOnCodaTable <- STT[1]);  try(aMBS$MaxGibbsIters <- length(aMBS$CodaList[[1]][,1]));} else if (aMBS$TBSR5$NumChains > 0) {  eval(parse(text=GetG0Text("STT", S=1)));  try(STT <- 1:aMBS$TBSR5$NumChains);  eval(parse(text=SetGText("STT", S=1)));} else {  eval(parse(text=GetG0Text("STT", S=1)));  if (Verbose > 1) {    print("Unfortunately as feature of STT, must set STT to NULL");  }  STT = NULL;  eval(parse(text=SetGText("STT", S=1)));}if (aMBS$dfTNoise > 0) {   print("dfTNoise: MBS is greater than zero, hoo boy!"); flush.console();   print(paste("aMBS$dfTNoise = ", aMBS$dfTNoise, " and TBSR5$dfTNoise = ",      TBSR5$dfTNoise, sep="")); flush.console();   ##return(aMBS);}  if (aMBS$TBSR5$EarlyEndStep >= 0) {    if (Verbose > -1) {      print("BayesSpikeRegression: Setting up Early End Step/ Early End tt"); flush.console();    }    aMBS$EarlyEndStep = aMBS$TBSR5$EarlyEndStep;      aMBS$EarlyEndtt = aMBS$TBSR5$EarlyEndtt;  }  try(.self$ABayesSpikeCL <- aMBS);  try(aMBS$TBSR5 <- .self);  return(aMBS);});  BayesSpikeR5$methods(  CopyAll = function(shallow=FALSE,...) {    if (.self$Verbose >= 1) {      print("BayesSpikeR5: Copying."); flush.console();    }    MyList <- .self$FullCopy();    MyR = NULL;    try(MyR <- ReLoad(MyList));    if (is.null(MyR)) {      print("Basic Full Copy and Reload failed.  Attempt a smaller function!"); flush.console();    } else {      return(MyR);    }  },   copy = function(shallow=FALSE, ...) {    if (.self$Verbose >= 1) {      print("BayesSpikeR5: Copying."); flush.console();    }        if (is.null(.self$.X) || length(.self$.X) == 0) {      aX = matrix(0,0,0);    }  else { aX = matrix(as.numeric(.self$.X),NROW(.self$.X),NCOL(.self$.X)); }    if (is.null(.self$.Y) || length(.self$.Y) == 0) {      aY = vector("numeric",0);    }  else { aY = as.vector(matrix(as.numeric(.self$.Y),length(.self$.Y),1)); }    if (is.null(.self$.Z) || length(.self$.Z) == 0) {      aZ = vector("numeric",0);    }  else { aZ = as.vector(matrix(as.numeric(.self$.Z),length(.),1)); }    AAFD = .self$AFD;    if (shallow == FALSE) {      try(AAFD <- Copy(AAFD));    }    NewR5 = BayesSpikeR5$new(X=aX, Y=aY, Z = aZ,      BetaStart = .self$BetaStart + 0.0,      tauEndList = .self$tauEndList, sOnTau = .self$sOnTau,       FirstRandom = .self$FirstRandom, tauFixed=.self$tauFixed,       TypeFixedPrior = .self$TypeFixedPrior, HowSample = .self$HowSample,      tauPriordf = .self$tauPriordf, tauPriorMean = .self$tauPriorMean,        NumChains = .self$NumChains, OnSigma = .self$OnSigma,       OnPiA = .self$OnPiA, PiAPrior = .self$PiAPrior, SigmaPrior = .self$SigmaPrior,      NoShrinkFixed=.self$NoShrinkFixed, NoShrinkFixedPrior = .self$NoShrinkFixedPrior,      NoShrinkRandom=.self$NoShrinkRandom,NoShrinkRandomPrior = .self$NoShrinkRandomPrior,      DoEEProbSort = .self$DoEEProbSort,  NInstance = -1,      TemperatureList = .self$TemperatureList, RandomInfoList=.self$RandomInfoList,      TemperatureDecreasingRate = .self$TemperatureDecreasingRate,      FileSave = .self$FileSave,      SaveDir = .self$SaveDir,     FileName = .self$FileName,  NewWrite = .self$NewWrite,    DoRecord = .self$DoRecord, MaxGibbsIters = .self$MaxGibbsIters,     NumSamples = .self$NumSamples,    CauchyEpsilon = .self$CauchyEpsilon, MaxIters = .self$MaxIters,     AFD=AAFD, PutRNG = .self$PutRNG, DependenciesTau = .self$DependenciesTau,    MaximizeMeCauchyTotalIters = .self$MaximizeMeCauchyTotalIters,  DependenciesFixed = .self$DependenciesFixed,  EarlyEndStep = .self$EarlyEndStep, EarlyEndtt = .self$EarlyEndtt,  ttStart = .self$ttStart, InitFlags =.self$InitFlags,  CodaTableNames = .self$CodaTableNames,   DoMax = .self$DoMax,  dfTNoise = .self$dfTNoise,  ListChainIters = .self$ListChainIters,  Verbose = .self$Verbose, MyPS = .self$MyPS$copy(),  RStart = .self$RStart, TempCoda = .self$TempCoda,   TempCodaIDs = .self$TempCodaIDs);  if (.self$Verbose >= 2) {    print("BayesSpikeR5: Generated Copy, now checking Shallow.");    flush.console();  }  if (shallow == FALSE  && !is.null(NewR5$CodaList)) {    if (length(.self$CodaTable) > 0) {       try(NewM <- matrix( as.numeric(.self$CodaTable), NROW(.self$CodaTable),         NCOL(.self$CodaTable)));       try(colnames(NewM) <- colnames(.self$CodaTable));       try(NewR5$CodaTable <- as.mcmc(NewM));    }  else {       try( NewR5$CodaTable <- as.mcmc(matrix(0,0,0)) );    }    if (length(.self$CodaList) > 0) {      ANew = list();      for (ii in 1:length(.self$CodaList)) {         try(NewM <-            matrix( as.numeric(.self$CodaList[[ii]]), NROW(.self$CodaList[[ii]]),         NCOL(.self$CodaList[[ii]])));       try(colnames(NewM) <- colnames(.self$CodaList[[ii]]));       try(ANew[[ii]] <- as.mcmc(NewM));      }      try(NewR5$CodaList <- as.mcmc.list(ANew), silent=TRUE);      if (is.null(NewR5$CodaList) || length(NewR5$CodaList) == 0) {        try(NewR5$CodaList <- as.mcmc(ANew), silent=TRUE);      }    } else {      try(NewR5$CodaList <- NULL);    }  } else {    NewR5$CodaTable = .self$CodaTable;    NewR5$CodaList = .self$CodaList;  }  if (shallow == FALSE && !is.null$self$ABayesSpikeCL) {    NewR5$ABayesSpikeCL = NewR5$BayesSpikeCppFromR5();  } else {    NewR5$ABayesSpikeCL = .self$ABayesSpikeCL;  }  if (.self$Verbose >= 1) {    print("BayesSpikeR5: Finished Copying."); flush.console();  }    return(NewR5);  });BayesSpikeR5$methods(  LoadSubCodaList = function(StartIter = 0, EndIter = 2000,    SubSetCoords = NULL, DoProb = -1, DoAllTemp = -1, DoPostBuff = -1, DoILoc = -1) {    try(library(coda));    if (!exists("DoProb") || is.null(DoProb) || (is.numeric(DoProb) && length(DoProb) == 1 &&      DoProb[1] == -1)) {      MyT <- "DoProb <- .self$.DoProb";  eval(parse(text=MyT));    }     StartIter = as.numeric(StartIter);    EndIter = as.numeric(EndIter);    if (EndIter == 2000 && .self$MaxGibbsIters != 2000) {      ATryText <- "EndIter <- .self$MaxGibbsIters";      try(eval(parse(text=ATryText)));    }    if (EndIter > .self$MaxGibbsIters) {        EndIter = .self$MaxGibbsIters;    }    if (( is.null(.self$SubSetCoords)  || length(.self$SubSetCoords) == 0) &&      (is.null(SubSetCoords) || length(SubSetCoords) == 0)) {      print("BayesSpikeR5: LoadSubCodaList: please supply SubSetCoords");      flush.console();       tryCatch("LoadSubCodaList: At first load in SubSetCoords cannot be filled for both NULL");    }    if (length(.self$SubSetCoords) <= 0 && !is.null(SubSetCoords) && length(SubSetCoords) > 0) {      try(.self$SubSetCoords <- as.integer(sort(unique(as.integer(        SubSetCoords[SubSetCoords >= 1 & SubSetCoords <= .self$p])))));    }    if (length(.self$SubSetCoords) >= 0) {      MyTxt = "SubSetCoords <- .self$SubSetCoords";      try(eval(parse(text=MyTxt)));    }    if (is.null(SubSetCoords) || length(SubSetCoords) <= 0) {       print("LoadSubCodaList:  ERROR, sorry, SubSetCoords supplied is length at end!");       tryCatch("LoadSubCodaList, no SubSetCoords to make this worthwhile!  Somehow NULL at End!");    }    if (StartIter != 0) {      ##StartIter = StartIter;    }    if (EndIter != 2000) {      ##.self$EndIter = EndIter;    }    ACodaThings <- NULL;     try(ACodaThings <- ReturnSubCodaFromFiles(      TBSR5 = .self,        StartIter = StartIter, EndIter = EndIter,      Verbose = .self$Verbose, SubSetCoords = .self$SubSetCoords, DoProb=DoProb,      DoPostBuff = .self$DoPostBuff, DoILoc = .self$DoILoc));    if (.self$Verbose >= 1) {      print("LoadSubSetCoords, ReturnSubCodaFromFiles is finished.  "); flush.console();      print(paste("Length ACodaThings is ", length(ACodaThings),        " with names: ", paste(names(ACodaThings), collapse=", "), ".", sep=""));      flush.console();    }    if (any(names(ACodaThings) == "CodaBeta")) {      if (.self$Verbose >= -1) {        print(paste("LoadSubSetCoords, We found a CodaBeta of length  ",          length(ACodaThings$CodaBeta), sep="")); flush.console();        flush.console();      }      ABT <- "      if (length(ACodaThings$CodaBeta) >= 1) {      for (jj in 1:length(ACodaThings$CodaBeta)) {        if (any(is.na(ACodaThings$CodaBeta[[jj]]))) {          ACodaThings$CodaBeta[[jj]][is.na(ACodaThings$CodaBeta[[jj]])]  <- 0;        }      }      } else {        try(print(paste(\"Hey: LoadSubCodaList, the names of ACodaThings are \",          paste(names(ACodaThings), collapse=\", \", sep=\"\"),          \" but length(CodaBeta) = \", length(ACodaThings$CodaBeta), sep=\"\")));        flush.console();      }      ";      try(eval(parse(text=ABT)));      .self$.SubCodaList <- ACodaThings$CodaBeta;      .self$OtherSubCoda <- ACodaThings;    } else {      ABT <- "      for (jj in 1:length(ACodaThings)) {        if (any(is.na(ACodaThings[[jj]]))) {          ACodaThings[[jj]][is.na(ACodaThings[[jj]])]  <- 0;        }      }      ";      try(eval(parse(text=ABT)));      try(.self$.SubCodaList <- ACodaThings)    }    if (!is.null(.self$ABayesSpikeCL)) {      try(.self$ABayesSpikeCL$SubCodaList <- .self$.SubCodaList);    }    return(.self$.SubCodaList);});BayesSpikeR5$methods(  LoadSubCodaLongList = function(StartIter = -1, EndIter = 2000,    SubSetCoords = NULL) {        StartIter = as.numeric(StartIter);    if (is.null(StartIter) || StartIter[1] < 0) {      StartIter <- .self$ABayesSpikeCL$burnin;    }    EndIter = as.numeric(EndIter);    if (EndIter == 2000 && .self$MaxGibbsIters != 2000) {      ATryText <- "EndIter <- .self$MaxGibbsIters";      try(eval(parse(text=ATryText)));    }    if (( is.null(.self$SubSetCoords)  || length(.self$SubSetCoords) <= 0) &&      (is.null(SubSetCoords) || length(SubSetCoords) <= 0)) {      print("BayesSpikeR5: LoadSubCodaLongList: please supply SubSetCoords");      flush.console();      print("ERROR ERROR ERROR ERROR LongSubCodaLongList "); flush.console();      tryCatch("SubSetCoords: LongSubCodaLongList: There was something initially wrong with SubSetCoords!")    }     if (length(.self$SubSetCoords) <= 0 && !is.null(SubSetCoords) && length(SubSetCoords) > 0) {      try(.self$SubSetCoords <- as.integer(sort(unique(as.integer(        SubSetCoords[SubSetCoords >= 1 & SubSetCoords <= .self$p])))));    }    MyT = "      try(SubSetCoords <- .self$SubSetCoords);    "    try(eval(parse(text=MyT)));    if (is.null(SubSetCoords) || length(SubSetCoords) <= 0) {      print("BayesSpikeR5.r: SubSetCoords after back and forth is NULL length, bad!");      tryCatch("BayesSpikeR5: LoadSubCodaLongList, bad SubSetCoords supplied!");    }    if (length(.self$SubSetCoords) <= 0) {     print("BayesSpikeR5.r:::LoadSubCodaLongList; No Coordinates available."); flush.console();     return(1);    }    if (StartIter != 0) {      ##StartIter = StartIter;    }    if (EndIter != .self$MaxGibbsIters) {      ##.self$EndIter = EndIter;    }    ACodaThings <- NULL;         if (!is.null(.self$SaveDir)) {       Dir = .self$SaveDir;       if (.self$Verbose > 1) {         print(paste("TBSR5:GenerateSubCodaLongList: We're going to pull files from SaveDir = ", Dir, sep=""));         try(print(paste("ListSaveFiles = (", paste(unlist(.self$ListSaveFiles), collapse=", "),           ")", sep=""))); flush.console();         flush.console();       }       MyNFiles = unlist(list.files(Dir));       MyNFiles <- MyNFiles[substr(MyNFiles, 1, nchar(.self$FileName)) ==          .self$FileName];       BetaLongBuffFiles =   MyNFiles[        substr(MyNFiles, nchar(MyNFiles)-nchar("LongBeta.bin")+1,         nchar(MyNFiles)) == "LongBeta.bin"];       BetaLongBuffFiles = paste(Dir, "//", BetaLongBuffFiles, sep="")    } else if (!is.null(.self$ListSaveFiles)) {        Dir = .self$SaveDir;        LSFiles = sort(unique(unlist(.self$ListSaveFiles)));        for (ii in 1:length(LSFiles)) {         if (substr(LSFiles[ii], 1, nchar(Dir)) == Dir) {          LSFiles[ii] = substr(LSFiles[ii], nchar(Dir)+1, nchar(LSFiles[ii]));          AT = unlist(strsplit(LSFiles[ii], "/"))          LSFiles[ii] = AT[length(AT)]         }        }        try(BetaLongBuffFiles <-  paste(LSFiles,           "LongBeta.bin", sep="") );     }      .self$.SubCodaLongList = NULL;      if (length(BetaLongBuffFiles) > 0) {        ATFList <- list();        if (!is.null(.self$ABayesSpikeCL$TemperatureList) &&          length(.self$ABayesSpikeCL$TemperatureList) > 0) {          for (jj in 1:length(.self$ABayesSpikeCL$TemperatureList)) {            AT <- c();            for (ttC in 1:.self$NumChains) {              if (jj < length(.self$ABayesSpikeCL$TemperatureList)) {                AT <- c(AT,                  BetaLongBuffFiles[                 substr(BetaLongBuffFiles, nchar(BetaLongBuffFiles) -                  nchar(paste("T",jj-1,"C", ttC, "LongBeta.bin", sep=""))+1,                 nchar(BetaLongBuffFiles)) == paste("T",jj-1,"C", ttC, "LongBeta.bin", sep="")]                )              } else {                  AT <- c(AT,                  BetaLongBuffFiles[                 substr(BetaLongBuffFiles, nchar(BetaLongBuffFiles) -                  nchar(paste("Go", ttC, "LongBeta.bin", sep=""))+1,                 nchar(BetaLongBuffFiles)) == paste("Go", ttC, "LongBeta.bin", sep="")]                )              }            }            ATFList[[jj]] <- AT;          }        } else {          ATFList[[1]] <- BetaLongBuffFiles;        }        LengthBetaLongBuff  = 0;        if (is.null(.self$CpBuffLongCI) || length(.self$CpBuffLongCI) <= 0 ||          !is.integer(.self$CpBuffLongCI) || .self$CpBuffLongCI[1] <= 0) {          LengthBetaLongBuff = 10 * (.self$p+1);        } else {          LengthBetaLongBuff = .self$CpBuffLongCI[1] * (.self$p+1);        }        if (LengthBetaLongBuff <= 3*(.self$p + 1)) {          LengthBetaLongBuff <- 3 * (.self$p+1);        }        .self$.SubCodaLongList <- list();        if (length(ATFList) > 1) {          AIn <- (1:length(.self$ABayesSpikeCL$TemperatureList))[.self$ABayesSpikeCL$TemperatureList ==             min(.self$ABayesSpikeCL$TemperatureList)]          BetaLongBuffFiles <- ATFList[[AIn]];        } else {          BetaLongBuffFiles <- ATFList[[1]];        }        for (ii in 1:length(BetaLongBuffFiles)) {          NewCoda = NULL;          NewCoda = matrix(0, .self$MaxGibbsIters,            length(.self$SubSetCoords) );          try(rownames(NewCoda) <- 1:.self$MaxGibbsIters);          if (Verbose > 1) {            print(paste("  Going to GiveCoda SubSet for BetaLongBuffFiles[", ii, "] = ",              BetaLongBuffFiles[ii], sep="")); flush.console();          }           MyOA = NULL;           try(MyOA <- file(description = paste(BetaLongBuffFiles[ii], sep=""),             open = "rb", blocking = TRUE,            encoding = getOption("encoding"), raw = FALSE));          if (!is.null(.self$MBS)) {            try(.self$MBS$TotalR5OpenedFiles <- .self$MBS$TotalR5OpenedFiles+1);          }          OverPrinted <- 0;    ReadIn = 1;          while(!is.null(MyOA) && OverPrinted < .self$MaxGibbsIters && ReadIn > 0) {            MyF = NULL;            try(MyF <- readBin(MyOA, what="double", n = LengthBetaLongBuff));            ReadIn = length(MyF);            LLMyF = length(MyF) / (.self$p+1);            if (ReadIn <= 0) {              try(print(paste("    LoadInLong: Bad ReadIn On Recovery, File ii = ", ii, " LengthBetaLongBuff = ",               LengthBetaLongBuff, "\n",                "     and File ",                BetaLongBuffFiles[ii],                 "\n     and length .self$SubSetCoords is ",                length(.self$SubSetCoords), " we got a LLMyF = ", LLMyF,                " but ReadIn = ", ReadIn, sep=""))); flush.console();              OverPrinted = .self$MaxGibbsIters + 1;            } else if (LLMyF > 0) {              try(MyF <- t(matrix(as.numeric(MyF), .self$p+1, LLMyF)))              try(NewCoda[OverPrinted + 1:LLMyF,] <- MyF[,1+.self$SubSetCoords])              OverPrinted <- OverPrinted+LLMyF;            } else {              try(print(paste("    LoadInLong: On Recovery, File ii = ", ii, " LengthBetaLongBuff = ",               LengthBetaLongBuff, "\n",                "     and File ",                BetaLongBuffFiles[ii],                 "\n     and length .self$SubSetCoords is ",                length(.self$SubSetCoords), " we got a LLMyF = ", LLMyF,                " but ReadIn = ", ReadIn, sep=""))); flush.console();              OverPrinted = .self$MaxGibbsIters + 1;            }          }          try(colnames(NewCoda) <- paste("Beta:", .self$SubSetCoords, sep=""));          if (StartIter > 1 || EndIter < .self$MaxGibbsIters) {            NewCoda <-  NewCoda[StartIter:EndIter,]          }          try(NewCoda <- as.mcmc(NewCoda))          try(.self$.SubCodaLongList[[ii]] <- NewCoda)          try(close(MyOA));          if (!is.null(.self$MBS)) {            try(.self$MBS$TotalR5ClosedFiles <- .self$MBS$TotalR5ClosedFiles+1);          }        }        try(.self$.SubCodaLongList <- as.mcmc.list(.self$.SubCodaLongList));    }    try(.self$.SubCodaLongList <- as.mcmc.list(.self$.SubCodaLongList));        try(.self$ABayesSpikeCL$SubCodaLongList <- .self$.SubCodaLongList);        return(.self$.SubCodaLongList);});BayesSpikeR5$methods(  GenerateMIP = function(DoShort = NULL, ...) {    if (is.null(DoShort)) {    DoShort <- as.logical(.self$MBS$DoShortMIP);  }  if (.self$p >= 2000 && DoShort == TRUE) {    print(paste("BayesSpikeR5.r::GenerateMIP(p=", .self$p, ") and DoShort == TRUE, if you want coda based please take set DoShort Flag = FALSE",      sep=""));    try(.self$.MIP <- .self$MBS$ProbVector);    try(.self$MBS$MIP <- .self$.MIP);    return(.self$MBS$ProbVector)  }     try(library(coda));     if ((!is.null(.self$MBS$OldCodaNames) &&       !is.null(.self$MBS$CodaList)) ||       .self$SaveDir %in% c("NoSave", "NOSAVE", "nosave", "Nosave")) {       MyHRT <- (1:length(.self$MBS$OldCodaNames))[         substr(.self$MBS$OldCodaNames, 1, nchar("ProbFixed")) ==           "ProbFixed" |         substr(.self$MBS$OldCodaNames, 1, nchar("Prob")) ==           "Prob" |         substr(.self$MBS$OldCodaNames, 1, nchar("Probtau")) %in%          c("Probtau", "probtau", "ProbTau")       ]       if (length(MyHRT) == 0) {         try(.self$.MIP <- .self$MBS$ProbVector);         try(.self$MBS$MIP <- .self$.MIP);         return(.self$MBS$ProbVector)       }       Burn <- .self$MBS$burnin;       if (Burn <= 0) { Burn = 1; }       CNTF <- rep(0, length(MyHRT));       RNTF <- rep(0, length(MyHRT));       for (jj in 1:length(.self$MBS$CodaList)) {         PMT <- .self$MBS$CodaList[[jj]][           Burn:NROW(.self$MBS$CodaList[[jj]]),MyHRT]         ART <- matrix(exp(PMT)/            (exp(PMT) + 1),            NROW(PMT), NCOL(PMT));          ART[PMT > 15] = 1.0;          ART[PMT < -10] = exp(PMT[PMT < -10]);          RNTF <- RNTF + colSums(ART);          CNTF <- CNTF + NROW(ART);       }       .self$.MIP <- RNTF/CNTF       try(names(.self$.MIP) <- .self$MBS$OldCodaNames[MyHRT]);       if (!is.null(.self$MBS$OtherNameCodaList)) {         try(names(.self$.MIP) <- .self$MBS$OtherNameCodaList[MyHRT]);       }       try(.self$MBS$MIP <- .self$.MIP);       return(.self$.MIP);     }     if (is.null(.self$MBS$SaveDir) || .self$MBS$SaveDir %in% c("NoSave", "NOSAVE", "nosave") ||       .self$SaveDir %in% c("NoSave", "NOSAVE", "nosave")) {        try(.self$.MIP <- .self$MBS$ProbVector);        if (length(.self$.MIP) <= 0) {          print("GenerateMIP: There Was NoSave Dir but Also no RunProbVector!"); flush.console();        }        try(.self$MBS$MIP <- .self$.MIP);        return(.self$.MIP);     }     .self$GenerateProbCodaList(DoLogitPostProb = FALSE);     if (length(.self$ProbCodaList) == 0 || length(.self$ProbCodaList[[1]]) <= 1 ||       NCOL(.self$ProbCodaList[[1]]) <= 0) {       print("GenerateMIP: We tried to do this with CodaList but must do through ProbVector");       flush.console();       try(.self$.MIP <- .self$MBS$ProbVector);       return(.self$MBS$ProbVector)     }     ProbList <- .self$ProbCodaList;     if (is.null(ProbList) || length(ProbList) <= 0 ||        NCOL(ProbList[[1]]) == 0) {       print(paste("-- GenerateMIP: Error .self$ProbCodaList is not of any size. ", sep=""));       flush.console();        }     CNTF <- rep(0, NCOL(ProbList[[1]]));     RNTF <- rep(0, NCOL(ProbList[[1]]));     Burn <- 1;     try(Burn <- .self$MBS$burnin);     if (Burn <= 0) { Burn = 1;}     if (is.list(ProbList[[1]])) {        iL <- length(ProbList);        ##print(paste("Hey ProbList has more lists, it is length ", iL, " which the last is length ",        ##  length(ProbList[[iL]]), " and Burn is ", Burn, sep="")); flush.console();        PLL <- ProbList[[iL]];        for (jj in 1:length(PLL)) {          MyRows <- NROW(PLL[[jj]]);          if (MyRows <= 0) {                      }  else {            RNTF <- RNTF + colSums(PLL[[jj]][Burn:NROW(PLL[[jj]]),]);            CNTF <- CNTF + (NROW(PLL[[jj]]) - Burn+1);          }        }     } else {       for (jj in 1:length(ProbList)) {         RNTF <- RNTF + colSums(ProbList[[jj]][Burn:NROW(ProbList[[jj]]),]);         CNTF <- CNTF + (NROW(ProbList[[jj]]) - Burn+1);       }     }     .self$.MIP <- RNTF/CNTF     if (!is.null(.self$MBS$OldCodaNames)) {       MyHRT <- (1:length(.self$MBS$OldCodaNames))[         substr(.self$MBS$OldCodaNames, 1, nchar("ProbFixed")) ==           "ProbFixed" |         substr(.self$MBS$OldCodaNames, 1, nchar("Prob")) ==           "Prob" |         substr(.self$MBS$OldCodaNames, 1, nchar("Probtau")) %in%          c("Probtau", "probtau", "ProbTau")       ];       try(names(.self$.MIP) <- .self$MBS$OldCodaNames[MyHRT]);       if (!is.null(.self$MBS$OtherNameCodaList)) {         try(names(.self$.MIP) <- .self$MBS$OtherNameCodaList[MyHRT]);       }     }     try(.self$MBS$MIP <- .self$.MIP);     return(.self$.MIP);  });BayesSpikeR5$methods(  GenerateProbCodaList = function(SubCodaList = NULL, DoLogitPostProb = NULL) {    if (is.null(DoLogitPostProb) || !is.logical(DoLogitPostProb) ) {      aDoLogitPostProb <- .self$DoLogitPostProb;    } else {      aDoLogitPostProb = DoLogitPostProb    }    if (is.null(aDoLogitPostProb)) {      aDoLogitPostProb = FALSE;    }    if (!is.logical(aDoLogitPostProb)) {      aDoLogitPostProb = FALSE;    }    aMBS = .self$ABayesSpikeCL;    if (is.null(aMBS)) {      print("Error! GenerateProbCodaList: No MBS!");      return(-1);    }    if (length(.self$DoRecord) > 0 &&      sum(.self$DoRecord[6:7]) > 0 &&      length(aMBS$CodaList) > 0 && sum(abs(aMBS$CodaList[[1]])) > 0) {      IS = 1; IE = -1;      if (.self$DoRecord[1] == 1) {        if (length(aMBS$OnTau) <= 0) {           IS <- IS + aMBS$p;        } else {          ##IS <- IS + aMBS$CFirstRandom;          IS <- IS + aMBS$p;        }      }      if (.self$DoRecord[2] > 0) {        IS <- IS + length(aMBS$OnTau);      }      if (.self$DoRecord[3] > 0) {        IS <- IS + length(aMBS$OnSigma);      }      if (.self$DoRecord[4] > 0) {        IS <- IS + length(aMBS$OnPiA);      }      if (.self$DoRecord[5] > 0) {        IS <- IS + length(aMBS$tauFixed);      }      IE = IS-1;      if (.self$DoRecord[6] > 0) {        if (length(aMBS$OnTau) <= 0) {           IE <- IE + aMBS$p;        } else {          IE <- IE + aMBS$CFirstRandom;        }      }      if (.self$DoRecord[7] > 0) {        IE <- IE + length(aMBS$OnTau);      }      MyR = list();      for (ii in 1:length(aMBS$CodaList)) {        ##MyP = (1:NCOL(aMBS$CodaList[[ii]]))[        ##  substr(colnames(aMBS$CodaList[[ii]]),1,        ##    nchar("Prob")) %in% c("Prob", "prob")];        FPF = aMBS$CodaList[[ii]];        MyWantP = FPF[, IS:IE];         if (is.null(colnames(FPF))) {          if (aMBS$CFirstRandom > 0 && length(aMBS$sOnTau) > 0) {            if (is.null(names(aMBS$Beta)) || length(names(aMBS$Beta)) <= 0) {              NB = paste("Beta:", 1:length(aMBS$Beta), sep="");            } else {              NB = names(aMBS$Beta);            }            if (is.null(names(aMBS$OnTau)) || length(names(aMBS$OnTau)) <= 0) {              NT = paste("Tau:", 1:length(aMBS$OnTau), sep="");            } else {              NT = names(aMBS$Ontau);            }            if (.self$DoRecord[6] > 0  && .self$DoRecord[7] > 0) {              try(colnames(MyWantP) <-                 paste("Prob:", c(NB[1:aMBS$CFirstRandom], NT), sep=""));            } else if (.self$DoRecord[6] > 0) {              try(colnames(MyWantP) <-                 paste("Prob:", c(NB[1:aMBS$CFirstRandom]), sep=""));            } else if (.self$DoRecord[7] > 0) {              try(colnames(MyWantP) <- paste("Prob:", NT, sep=""));            }          } else if (aMBS$CFirstRandom == 0 && length(aMBS$sOnTau) > 0) {            if (is.null(names(aMBS$OnTau)) || length(names(aMBS$OnTau)) <= 0) {              NT = paste("Tau:", 1:length(aMBS$OnTau), sep="");            } else {              NT = names(aMBS$Ontau);              try(colnames(MyWantP) <- paste("Prob:", c(NT), sep=""));            }                    } else {             if (is.null(names(aMBS$Beta)) || length(names(aMBS$Beta)) <= 0) {              NB = paste("Beta:", 1:length(aMBS$Beta), sep="");            } else {              NB = names(aMBS$Beta);            }            try(colnames(MyWantP) <- paste("Prob:", NB, sep="") );                   }        } else {          try(colnames(MyWantP)  <- (colnames(FPF))[IS:IE]);        }        if (!exists("aDoLogitPostProb")) { aDoLogitPostProb = FALSE; }        if (aDoLogitPostProb == FALSE) {           NewWantP = matrix(0, NROW(MyWantP), NCOL(MyWantP));          NewWantP[MyWantP > -10 & MyWantP < 10] =             exp(MyWantP[MyWantP > -10 & MyWantP < 10])/            (1.0 + exp(MyWantP[MyWantP > -10 & MyWantP < 10]));          ##NewWantP = matrix(0, NROW(MyWantP), NCOL(MyWantP));          NewWantP[MyWantP <= -10] =             exp(MyWantP[MyWantP <= -10] );          NewWantP[MyWantP >= 10] = 1.0;          try(colnames(NewWantP) <- (colnames(aMBS$CodaList[[ii]]))[IS:IE]);        } else {          NewWantP <- MyWantP;        }                try(MyR[[ii]] <- as.mcmc(NewWantP));            }      try(MyR <- as.mcmc.list(MyR));      .self$.ProbCodaList <- MyR;      try(.self$MBS$ProbCodaList <- .self$.ProbCodaList);      .ProbCodaList <<- MyR;      return(.ProbCodaList);    } else{     PostBuffFiles <- NULL;     if (!is.null(.self$SaveDir) && !(.self$SaveDir %in% c("NoSave", "NOSAVE", "nosave"))) {       Dir = .self$SaveDir;       if (.self$Verbose > 1) {         print(paste("TBSR5:GenerateCodaProbList: We're going to pull files from SaveDir = ", Dir, sep=""));         try(print(paste("ListSaveFiles = (", paste(unlist(.self$ListSaveFiles), collapse=", "),           ")", sep=""))); flush.console();         flush.console();       }       MyNFiles = unlist(list.files(Dir));       if (length(MyNFiles) <= 0) {         print("ISSUEISSUEISSUEISSUEISSUEISSUEISSUEISSUEISSUEISSUEISSUEISSUEISSUE");         print("ISSUE| We looked for files listed in .self$SaveDir and we got");         print("ISSUE|  Zero Files in: ");         print(paste("ISSUE| \"", Dir, "\"", sep="")); flush.console();       }       MyNFiles <- MyNFiles[substr(MyNFiles, 1, nchar(.self$FileName)) ==          .self$FileName];       PostBuffFiles =   MyNFiles[        substr(MyNFiles, nchar(MyNFiles)-nchar("PostBuff.bin")+1,         nchar(MyNFiles)) == "PostBuff.bin"];       PostBuffFiles = paste(Dir, "//", PostBuffFiles, sep="")       if (length(PostBuffFiles) <= 0) {           print("ISSUEISSUEISSUEISSUEISSUEISSUEISSUEISSUEISSUEISSUE");           print(paste("ISSUE| We tried to taper down ", length(MyNFiles), " files in save dir"));           print(paste("ISSUE| But none of them had PostBuff.bin included!"));           eval(parse(text=SetGText("MyNFiles", "globalenv()", S=1)));           BadSaveDir <- Dir;           eval(parse(text=SetGText("BadSaveDir", "globalenv()", S=1)));       }      } else if (!is.null(.self$ListSaveFiles)) {        Dir = .self$SaveDir;        LSFiles = sort(unique(unlist(.self$ListSaveFiles)));        for (ii in 1:length(LSFiles)) {         if (substr(LSFiles[ii], 1, nchar(Dir)) == Dir) {          LSFiles[ii] = substr(LSFiles[ii], nchar(Dir)+1, nchar(LSFiles[ii]));          AT = unlist(strsplit(LSFiles[ii], "/"))          LSFiles[ii] = AT[length(AT)]         }        }        try(PostBuffFiles <-  paste(LSFiles,           "PostBuff.bin", sep="") );       }      if (.self$ABayesSpikeCL$Verbose >= -1) {        print(paste("-- MIP: working well we have ", length(PostBuffFiles), " PostBuffFiles selected", sep=""));        print(paste("--- They are: "));        print(paste("--- ", (1:length(PostBuffFiles)), "\"", PostBuffFiles, "\"", sep=""));        try(eval(parse(text=SetGText("PostBuffFiles", "globalenv()", S=1))));        print("--- Go Get Them. ");        if (is.null(.self$ABayesSpikeCL$TemperatureList)) {          print("--- Note TemperatureList is null");        }  else if (length(.self$ABayesSpikeCL$TemperatureList) == 1) {          print("--- Note TemperatureList is length One");        }  else {          print(paste("--- Note TemperatureList is length ", length(.self$ABayesSpikeCL$TemperatureList), sep=""));        }        print("------------------------------------------------------"); flush.console();      }      .self$.ProbCodaList = NULL;      if (length(PostBuffFiles) > 0) {        ATFList <- list();        if (!is.null(.self$ABayesSpikeCL$TemperatureList) &&          length(.self$ABayesSpikeCL$TemperatureList) > 0) {          for (jj in 1:length(.self$ABayesSpikeCL$TemperatureList)) {            AT <- c();            for (ttC in 1:.self$NumChains) {              if (jj < length(.self$ABayesSpikeCL$TemperatureList)) {                AT <- c(AT,                  PostBuffFiles[                    substr(PostBuffFiles, nchar(PostBuffFiles) -                     nchar(paste("T",jj-1,"C", ttC, "PostBuff.bin", sep=""))+1,                    nchar(PostBuffFiles)) == paste("T",jj-1,"C", ttC, "PostBuff.bin", sep="")]                  )              } else {                 AT <- c(AT,                  PostBuffFiles[                    substr(PostBuffFiles, nchar(PostBuffFiles) -                     nchar(paste("Go",ttC, "PostBuff.bin", sep=""))+1,                    nchar(PostBuffFiles)) == paste("Go",ttC, "PostBuff.bin", sep="")]                  )              }            }            ATFList[[jj]] <- AT;          }        } else {          ATFList[[1]] <- PostBuffFiles;        }        eval(parse(text=SetGText("ATFList", "globalenv()", S=1)));        LengthPostBuff  = 0;        if (is.null(.self$sOnTau) || length(.self$sOnTau) <= 0) {          LengthPostBuff = .self$p;        } else {          LengthPostBuff = .self$FirstRandom-1 + length(.self$sOnTau);        }        .self$.ProbCodaList <- list();        for (jtt in 1:length(ATFList)) {          PostBuffFiles <- ATFList[[jtt]];          if (length(ATFList) > 1) {            .self$.ProbCodaList[[jtt]] <- list();          }          for (ii in 1:length(PostBuffFiles)) {          NewCoda = NULL;          if (Verbose >= 2) {            print(paste("  .self$DoProb = ", .self$.DoProb, ", Going to GiveCoda SubSet for PostBuffFiles[", ii, "] = ",              PostBuffFiles[ii], sep="")); flush.console();          }           MyOA = NULL;           try(MyOA <- file(description = paste(PostBuffFiles[ii], sep=""),             open = "rb", blocking = TRUE,            encoding = getOption("encoding"), raw = FALSE));          if (is.null(MyOA)) {            if (.self$ABayesSpikeCL$Verbose >= -1) {              print(paste("-- GenerateProbCodaList: MyOA: Error could not open ", PostBuffFiles[ii], sep=""));              flush.console();            }          } else {            if (!is.null(.self$MBS)) {              try(.self$ABayesSpikeCL$TotalR5OpenedFiles <- .self$ABayesSpikeCL$TotalR5OpenedFiles+1);            }            MyF = NULL;            try(MyF <- readBin(MyOA, what="double", n = LengthPostBuff * .self$MaxGibbsIters));            try(close(MyOA)); try(MyOA <- NULL);            if (!is.null(MyF) && length(MyF) >= LengthPostBuff) {              LLMyF = length(MyF) / LengthPostBuff;              if (.self$ABayesSpikeCL$Verbose >= -1) {                 print(paste("-- GenerateProbCodaList[ii=", ii, "]: Got MyF read of length ",                   length(MyF), " for LengthPostBuff=", LengthPostBuff, " and p is ", .self$ABayesSpikeCL$p, " and LLMyF is ", LLMyF[1], sep=""));                flush.console();              }              try(MyF <- t(matrix(as.numeric(MyF), LengthPostBuff, LLMyF)))            if (!is.null(.self$sOnTau) && length(.self$sOnTau) > 0) {             if (.self$FirstRandom > 1) {               try(colnames(MyF) <- c(names(.self$sBeta)[1:(.self$FirstRandom-1)],                 names(.self$sOnTau)) );             } else {               try(colnames(MyF) <- names(.self$sOnTau));             }            } else {             try(colnames(MyF) <- names(.self$sBeta));            }            if (!exists("aDoLogitPostProb")) { aDoLogitPostProb <- FALSE; }            if (aDoLogitPostProb == FALSE && !is.null(MyF) && NROW(MyF) > 0 && NCOL(MyF) > 0) {              MyF[is.na(MyF)] = -9999;              NewMyF = matrix(0, NROW(MyF), NCOL(MyF));              NewMyF[MyF >= 10] <- 1.0;              NewMyF[MyF <= -10] <- exp(MyF[MyF <= -10]);              NewMyF[MyF < 10 & MyF > -10] <- exp(MyF[MyF < 10 & MyF > -10])/               (1.0 + exp(MyF[MyF < 10 & MyF > -10]));              colnames(NewMyF) <- colnames(MyF);              NewMyF[MyF == -9999] = NA;              MyF <- NewMyF;              if (.self$ABayesSpikeCL$Verbose > -1) {                print(paste("-- GenerateProbCodaList: After NewMyF has dimension (",                   paste(dim(MyF), collapse=", ", sep=""), ")", sep="")); flush.console();              }            } else {            }            if (is.null(.self$SubSetCoords) || length(.self$SubSetCoords)) {              print("Get_ProbCodaList: Error: SubSetCoords is totally NULL: which might be good."); flush.console();            }            if (!is.null(.self$SubSetCoords) && length(.self$SubSetCoords) > 0) {              if (is.null(.self$sOnTau) || length(.self$sOnTau) <= 0) {                MyV = 1:.self$p;                MyV = MyV[MyV %in% .self$SubSetCoords];                try(MyF <- MyF[,MyV]);              } else {                KeepMyV = 1:(.self$FirstRandom -1);                KeepMyV = KeepMyV[KeepMyV %in% .self$SubSetCoords];                KeepMyV = c(KeepMyV, (.self$FirstRandom):(                  .self$FirstRandom + length(.self$sOnTau) -1));                try(MyF <- MyF[, KeepMyV]);              }            }            }            if (!is.null(MyF)) {              if (length(ATFList) == 1) {                if (.self$ABayesSpikeCL$Verbose >= -1) {                  print(paste("-- GenerateProbCodaList: okay to locate now and as.mcmc MyF is dim (",                    paste(dim(MyF), collapse=", ", sep=""), ")", sep="")); flush.console();                }                try(.self$.ProbCodaList[[length(.self$.ProbCodaList)+1]] <- as.mcmc(MyF));              } else {                if (.self$ABayesSpikeCL$Verbose >= -1) {                  print(paste("-- GenerateProbCodaList: jtt = ", jtt,                     " length now = ", length(.self$.ProbCodaList[[jtt]]), " okay to locate now and as.mcmc MyF is dim (",                    paste(dim(MyF), collapse=", ", sep=""), ")", sep="")); flush.console();                }                try(.self$.ProbCodaList[[jtt]][[length(.self$.ProbCodaList[[jtt]])+1]] <- as.mcmc(MyF));              }            }            if (!is.null(MyOA)) { try(close(MyOA));  }            if (!is.null(.self$MBS)) {              try(.self$ABayesSpikeCL$TotalR5ClosedFiles <- .self$ABayesSpikeCL$TotalR5ClosedFiles+1);            }          }        }          if (length(ATFList) == 1) {            try(.self$.ProbCodaList <- as.mcmc.list(.self$.ProbCodaList));          } else {            try(.self$.ProbCodaList[[jtt]] <- as.mcmc.list(.self$.ProbCodaList[[jtt]]));          }        }        if (!is.null(.self$ABayesSpikeCL)) {          try(.self$ABayesSpikeCL$PostProbCodaList <- .self$ProbCodaList);        }        if (length(.self$.ProbCodaList) <= 0) {          print("GetProbCodaList: There were no Valid Files"); flush.console();        }        return(.self$.ProbCodaList);      }    }    return(NULL);  });BayesSpikeR5$methods(  GenerateSubProbCodaList = function(SubCodaList = NULL, DoLogitPostProb = NULL) {    if (is.null(DoLogitPostProb) || !is.logical(DoLogitPostProb) ) {      aDoLogitPostProb <- .self$DoLogitPostProb;    } else {      aDoLogitPostProb = DoLogitPostProb    }    if (is.null(aDoLogitPostProb)) {      aDoLogitPostProb = FALSE;    }    if (!is.logical(aDoLogitPostProb)) {      aDoLogitPostProb = FALSE;    }    aMBS = .self$ABayesSpikeCL;    if (is.null(aMBS)) {      print("Error! GenerateProbCodaList: No MBS!");      return(-1);    }    if (.self$p < 5000 && length(.self$DoRecord) > 0 &&      sum(.self$DoRecord[6:7]) > 0 &&      length(aMBS$CodaList) > 0 && sum(abs(aMBS$CodaList[[1]])) > 0) {      IS = 1; IE = -1;      if (.self$DoRecord[1] == 1) {        if (length(aMBS$OnTau) <= 0) {           IS <- IS + aMBS$p;        } else {          ##IS <- IS + aMBS$CFirstRandom;          IS <- IS + aMBS$p;        }      }      if (.self$DoRecord[2] > 0) {        IS <- IS + length(aMBS$OnTau);      }      if (.self$DoRecord[3] > 0) {        IS <- IS + length(aMBS$OnSigma);      }      if (.self$DoRecord[4] > 0) {        IS <- IS + length(aMBS$OnPiA);      }      if (.self$DoRecord[5] > 0) {        IS <- IS + length(aMBS$tauFixed);      }      IE = IS-1;      if (.self$DoRecord[6] > 0) {        if (length(aMBS$OnTau) <= 0) {           IE <- IE + aMBS$p;        } else {          IE <- IE + aMBS$CFirstRandom;        }      }      if (.self$DoRecord[7] > 0) {        IE <- IE + length(aMBS$OnTau);      }      MyR = list();      for (ii in 1:length(aMBS$CodaList)) {        ##MyP = (1:NCOL(aMBS$CodaList[[ii]]))[        ##  substr(colnames(aMBS$CodaList[[ii]]),1,        ##    nchar("Prob")) %in% c("Prob", "prob")];        FPF = aMBS$CodaList[[ii]];        MyWantP = FPF[, IS:IE];         if (is.null(colnames(FPF))) {          if (aMBS$CFirstRandom > 0 && length(aMBS$sOnTau) > 0) {            if (is.null(names(aMBS$Beta)) || length(names(aMBS$Beta)) <= 0) {              NB = paste("Beta:", 1:length(aMBS$Beta), sep="");            } else {              NB = names(aMBS$Beta);            }            if (is.null(names(aMBS$OnTau)) || length(names(aMBS$OnTau)) <= 0) {              NT = paste("Tau:", 1:length(aMBS$OnTau), sep="");            } else {              NT = names(aMBS$Ontau);            }            if (.self$DoRecord[6] > 0  && .self$DoRecord[7] > 0) {              try(colnames(MyWantP) <-                 paste("Prob:", c(NB[1:aMBS$CFirstRandom], NT), sep=""));            } else if (.self$DoRecord[6] > 0) {              try(colnames(MyWantP) <-                 paste("Prob:", c(NB[1:aMBS$CFirstRandom]), sep=""));            } else if (.self$DoRecord[7] > 0) {              try(colnames(MyWantP) <- paste("Prob:", NT, sep=""));            }          } else if (aMBS$CFirstRandom == 0 && length(aMBS$sOnTau) > 0) {            if (is.null(names(aMBS$OnTau)) || length(names(aMBS$OnTau)) <= 0) {              NT = paste("Tau:", 1:length(aMBS$OnTau), sep="");            } else {              NT = names(aMBS$Ontau);              try(colnames(MyWantP) <- paste("Prob:", c(NT), sep=""));            }                    } else {             if (is.null(names(aMBS$Beta)) || length(names(aMBS$Beta)) <= 0) {              NB = paste("Beta:", 1:length(aMBS$Beta), sep="");            } else {              NB = names(aMBS$Beta);            }            try(colnames(MyWantP) <- paste("Prob:", NB, sep="") );                   }        } else {          try(colnames(MyWantP)  <- (colnames(FPF))[IS:IE]);        }        if (!exists("aDoLogitPostProb")) { aDoLogitPostProb = FALSE; }        if (aDoLogitPostProb == FALSE) {           NewWantP = matrix(0, NROW(MyWantP), NCOL(MyWantP));          NewWantP[MyWantP > -10 & MyWantP < 10] =             exp(MyWantP[MyWantP > -10 & MyWantP < 10])/            (1.0 + exp(MyWantP[MyWantP > -10 & MyWantP < 10]));          ##NewWantP = matrix(0, NROW(MyWantP), NCOL(MyWantP));          NewWantP[MyWantP <= -10] =             exp(MyWantP[MyWantP <= -10] );          NewWantP[MyWantP >= 10] = 1.0;          try(colnames(NewWantP) <- (colnames(aMBS$CodaList[[ii]]))[IS:IE]);        } else {          NewWantP <- MyWantP;        }        if (!is.null(.self$SubSetCoords) && length(.self$SubSetCoords) >= 5) {            NewWantP <- NewWantP[,.self$SubSetCoords];        }          try(MyR[[ii]] <- as.mcmc(NewWantP));            }      try(MyR <- as.mcmc.list(MyR));      .self$.ProbCodaList <- MyR;      try(.self$MBS$ProbCodaList <- .self$.ProbCodaList);      .ProbCodaList <<- MyR;      return(.ProbCodaList);    } else{     PostBuffFiles <- NULL;     if (!is.null(.self$SaveDir) && !(.self$SaveDir %in% c("NoSave", "NOSAVE", "nosave"))) {       Dir = .self$SaveDir;       if (.self$Verbose > 1) {         print(paste("TBSR5:GenerateCodaProbList: We're going to pull files from SaveDir = ", Dir, sep=""));         try(print(paste("ListSaveFiles = (", paste(unlist(.self$ListSaveFiles), collapse=", "),           ")", sep=""))); flush.console();         flush.console();       }       MyNFiles = unlist(list.files(Dir));       MyNFiles <- MyNFiles[substr(MyNFiles, 1, nchar(.self$FileName)) ==          .self$FileName];       PostBuffFiles =   MyNFiles[        substr(MyNFiles, nchar(MyNFiles)-nchar("PostBuff.bin")+1,         nchar(MyNFiles)) == "PostBuff.bin"];       PostBuffFiles = paste(Dir, "//", PostBuffFiles, sep="")      } else if (!is.null(.self$ListSaveFiles)) {        Dir = .self$SaveDir;        LSFiles = sort(unique(unlist(.self$ListSaveFiles)));        for (ii in 1:length(LSFiles)) {         if (substr(LSFiles[ii], 1, nchar(Dir)) == Dir) {          LSFiles[ii] = substr(LSFiles[ii], nchar(Dir)+1, nchar(LSFiles[ii]));          AT = unlist(strsplit(LSFiles[ii], "/"))          LSFiles[ii] = AT[length(AT)]         }        }        try(PostBuffFiles <-  paste(LSFiles,           "PostBuff.bin", sep="") );       }      .self$.ProbCodaList = NULL;      if (length(PostBuffFiles) > 0) {        ATFList <- list();        if (!is.null(.self$ABayesSpikeCL$TemperatureList) &&          length(.self$ABayesSpikeCL$TemperatureList) > 0) {          for (jj in 1:length(.self$ABayesSpikeCL$TemperatureList)) {            AT <- c();            for (ttC in 1:.self$NumChains) {              if (jj < length(.self$ABayesSpikeCL$TemperatureList))  {               AT <- c(AT,                  PostBuffFiles[                    substr(PostBuffFiles, nchar(PostBuffFiles) -                     nchar(paste("T",jj-1,"C", ttC, "PostBuff.bin", sep=""))+1,                    nchar(PostBuffFiles)) == paste("T",jj-1,"C", ttC, "PostBuff.bin", sep="")]                  )              } else {               AT <- c(AT,                  PostBuffFiles[                    substr(PostBuffFiles, nchar(PostBuffFiles) -                     nchar(paste("Go", ttC, "PostBuff.bin", sep=""))+1,                    nchar(PostBuffFiles)) == paste("Go", ttC, "PostBuff.bin", sep="")]                  )                              }            }            ATFList[[jj]] <- AT;          }        } else {          ATFList[[1]] <- PostBuffFiles;        }        LengthPostBuff  = 0;        if (is.null(.self$sOnTau) || length(.self$sOnTau) <= 0) {          LengthPostBuff = .self$p;        } else {          LengthPostBuff = .self$FirstRandom-1 + length(.self$sOnTau);        }        .self$.ProbCodaList <- list();        for (jtt in 1:length(ATFList)) {          PostBuffFiles <- ATFList[[jtt]];          if (length(ATFList) > 1) {            .self$.ProbCodaList[[jtt]] <- list();          }        for (ii in 1:length(PostBuffFiles)) {          NewCoda = NULL;          if (Verbose >= 2) {            print(paste("  .self$DoProb = ", .self$.DoProb, ", Going to GiveCoda SubSet for PostBuffFiles[", ii, "] = ",              PostBuffFiles[ii], sep="")); flush.console();          }           MyOA = NULL;           if (.self$p <= 2000) {          try(MyOA <- file(description = paste(PostBuffFiles[ii], sep=""),             open = "rb", blocking = TRUE,            encoding = getOption("encoding"), raw = FALSE));          if (is.null(MyOA)) {          } else {            if (!is.null(.self$MBS)) {              try(.self$MBS$TotalR5OpenedFiles <- .self$MBS$TotalR5OpenedFiles+1);            }            MyF = NULL;            try(MyF <- readBin(MyOA, what="double", n = LengthPostBuff * .self$MaxGibbsIters));            if (!is.null(MyF) && length(MyF) >= LengthPostBuff) {            LLMyF = length(MyF) / LengthPostBuff;            try(MyF <- t(matrix(as.numeric(MyF), LengthPostBuff, LLMyF)))            if (!is.null(.self$sOnTau) && length(.self$sOnTau) > 0) {             if (.self$FirstRandom > 1) {               try(colnames(MyF) <- c(names(.self$sBeta)[1:(.self$FirstRandom-1)],                 names(.self$sOnTau)) );             } else {               try(colnames(MyF) <- names(.self$sOnTau));             }            } else {             try(colnames(MyF) <- names(.self$sBeta));            }            if (aDoLogitPostProb == FALSE && !is.null(MyF) && NROW(MyF) > 0 && NCOL(MyF) > 0) {              MyF[is.na(MyF)] = -9999;              NewMyF = matrix(0, NROW(MyF), NCOL(MyF));              NewMyF[MyF >= 10] <- 1.0;              NewMyF[MyF <= -10] <- exp(MyF[MyF <= -10]);              NewMyF[MyF < 10 & MyF > -10] <- exp(MyF[MyF < 10 & MyF > -10])/               (1.0 + exp(MyF[MyF < 10 & MyF > -10]));              colnames(NewMyF) <- colnames(MyF);              NewMyF[MyF == -9999] = NA;              MyF <- NewMyF;            } else {            }            if (!is.null(.self$SubSetCoords) && length(.self$SubSetCoords) > 0) {              if (is.null(.self$sOnTau) || length(.self$sOnTau) <= 0) {                MyV = 1:.self$p;                MyV = MyV[MyV %in% .self$SubSetCoords];                try(MyF <- MyF[,MyV]);              } else {                KeepMyV = 1:(.self$FirstRandom -1);                KeepMyV = KeepMyV[KeepMyV %in% .self$SubSetCoords];                KeepMyV = c(KeepMyV, (.self$FirstRandom):(                  .self$FirstRandom + length(.self$sOnTau) -1));                try(MyF <- MyF[, KeepMyV]);              }            }            }            if (!is.null(MyF)) {              if (length(ATFList) == 1) {                try(.self$.ProbCodaList[[length(.self$.ProbCodaList)+1]] <- as.mcmc(MyF));              } else {                try(.self$.ProbCodaList[[jtt]][[length(.self$.ProbCodaList)+1]] <- as.mcmc(MyF));              }            }            try(close(MyOA));            if (!is.null(.self$MBS)) {              try(.self$MBS$TotalR5ClosedFiles <- .self$MBS$TotalR5ClosedFiles+1);            }          }        }  else {          try(setwd(.self$SaveDir));          try(MyOA <- file(description = paste(PostBuffFiles[ii], sep=""),             open = "rb", blocking = TRUE,            encoding = getOption("encoding"), raw = FALSE));          if (is.null(MyOA)) {          } else {            if (!is.null(.self$MBS)) {              try(.self$MBS$TotalR5OpenedFiles <- .self$MBS$TotalR5OpenedFiles+1);            }            MyF = NULL;            MaxILoad = 10000000;  ItersAtATime <- max(c(10, ceiling(MaxILoad / .self$p)));            ATLoad <- 0;            goSubProbCoda <- matrix(0, .self$MaxGibbsIters, length(.self$SubSetCoords));            colnames(goSubProbCoda) <- .self$SubSetCoords;            AGO <- 0;            while(ATLoad < .self$MaxGibbsIters) {             if (AGO  >= 20) {               print(paste("ATLoad is ", ATLoad, " of",                .self$MaxGibbsIters, sep="")); flush.console();               AGO <- 0;             } else {                AGO <- AGO+1;             }            try(MyF <- readBin(MyOA, what="double", n = LengthPostBuff * ItersAtATime));            if (!is.null(MyF) && length(MyF) >= LengthPostBuff) {            LLMyF = length(MyF) / LengthPostBuff;            try(MyF <- t(matrix(as.numeric(MyF), LengthPostBuff, LLMyF)))            if (!is.null(.self$sOnTau) && length(.self$sOnTau) > 0) {             if (.self$FirstRandom > 1) {               try(colnames(MyF) <- c(names(.self$sBeta)[1:(.self$FirstRandom-1)],                 names(.self$sOnTau)) );             } else {               try(colnames(MyF) <- names(.self$sOnTau));             }            } else {             try(colnames(MyF) <- names(.self$sBeta));            }            if (aDoLogitPostProb == FALSE && !is.null(MyF) && NROW(MyF) > 0 && NCOL(MyF) > 0) {              MyF[is.na(MyF)] = -9999;              NewMyF = matrix(0, NROW(MyF), NCOL(MyF));              NewMyF[MyF >= 10] <- 1.0;              NewMyF[MyF <= -10] <- exp(MyF[MyF <= -10]);              NewMyF[MyF < 10 & MyF > -10] <- exp(MyF[MyF < 10 & MyF > -10])/               (1.0 + exp(MyF[MyF < 10 & MyF > -10]));              colnames(NewMyF) <- colnames(MyF);              NewMyF[MyF == -9999] = NA;              MyF <- NewMyF;            } else {            }            if (!is.null(.self$SubSetCoords) && length(.self$SubSetCoords) > 0) {              if (is.null(.self$sOnTau) || length(.self$sOnTau) <= 0) {                MyV = 1:.self$p;                MyV = MyV[MyV %in% .self$SubSetCoords];                try(MyF <- MyF[,MyV]);              } else {                KeepMyV = 1:(.self$FirstRandom -1);                KeepMyV = KeepMyV[KeepMyV %in% .self$SubSetCoords];                KeepMyV = c(KeepMyV, (.self$FirstRandom):(                  .self$FirstRandom + length(.self$sOnTau) -1));                try(MyF <- MyF[, KeepMyV]);              }            }            }            if (!is.null(MyF) && length(MyF) >= 0) {              if (length(.self$SubSetCoords) > 1) {                try(goSubProbCoda[ATLoad+1:NROW(MyF),] <- MyF);              } else if (length(.self$SubSetCoords) == 1) {                try(goSubProbCoda[ATLoad+1:length(MyF)] <- MyF);              }            }            ATLoad <- ATLoad + ItersAtATime;         }          if (is.null(.self$.SubProbCodaList) || !is.list(.self$.SubProbCodaList)) {            try(.self$.SubProbCodaList <- NULL)          }          if (!is.null(goSubProbCoda)) {              if (length(ATFList) == 1) {                try(.self$.SubProbCodaList[[length(.self$.SubProbCodaList)+1]] <- as.mcmc(goSubProbCoda));              } else {                try(.self$.SubProbCodaList[[jtt]][[length(.self$.SubProbCodaList)+1]] <- as.mcmc(goSubProbCoda));              }            }            try(close(MyOA));            if (!is.null(.self$MBS)) {              try(.self$MBS$TotalR5ClosedFiles <- .self$MBS$TotalR5ClosedFiles+1);            }          }        }          }          if (length(ATFList) == 1) {            try(.self$.SubProbCodaList <- as.mcmc.list(.self$.SubProbCodaList));          } else {            try(.self$.SubProbCodaList[[jtt]] <- as.mcmc.list(.self$.SubProbCodaList[[jtt]]));          }        }                if (length(.self$.SubProbCodaList) <= 0) {          print("GenerteSubProbCodaList: There were no Valid Files"); flush.console();        }        return(.self$.SubProbCodaList);      }    }    return(NULL);  });BayesSpikeR5$methods(  GenerateYCodaList = function(SubYList = -1) {    if (!exists("SubYList")) {       try(eval(parse(text=SetGEqualsText("SubYList", "vector(\"integer\",0)", S=1, envir="environment()"))));     }    if (is.null(SubYList) || length(SubYList) == 0) {  .self$SubYList <- vector("integer",0); }       aMBS = .self$ABayesSpikeCL;    if (is.null(aMBS)) {      print("Error! GenerateYCodaList: No MBS!");      return(-1);    }    YBuffFiles <- NULL;    if (!is.null(.self$SaveDir)) {      Dir = .self$SaveDir;      if (.self$Verbose > 1) {        print(paste("TBSR5:GenerateYCodaList: We're going to pull files from SaveDir = ", Dir, sep=""));          try(print(paste("ListSaveFiles = (", paste(unlist(.self$ListSaveFiles), collapse=", "),           ")", sep=""))); flush.console();         flush.console();      }      MyNFiles = unlist(list.files(Dir));      MyNFiles <- MyNFiles[substr(MyNFiles, 1, nchar(.self$FileName)) ==         .self$FileName];      YBuffFiles =   MyNFiles[        substr(MyNFiles, nchar(MyNFiles)-nchar("YBuff.bin")+1,         nchar(MyNFiles)) == "YBuff.bin"];      if (length(YBuffFiles) <= 0) {        print("GenerateYCodaList: No YBuffFiles in Directory!");        return(NULL);      }      YBuffFiles = paste(Dir, "//", YBuffFiles, sep="")    } else if (!is.null(.self$ListSaveFiles)) {      Dir = .self$SaveDir;      LSFiles = unlist(.self$ListSaveFiles);      for (ii in 1:length(LSFiles)) {        if (substr(LSFiles[ii], 1, nchar(Dir)) == Dir) {          LSFiles[ii] = substr(LSFiles[ii], nchar(Dir)+1, nchar(LSFiles[ii]));          AT = unlist(strsplit(LSFiles[ii], "/"))          LSFiles[ii] = AT[length(AT)]        }      }      try(YBuffFiles <-  paste(.self$SaveDir, "//", LSFiles,        "YBuff.bin", sep="") );       MyListFiles = unlist(list.files(.self$SaveDir));      YBuffFiles = YBuffFiles[YBuffFiles %in% MyListFiles];      if (length(YBuffFiles) <= 0) {        print("GenerateYCodaList: No YBuffFiles in Directory!");        return(NULL);      }    }    .self$.YCodaList = NULL;    if (length(YBuffFiles) > 0) {        ATFList <- list();        if (!is.null(.self$ABayesSpikeCL$TemperatureList) &&          length(.self$ABayesSpikeCL$TemperatureList) > 0) {          for (jj in 1:length(.self$ABayesSpikeCL$TemperatureList)) {            AT <- c();            for (ttC in 1:.self$NumChains) {              AT <- c(AT,                YBuffFiles[             substr(YBuffFiles, nchar(YBuffFiles) -                nchar(paste("T",jj-1,"C", ttC, "YBuff.bin", sep=""))+1,               nchar(YBuffFiles)) == paste("T",jj-1,"C", ttC, "YBuff.bin", sep="")]              )            }            ATFList[[jj]] <- AT;          }        } else {          ATFList[[1]] <- YBuffFiles;        }      .self$.YCodaList <- list();      for (jtt in 1:length(ATFList)) {        if (length(ATFList) > 1) {           .self$.YCodaList[[jtt]] <- list();        }        YBuffFiles <- ATFList[[jtt]]      for (ii in 1:length(YBuffFiles)) {        NewCoda = NULL;        if (Verbose > 1) {          print(paste("  Going to GiveCoda SubSet for YBuffFiles[", ii, "] = ",            YBuffFiles[ii], sep="")); flush.console();        }         MyOA = NULL;         try(MyOA <- file(description = paste(YBuffFiles[ii], sep=""),           open = "rb", blocking = TRUE,          encoding = getOption("encoding"), raw = FALSE));        if (is.null(MyOA)) {        } else {          if (!is.null(.self$MBS)) {            try(.self$MBS$TotalR5OpenedFiles <- .self$MBS$TotalR5OpenedFiles+1);          }          MyF = NULL;          try(MyF <- readBin(MyOA, what="double", n = .self$n * .self$MaxGibbsIters));          LLMyF = length(MyF) / .self$n;          try(MyF <- t(matrix(as.numeric(MyF), .self$n, LLMyF)));          try(colnames(MyF) <- paste("Y:", 1:.self$n, sep=""));          if (!is.null(.self$SubYList) && length(.self$SubYList) > 0) {            MyV = 1:.self$n;            try(MyF <- MyF[,MyV]);          }          if (!is.null(MyF)) {            if (length(ATFList) == 1) {              try(.self$.YCodaList[[length(.self$.YCodaList)+1]] <- as.mcmc(MyF));            } else {              try(.self$.YCodaList[[jtt]][[length(.self$.YCodaList)+1]] <- as.mcmc(MyF));            }          }            try(close(MyOA));           if (!is.null(.self$MBS)) {             try(.self$MBS$TotalR5ClosedFiles <- .self$MBS$TotalR5ClosedFiles+1);           }          }        }        if (length(ATFList) > 1) {          try(.self.YCodaList[[jtt]] <- as.mcmc.list(.self$.YCodaList[[jtt]]));        }        }        if (length(ATFList) == 1) {          try(.self$.YCodaList <- as.mcmc.list(.self$.YCodaList));        }        if (!is.null(.self$ABayesSpikeCL)) {          try(.self$ABayesSpikeCL$YCodaList <- .self$YCodaList);        }        return(.self$.YCodaList);      }      return(NULL);    });BayesSpikeR5$methods(  GenerateWeightCodaList = function(SubYList = -1) {        if (!exists("SubYList")) {       try(eval(parse(text=SetGEqualsText("SubYList", "vector(\"integer\",0)", S=1, envir="environment()"))));     }    if (is.null(SubYList) || length(SubYList) == 0) {  .self$SubYList <- vector("integer",0); }       aMBS = .self$ABayesSpikeCL;    if (is.null(aMBS)) {      print("Error! GenerateWeightCodaList: No MBS!");      return(-1);    }    WeightBuffFiles <- NULL;    if (!is.null(.self$SaveDir)) {      Dir = .self$SaveDir;      if (.self$Verbose > 1) {        print(paste("TBSR5:GenerateWeightCodaList: We're going to pull files from SaveDir = ", Dir, sep=""));          try(print(paste("ListSaveFiles = (", paste(unlist(.self$ListSaveFiles), collapse=", "),           ")", sep=""))); flush.console();         flush.console();      }      MyNFiles = unlist(list.files(Dir));      MyNFiles <- MyNFiles[substr(MyNFiles, 1, nchar(.self$FileName)) ==         .self$FileName];      WeightBuffFiles =   MyNFiles[        substr(MyNFiles, nchar(MyNFiles)-nchar("WBuff.bin")+1,         nchar(MyNFiles)) == "WBuff.bin"];      if (length(WeightBuffFiles) <= 0) {        print("GenerateWeightCodaList: Error, WeightBuffFiles has zero length!");        return(NULL);      }      WeightBuffFiles = paste(Dir, "//", WeightBuffFiles, sep="");    } else if (!is.null(.self$ListSaveFiles)) {      Dir = .self$SaveDir;      LSFiles = unlist(.self$ListSaveFiles);      for (ii in 1:length(LSFiles)) {        if (substr(LSFiles[ii], 1, nchar(Dir)) == Dir) {          LSFiles[ii] = substr(LSFiles[ii], nchar(Dir)+1, nchar(LSFiles[ii]));          AT = unlist(strsplit(LSFiles[ii], "/"))          LSFiles[ii] = AT[length(AT)]        }      }      try(WeightBuffFiles <-  paste(.self$Savedir, "//", LSFiles,        "WBuff.bin", sep="") );      MyListFiles = unlist(list.files(.self$SaveDir));      WeightBuffFiles = WeightBuffFiles[WeightBuffFiles %in% MyListFiles];       if (length(WeightBuffFiles) <= 0) {        print("GenerateWeightCodaList: Error, WeightBuffFiles has zero length!");        return(NULL);      }    }    .self$.WeightCodaList = NULL;    if (length(WeightBuffFiles) > 0) {        ATFList <- list();        if (!is.null(.self$ABayesSpikeCL$TemperatureList) &&          length(.self$ABayesSpikeCL$TemperatureList) > 0) {          for (jj in 1:length(.self$ABayesSpikeCL$TemperatureList)) {            AT <- c();            for (ttC in 1:.self$NumChains) {              AT <- c(AT,                WeightBuffFiles[             substr(WeightBuffFiles, nchar(WeightBuffFiles) -                nchar(paste("T",jj-1,"C", ttC, "WBuff.bin", sep=""))+1,               nchar(WeightBuffFiles)) == paste("T",jj-1,"C", ttC, "WBuff.bin", sep="")]              )            }            ATFList[[jj]] <- AT;          }        } else {          ATFList[[1]] <- WeightBuffFiles;        }      .self$.WeightCodaList <- list();      for (jtt in 1:length(ATFList)) {        if (length(ATFList) > 1) {          .self$.WeightCodaList[[jtt]] <- list();        }        WeightBuffFiles <- ATFList[[jtt]];      for (ii in 1:length(WeightBuffFiles)) {        NewCoda = NULL;        if (Verbose > 1) {          print(paste("  Going to GiveCoda SubSet for WeightBuffFiles[", ii, "] = ",            WeightBuffFiles[ii], sep="")); flush.console();        }         MyOA = NULL;         try(MyOA <- file(description = paste(WeightBuffFiles[ii], sep=""),           open = "rb", blocking = TRUE,          encoding = getOption("encoding"), raw = FALSE));        if (is.null(MyOA)) {        } else {          if (!is.null(.self$MBS)) {            try(.self$MBS$TotalR5OpenedFiles <- .self$MBS$TotalR5OpenedFiles+1);          }          MyF = NULL;          try(MyF <- readBin(MyOA, what="double", n = .self$n * .self$MaxGibbsIters));          LLMyF = length(MyF) / .self$n;          try(MyF <- t(matrix(as.numeric(MyF), .self$n, LLMyF)));          try(colnames(MyF) <- paste("W:", 1:.self$n, sep=""));          if (!is.null(.self$SubYList) && length(.self$SubYList) > 0) {            MyV = 1:.self$n;            try(MyF <- MyF[,MyV]);          }          if (!is.null(MyF)) {            if (length(ATFList) == 1) {              try(.self$.WeightCodaList[[length(.self$.WeightCodaList)+1]] <- as.mcmc(MyF));            } else {              try(.self$.WeightCodaList[[jtt]][[length(.self$.WeightCodaList)+1]] <- as.mcmc(MyF));            }          }            try(close(MyOA));            if (!is.null(.self$MBS)) {              try(.self$MBS$TotalR5OpenedFiles <- .self$MBS$TotalR5OpenedFiles+1);            }          }        }        if (length(ATFList) ==1 ) {          try(.self$.WeightCodaList <- as.mcmc.list(.self$.WeightCodaList));        } else {          try(.self$.WeightCodaList[[jtt]] <- as.mcmc.list(.self$.WeightCodaList[[jtt]]));                }        }        if (!is.null(.self$ABayesSpikeCL)) {          try(.self$ABayesSpikeCL$WeightCodaList <- .self$WeightCodaList);        }        return(.self$.WeightCodaList);      }      return(NULL);    });BayesSpikeR5$methods(  GeneratePiACodaList = function() {        aMBS = .self$ABayesSpikeCL;    if (is.null(aMBS)) {      print("Error! GeneratePiACodaList: No MBS!");      return(-1);    }    PiABuffFiles <- NULL;    if (!is.null(.self$SaveDir)) {      Dir = .self$SaveDir;      if (.self$Verbose > 1) {        print(paste("TBSR5:GeneratePiACodaList: We're going to pull files from SaveDir = ", Dir, sep=""));          try(print(paste("ListSaveFiles = (", paste(unlist(.self$ListSaveFiles), collapse=", "),           ")", sep=""))); flush.console();         flush.console();      }      MyNFiles = unlist(list.files(Dir));      MyNFiles <- MyNFiles[substr(MyNFiles, 1, nchar(.self$FileName)) ==         .self$FileName];      PiABuffFiles =   MyNFiles[        substr(MyNFiles, nchar(MyNFiles)-nchar("PiABuff.bin")+1,         nchar(MyNFiles)) == "PiABuff.bin"];      if (length(PiABuffFiles) <= 0) {        print("GeneratePiACodaList: Error, PiABuffFiles has zero length!");        return(NULL);      }      PiABuffFiles = paste(Dir, "//", PiABuffFiles, sep="");    } else if (!is.null(.self$ListSaveFiles)) {      Dir = .self$SaveDir;      LSFiles = unlist(.self$ListSaveFiles);      for (ii in 1:length(LSFiles)) {        if (substr(LSFiles[ii], 1, nchar(Dir)) == Dir) {          LSFiles[ii] = substr(LSFiles[ii], nchar(Dir)+1, nchar(LSFiles[ii]));          AT = unlist(strsplit(LSFiles[ii], "/"))          LSFiles[ii] = AT[length(AT)]        }      }      try(PiABuffFiles <-  paste(.self$Savedir, "//", LSFiles,        "PiABuff.bin", sep="") );      MyListFiles = unlist(list.files(.self$SaveDir));      PiABuffFiles = PiABuffFiles[PiABuffFiles %in% MyListFiles];       if (length(PiABuffFiles) <= 0) {        print("GeneratePiACodaList: Error, PiABuffFiles has zero length!");        return(NULL);      }    }    .self$.PiACodaList = NULL;    if (length(PiABuffFiles) > 0) {         ATFList <- list();        if (!is.null(.self$ABayesSpikeCL$TemperatureList) &&          length(.self$ABayesSpikeCL$TemperatureList) > 0) {          for (jj in 1:length(.self$ABayesSpikeCL$TemperatureList)) {            AT <- c();            for (ttC in 1:.self$NumChains) {              AT <- c(AT,                PiABuffFiles[             substr(PiABuffFiles, nchar(PiABuffFiles) -                nchar(paste("T",jj-1,"C", ttC, "PiABuff.bin", sep=""))+1,               nchar(PiABuffFiles)) == paste("T",jj-1,"C", ttC, "PiABuff.bin", sep="")]              )            }            ATFList[[jj]] <- AT;          }        } else {          ATFList[[1]] <- PiABuffFiles;        }      .self$.PiACodaList <- list();      for (jtt in 1:length(ATFList)) {        if (length(ATFList) == 1) {          PiABuffFiles = ATFList[[1]];        } else {          .self$.PiACodaList[[jtt]] <- list();          PiABuffFiles = ATFList[[jtt]];        }      for (ii in 1:length(PiABuffFiles)) {        NewCoda = NULL;        if (Verbose > 1) {          print(paste("  Going to GiveCoda SubSet for PiABuffFiles[", ii, "] = ",            PiABuffFiles[ii], sep="")); flush.console();        }         MyOA = NULL;         try(MyOA <- file(description = paste(PiABuffFiles[ii], sep=""),           open = "rb", blocking = TRUE,          encoding = getOption("encoding"), raw = FALSE));        if (!is.null(.self$MBS)) {          try(.self$MBS$TotalR5OpenedFiles <- .self$MBS$TotalR5OpenedFiles+1);        }        AT1 <- readBin(MyOA, what="double", n=1);        if (abs(AT1-2.0) <= .001) {          if (length(aMBS$OnPiA) == 2) {            if (Verbose > 2) {              print("GeneratePiACodaList: Good length at start, 2.0");              flush.console();            }          } else {            print(paste("GeneratePiACodaList: Bad length at start,",              " PiA length 2, but AT1 = ", AT1, sep="")); flush.console();          }        } else if (abs(AT1-1.0) <= .001) {          if (length(aMBS$OnPiA) == 1) {            if (Verbose > 2) {              print("GeneratePiACodaList: Good length at start, 1.0");              flush.console();            }          } else {            print(paste("GeneratePiACodaList: Bad length at start,",              " PiA length 2, but AT1 = ", AT1, sep="")); flush.console();          }        } else {          print(paste("GeneratePiACodaList: Issue, start read is ", AT1,             sep="")); flush.console();        }        if (is.null(MyOA)) {        } else {          MyF = NULL;          if (length(aMBS$OnPiA) == 1) {            try(MyF <- readBin(MyOA, what="double", n = .self$MaxGibbsIters));          } else {            try(MyF <- readBin(MyOA, what="double", n = 2*.self$MaxGibbsIters));             try(LMF <- floor(length(MyF)/2));            try(MyF <- t(matrix(MyF[1:(LMF*2)],2,LMF)));                  }          if (length(ATFList) == 1) {            try(.self$.PiACodaList[[ii]] <- as.mcmc(MyF));              } else {            try(.self$.PiACodaList[[jtt]][[ii]] <- as.mcmc(MyF));              }          try(close(MyOA));          if (!is.null(.self$MBS)) {            try(.self$MBS$TotalR5ClosedFiles <- .self$MBS$TotalR5ClosedFiles+1);          }        }           }      if (length(ATFList) == 1) {        try(.self$.PiACodaList <- as.mcmc.list(.self$.PiACodaList));      } else {        try(.self$.PiACodaList[[jtt]] <- as.mcmc.list(.self$.PiACodaList[[jtt]]));            }      }      if (!is.null(.self$ABayesSpikeCL)) {        try(.self$ABayesSpikeCL$PiACodaList <- .self$PiACodaList);      }      return(.self$.PiACodaList);    }    return(NULL);  });BayesSpikeR5$methods(  GenerateTauCodaList = function(SubSetTau = -1, StartIter = 0, EndIter = -1) {  try(library(coda))  if (!exists("StartIter")) { StartIter = 0; }  if (StartIter < 0 || StartIter > .self$MaxGibbsIters) {    StartIter = 0;  }  if (!exists("EndIter")) { EndIter = -1; }  if (EndIter <= 0 || EndIter <= EndIter) {    EndIter = .self$MaxGibbsIters;  }    if (!is.null(SubSetTau) && length(SubSetTau) == 1 &&     SubSetTau == -1) {    } else {      .self$SubSetTau = round(SubSetTau[round(SubSetTau) > 0]);    }    CodaTauFiles <- NULL;  CodaTjjFiles <- NULL;    if (!is.null(.self$SaveDir)) {      Dir = .self$SaveDir;      if (.self$Verbose > 1) {        print(paste("TBSR5:GenerateTauCodaList: We're going to pull files from SaveDir = ", Dir, sep=""));          try(print(paste("ListSaveFiles = (", paste(unlist(.self$ListSaveFiles), collapse=", "),           ")", sep=""))); flush.console();         flush.console();      }      MyNFiles = unlist(list.files(Dir));      MyNFiles <- MyNFiles[substr(MyNFiles, 1, nchar(.self$FileName)) ==         .self$FileName];      CodaTauFiles =   MyNFiles[        substr(MyNFiles, nchar(MyNFiles)-nchar("dT.bin")+1,         nchar(MyNFiles)) == "dT.bin"];      CodaTjjFiles =   MyNFiles[        substr(MyNFiles, nchar(MyNFiles)-nchar("iT.bin")+1,         nchar(MyNFiles)) == "iT.bin"];      CodaTjjFiles = CodaTjjFiles[substr(CodaTjjFiles,         1, nchar(CodaTjjFiles)-nchar("iT.bin")) %in%        substr(CodaTauFiles,         1,nchar(CodaTauFiles)-nchar("dT.bin"))]      CodaTauFiles = CodaTauFiles[substr(CodaTauFiles,         1, nchar(CodaTauFiles)-nchar("dT.bin")) %in%        substr(CodaTjjFiles,  1,        nchar(CodaTjjFiles)-nchar("iT.bin"))]      if (length(CodaTauFiles) <= 0) {        print("GenerateTauCodaList: Error, CodaTauFiles has zero length!");        return(NULL);      }      if (length(CodaTjjFiles) <= 0) {        print("GenerateCodaTauList: Error, CodaTjj Files has zero Length!");      }      CodaTjjFiles <- sort(CodaTjjFiles);      MM <- match(        substr(CodaTjjFiles,         1, nchar(CodaTjjFiles)-nchar("iT.bin")),        substr(CodaTauFiles,         1, nchar(CodaTauFiles)-nchar("dT.bin"))         );      CodaTauFiles <- CodaTauFiles[MM]              CodaTauFiles = paste(Dir, "//", CodaTauFiles, sep="");      CodaTjjFiles = paste(Dir, "//", CodaTjjFiles, sep="");    } else if (!is.null(.self$ListSaveFiles)) {      Dir = .self$SaveDir;      LSFiles = unlist(.self$ListSaveFiles);      for (ii in 1:length(LSFiles)) {        if (substr(LSFiles[ii], 1, nchar(Dir)) == Dir) {          LSFiles[ii] = substr(LSFiles[ii], nchar(Dir)+1, nchar(LSFiles[ii]));          AT = unlist(strsplit(LSFiles[ii], "/"))          LSFiles[ii] = AT[length(AT)]        }      }      try(CodaTjjFiles <-  paste(.self$Savedir, "//", LSFiles,        "iT.bin", sep="") );      try(CodaTauFiles <-  paste(.self$Savedir, "//", LSFiles,        "dT.bin", sep="") );      MyListFiles = unlist(list.files(.self$SaveDir));      try(MyListFiles <- paste(.self$Savedir, "//", MyListFiles, sep=""));      CodaTjjFiles = CodaTjjFiles[CodaTjjFiles %in% MyListFiles];       CodaTauFiles = CodaTauFiles[CodaTauFiles %in% MyListFiles];       CodaTjjFiles = CodaTjjFiles[substr(CodaTjjFiles,         1, nchar(CodaTjjFiles)-nchar("iT.bin")) %in%        substr(CodaTauFiles,         1, nchar(CodaTauFiles)-nchar("dT.bin"))]      CodaTauFiles = CodaTauFiles[substr(CodaTauFiles,         1, nchar(CodaTauFiles)-nchar("dT.bin")) %in%        substr(CodaTjjFiles,         1, nchar(CodaTjjFiles)-nchar("iT.bin"))]      if (length(CodaTauFiles) <= 0) {        print("GenerateTauCodaList: Error, SigBuffFiles has zero length!");        return(NULL);      }      if (length(CodaTjjFiles) <= 0) {        print("GenerateTauCodaList: Error, CodaTjj Files has zero Length!");      }      CodaTjjFiles <- sort(CodaTjjFiles);      MM <- match(        substr(CodaTjjFiles,         1, nchar(CodaTjjFiles)-nchar("iT.bin")),        substr(CodaTauFiles,         1, nchar(CodaTauFiles)-nchar("dT.bin"))         );      CodaTauFiless <- CodaTauFiles[MM];    }    .self$.TauCodaList = NULL;      if (length(CodaTjjFiles) > 0) {      if (is.null(.self$SubSetTau) || length(.self$SubSetTau) <= 0) {        aSubSetTau <- 1:length(.self$sOnTau)      } else {        aSubSetTau <- .self$SubSetTau;      }      CodaTjjList <- list();      CodaTauList <- list();        if (!is.null(.self$ABayesSpikeCL$TemperatureList) &&          length(.self$ABayesSpikeCL$TemperatureList) > 0) {          for (jj in 1:length(.self$ABayesSpikeCL$TemperatureList)) {            AT <- c();            for (ttC in 1:.self$NumChains) {              AT <- c(AT,                CodaTjjFiles[             substr(CodaTjjFiles, nchar(CodaTjjFiles) -                nchar(paste("T",jj-1,"C", ttC, "iT.bin", sep=""))+1,               nchar(CodaTjjFiles)) == paste("T",jj-1,"C", ttC, "iT.bin", sep="")]              )            }            CodaTjjList[[jj]] <- AT;          }          for (jj in 1:length(.self$ABayesSpikeCL$TemperatureList)) {            AT <- c();            for (ttC in 1:.self$NumChains) {              AT <- c(AT,                CodaTauFiles[             substr(CodaTauFiles, nchar(CodaTauFiles) -                nchar(paste("T",jj-1,"C", ttC, "dT.bin", sep=""))+1,               nchar(CodaTauFiles)) == paste("T",jj-1,"C", ttC, "dT.bin", sep="")]              )            }            CodaTauList[[jj]] <- AT;          }        } else {          CodaTjjList[[1]] <- CodaTjjFiles;          CodaTauList[[1]] <- CodaTauFiles;        }      .self$.TauCodaList <- list();      for (jtt in 1:length(CodaTjjList)) {        if (length(CodaTjjList) == 1) {          CodaTjjFiles = CodaTjjList[[1]];          CodaTauFiles = CodaTauList[[1]];        } else {          .self$.TauCodaList[[jtt]] <- list();          CodaTjjFiles = CodaTjjList[[jtt]];          CodaTauFiles = CodaTauList[[jtt]];        }      for (ii in 1:length(CodaTjjFiles)) {        NewCoda = NULL;        if (Verbose > 1) {          print(paste("  Going to GiveCoda SubSet for TauBuffFiles[", ii, "] = ",            CodaTjjFiles[ii], sep="")); flush.console();        }         try(MyOut <- .Call("GiveCodaSubset", aSubSetTau-1, CodaTjjFiles[ii],  CodaTauFiles[ii],          StartIter, EndIter, .self$Verbose));        if (!is.null(MyOut)) {          try(colnames(MyOut) <- paste("tau:", aSubSetTau, sep=""));          if (length(CodaTjjList) == 1) {            try(.self$.TauCodaList[[ii]] <- as.mcmc(MyOut));          } else {            try(.self$.TauCodaList[[jtt]][[ii]] <- as.mcmc(MyOut));                    }        }      }      if (length(CodaTjjList) == 1) {        try(.self$.TauCodaList <- as.mcmc.list(.self$.TauCodaList));      } else {        try(.self$.TauCodaList[[jtt]] <- as.mcmc.list(.self$.TauCodaList[[jtt]]));            }      }      try(.self$ABayesSpikeCL$TauCodaList <- .self$.TauCodaList);      return(.self$.TauCodaList);    }    if (.self$Verbose >= -1) {      print("GenerateTauCodaList: Error, could not find any iles for TauCodaList");      flush.console();    }    return(NULL);  });BayesSpikeR5$methods(  GenerateSigmaQuantiles = function() {    try(library(coda))    if (is.null(.self$.SigmaCodaList) || length(.self$.SigmaCodaList) == 0) {      .self$GenerateSigmaCodaList();    }    if (is.null(.self$.SigmaCodaList) || length(.self$.SigmaCodaList) == 0) {      print("GetSigmaQuantiles Error, we tried to get a SigmaCodaList, could not retrieve!");      return(-1);    }    if (.self$ABayesSpikeCL$burnin > 0 &&      .self$ABayesSpikeCL$burnin < length(.self$.SigmaCodaList[[1]]) ) {      ALongSigmaVector = rep(0, length(.self$.SigmaCodaList) *        (length(.self$.SigmaCodaList[[1]]) - .self$ABayesSpikeCL$burnin+1) );      AOn <- 0;      for (ii in 1:length(.self$.SigmaCodaList)) {        ALongSigmaVector[AOn +           1:(length(.self$.SigmaCodaList[[1]])           - .self$ABayesSpikeCL$burnin+1)] <- .self$.SigmaCodaList[[ii]][          .self$ABayesSpikeCL$burnin:(length(.self$.SigmaCodaList[[ii]]))];        AOn <- AOn + (          length(.self$.SigmaCodaList[[1]]) - .self$ABayesSpikeCL$burnin+1);       }    } else {      ALongSigmaVector = rep(0, length(.self$.SigmaCodaList) *        (length(.self$.SigmaCodaList[[1]])) );      AOn <- 0;      for (ii in 1:length(.self$.SigmaCodaList)) {        ALongSigmaVector[AOn +           1:(length(.self$.SigmaCodaList[[1]]))] <- .self$.SigmaCodaList[[ii]][          1:(length(.self$.SigmaCodaList[[ii]]))];        AOn <- AOn + (          length(.self$.SigmaCodaList[[1]]));       }    }  try(library(coda));  try(.self$.SigmaSymmetricQuantiles <-     quantile(ALongSigmaVector, .self$.KeepPosteriorQuantiles));  try(names(.self$.SigmaSymmetricQuantiles) <-     paste(.self$.KeepPosteriorQuantiles * 100, "%", sep="") );   HPDNeeds <- .self$HPDQuantiles;  HPDGot <- c(); HPDN <- c();  if (.5 %in% .self$.KeepPosteriorQuantiles) {    HPDGot <- quantile(ALongSigmaVector, .5);    HPDN <- "50%";  }  try(ALongSigmaVector <- as.mcmc(ALongSigmaVector));  for (ii in 1:length(HPDNeeds)) {    try(ART <- BayesSpike:::StableHPDinterval(ALongSigmaVector, prob = HPDNeeds[ii]), silent=TRUE);    try(HPDGot <- c(HPDGot, ART[1:2]));    HPDN <- c(HPDN, paste( c((1-HPDNeeds[ii])/2, 1-(1-HPDNeeds[ii])/2) * 100,      "%", sep=""));  }  try(.self$.SigmaHPDQuantiles <- HPDGot);  try(names(.self$.SigmaHPDQuantiles) <- HPDN);  return;  });BayesSpikeR5$methods(  GenerateSigmaCodaList = function() {    try(library(coda));    aMBS = .self$ABayesSpikeCL;    if (is.null(aMBS)) {      print("Error! GenerateSigmaCodaList: No MBS!");      return(-1);    }    SigBuffFiles <- NULL;    if ( (!is.null(.self$SaveDir)           && .self$SaveDir %in% c("NoSave", "NOSAVE") ) ||      .self$DoSave == 0) {      if (is.null(aMBS$CodaList) || length(aMBS$CodaList) <= 0 ||        aMBS$DoRecord[4] == 0) {        print("TBSR5:GenerateSigmaCodaList: No Save to Hard-drive was conducted.  Check DoSave Flag");        flush.console();        return(NULL);       }      MySig <- (1:NCOL(aMBS$CodaList[[1]]))[colnames(aMBS$CodaList[[1]]) %in%        c("Sigma", "OnSigma", "sigma", "sigma:1", "Sigma:1", "onsigma")];      if (length(MySig) != 1) {        print("TBSR5:GeneratesigCodaList: Couldn't find sigma in coda list!");        flush.console();      }       NewList <- list();      for (ii in 1:length(aMBS$CodaList)) {        AVV <- aMBS$CodaList[[ii]][,MySig];        try(AVV <- as.mcmc(AVV));        try(NewList[[ii]] <- AVV );      }      try(NewList <- as.mcmc.list(NewList));      return(NewList);    }    if (!is.null(.self$SaveDir)) {      Dir = .self$SaveDir;      if (.self$Verbose > 1) {        print(paste("TBSR5:GenerateSigCodaList: We're going to pull files from SaveDir = ", Dir, sep=""));          try(print(paste("ListSaveFiles = (", paste(unlist(.self$ListSaveFiles), collapse=", "),           ")", sep=""))); flush.console();         flush.console();      }      MyNFiles = unlist(list.files(Dir));      MyNFiles <- MyNFiles[substr(MyNFiles, 1, nchar(.self$FileName)) ==         .self$FileName];      SigBuffFiles =   MyNFiles[        substr(MyNFiles, nchar(MyNFiles)-nchar("SigBuff.bin")+1,         nchar(MyNFiles)) == "SigBuff.bin"];      if (length(SigBuffFiles) <= 0) {        print("GenerateSigCodaList: Error, SigBuffFiles has zero length!");        return(NULL);      }      SigBuffFiles = paste(Dir, "//", SigBuffFiles, sep="");    } else if (!is.null(.self$ListSaveFiles)) {      Dir = .self$SaveDir;      LSFiles = unlist(.self$ListSaveFiles);      for (ii in 1:length(LSFiles)) {        if (substr(LSFiles[ii], 1, nchar(Dir)) == Dir) {          LSFiles[ii] = substr(LSFiles[ii], nchar(Dir)+1, nchar(LSFiles[ii]));          AT = unlist(strsplit(LSFiles[ii], "/"))          LSFiles[ii] = AT[length(AT)]        }      }      try(SigBuffFiles <-  paste(.self$Savedir, "//", LSFiles,        "SigBuff.bin", sep="") );      MyListFiles = unlist(list.files(.self$SaveDir));      SigBuffFiles = SigBuffFiles[SigBuffFiles %in% MyListFiles];       if (length(SigBuffFiles) <= 0) {        print("GenerateSigCodaList: Error, SigBuffFiles has zero length!");        return(NULL);      }    }    .self$.SigCodaList = NULL;    if (length(SigBuffFiles) > 0) {       ATFList <- list();        if (!is.null(.self$ABayesSpikeCL$TemperatureList) &&          length(.self$ABayesSpikeCL$TemperatureList) > 0) {          for (jj in 1:length(.self$ABayesSpikeCL$TemperatureList)) {            AT <- c();            for (ttC in 1:.self$NumChains) {              AT <- c(AT,                SigBuffFiles[             substr(SigBuffFiles, nchar(SigBuffFiles) -                nchar(paste("T",jj-1,"C", ttC, "SigBuff.bin", sep=""))+1,               nchar(SigBuffFiles)) == paste("T",jj-1,"C", ttC, "SigBuff.bin", sep="")]              )            }            ATFList[[jj]] <- AT;          }        } else {          ATFList[[1]] <- SigBuffFiles;        }      .self$.SigmaCodaList <- list();      for (jtt in 1:length(ATFList)) {        if (length(ATFList) == 1) {          SigBuffFiles = ATFList[[1]];        } else {          .self$.SigmaCodaList[[jtt]] <- list();          SigBuffFiles = ATFList[[jtt]];        }      for (ii in 1:length(SigBuffFiles)) {        NewCoda = NULL;          if (Verbose > 1) {          print(paste("  Going to GiveCoda SubSet for SigBuffFiles[", ii, "] = ",            SigBuffFiles[ii], sep="")); flush.console();          }           MyOA = NULL;           try(MyOA <- file(description = paste(SigBuffFiles[ii], sep=""),             open = "rb", blocking = TRUE,            encoding = getOption("encoding"), raw = FALSE));          if (is.null(MyOA)) {          } else {            if (!is.null(.self$MBS)) {             try(.self$MBS$TotalR5OpenedFiles <- .self$MBS$TotalR5OpenedFiles+1);            }            MyF = NULL;            try(MyF <- readBin(MyOA, what="double", n = .self$MaxGibbsIters));            if (length(ATFList) == 1) {              try(.self$.SigmaCodaList[[ii]] <- as.mcmc(MyF));             } else {              try(.self$.SigmaCodaList[[jtt]][[ii]] <- as.mcmc(MyF));                         }              try(close(MyOA));             if (!is.null(.self$MBS)) {              try(.self$MBS$TotalR5ClosedFiles <- .self$MBS$TotalR5ClosedFiles+1);            }          }              }      if (length(ATFList) == 1) {        try(.self$.SigmaCodaList <- as.mcmc.list(.self$.SigmaCodaList));      } else {        try(.self$.SigmaCodaList[[jtt]] <- as.mcmc.list(.self$.SigmaCodaList[[jtt]]));            }      }      if (!is.null(.self$ABayesSpikeCL)) {        try(.self$ABayesSpikeCL$SigmaCodaList <- .self$.SigmaCodaList);      }      return(.self$.SigmaCodaList);    }    return(NULL);  });BayesSpikeR5$methods(  GenerateAlterWeightCodaList = function() {    try(library(coda));    if (.self$Verbose > 3) {      print("AlterWeightCodaList Deriving."); flush.console();    }    aMBS = .self$ABayesSpikeCL;    if (is.null(aMBS)) {      print("Error! GenerateAlterWeightCodaList: No MBS!");      return(-1);    }    AlterWeightBuffFiles <- NULL;    if ( (!is.null(.self$SaveDir) && .self$SaveDir %in% c("NoSave", "NOSAVE")) ||      .self$DoSave == 0) {      print("TBSR5:GenerateAlterWeightCodaList: No Save to Hard-drive was conducted.  Check DoSave Flag");      flush.console();      return(NULL);      }    if (!is.null(.self$SaveDir)) {      Dir = .self$SaveDir;      if (.self$Verbose > 1) {        print(paste("TBSR5:GenerateAlterWeightCodaList: We're going to pull files from SaveDir = ", Dir, sep=""));          try(print(paste("ListSaveFiles = (", paste(unlist(.self$ListSaveFiles), collapse=", "),           ")", sep=""))); flush.console();         flush.console();      }      MyNFiles = unlist(list.files(Dir));      MyNFiles <- MyNFiles[substr(MyNFiles, 1, nchar(.self$FileName)) ==         .self$FileName];      AlterWeightBuffFiles =   MyNFiles[        substr(MyNFiles, nchar(MyNFiles)-nchar("AWF.bin")+1,         nchar(MyNFiles)) == "AWF.bin"];      if (length(AlterWeightBuffFiles) <= 0) {        print("GenerateAlterWeightCodaList: Error, AlterWeightBuffFiles has zero length!");        return(NULL);      }      if (.self$Verbose > 4) {        print("AlterWeightCodaList: We identified files:  "); flush.console();        print(AlterWeightBuffFiles); flush.console();      }      AlterWeightBuffFiles = paste(Dir, "//", AlterWeightBuffFiles, sep="");    } else if (!is.null(.self$ListSaveFiles)) {      Dir = .self$SaveDir;      LSFiles = unlist(.self$ListSaveFiles);      for (ii in 1:length(LSFiles)) {        if (substr(LSFiles[ii], 1, nchar(Dir)) == Dir) {          LSFiles[ii] = substr(LSFiles[ii], nchar(Dir)+1, nchar(LSFiles[ii]));          AT = unlist(strsplit(LSFiles[ii], "/"))          LSFiles[ii] = AT[length(AT)]        }      }      try(AlterWeightBuffFiles <-  paste(LSFiles,        "AWF.bin", sep="") );      MyListFiles = unlist(list.files(.self$SaveDir));      AlterWeightBuffFiles = AlterWeightBuffFiles[AlterWeightBuffFiles %in% MyListFiles];       if (length(AlterWeightBuffFiles) <= 0) {        print("GenerateAlterWeightCodaList: Error, AlterWeightBuffFiles has zero length!");        return(NULL);      }      if (.self$Verbose > 4) {        print("AlterWeightCodaList: We are seeking files:  "); flush.console();        print(AlterWeightBuffFiles); flush.console();      }      try(AlterWeightBuffFiles <- paste(.self$SaveDir, "//", AlterWeightBuffFiles, sep=""));          }    AlterWeightFiles <- AlterWeightBuffFiles;    .self$.AlterWeightFiles = NULL;    if (length(AlterWeightFiles) > 0) {      ATFList <- list();        if (!is.null(.self$ABayesSpikeCL$TemperatureList) &&          length(.self$ABayesSpikeCL$TemperatureList) > 0) {          for (jj in 1:length(.self$ABayesSpikeCL$TemperatureList)) {            AT <- c();            for (ttC in 1:.self$NumChains) {              AT <- c(AT,                AlterWeightFiles[             substr(AlterWeightFiles, nchar(AlterWeightFiles) -                nchar(paste("T",jj-1,"C", ttC, "AWF.bin", sep=""))+1,               nchar(AlterWeightFiles)) == paste("T",jj-1,"C", ttC, "AWF.bin", sep="")]              )            }            ATFList[[jj]] <- AT;          }        } else {          ATFList[[1]] <- AlterWeightFiles;        }      .self$.AlterWeightCodaList <- list();      for (jtt in 1:length(ATFList)) {        if (length(ATFList) == 1) {          AlterWeightFiles = ATFList[[1]];        } else {          .self$.AlterWeightCodaList[[jtt]] <- list();          AlterWeightFiles = ATFList[[jtt]];        }      if (Verbose >= 3) {        print(paste("DeriveAlterWeightFiles, working on jtt=", jtt, " group. ",          sep="")); flush.console();      }      for (ii in 1:length(AlterWeightFiles)) {        NewCoda = NULL;          if (Verbose > 1) {             print(paste("  Going to GiveCoda SubSet for AlterWeightFiles[", ii, "] = ",              AlterWeightFiles[ii], sep="")); flush.console();          }           MyOA = NULL;           try(MyOA <- file(description = paste(AlterWeightFiles[ii], sep=""),             open = "rb", blocking = TRUE,            encoding = getOption("encoding"), raw = FALSE));          if (is.null(MyOA)) {          } else {            if (!is.null(.self$MBS)) {              try(.self$MBS$TotalR5OpenedFiles <- .self$MBS$TotalR5OpenedFiles+1);            }            MyF = NULL;            try(MyF <- readBin(MyOA, what="double", n = .self$MaxGibbsIters));            try(MyF <- matrix(MyF, length(MyF),1));            try(colnames(MyF) <- "WeightColumn");            if (length(ATFList) == 1)  {              try(.self$.AlterWeightCodaList[[ii]] <- as.mcmc(MyF));               } else {              try(.self$.AlterWeightCodaList[[jtt]][[ii]] <- as.mcmc(MyF));                           }            try(close(MyOA));             if (!is.null(.self$MBS)) {              try(.self$MBS$TotalR5ClosedFiles <- .self$MBS$TotalR5ClosedFiles+1);            }          }                }        if (length(ATFList) == 1) {          try(.self$.AlterWeightCodaList <-             as.mcmc.list(.self$.AlterWeightCodaList));        } else {          try(.self$.AlterWeightCodaList[[jtt]] <-             as.mcmc.list(.self$.AlterWeightCodaList[[jtt]]));              }      }      if (!is.null(.self$ABayesSpikeCL)) {        try(.self$ABayesSpikeCL$DeliberatelySetAlterWeightCodaList(.self$.AlterWeightCodaList));      }      return(.self$.AlterWeightCodaList);    }    return(NULL);  });DICodaClass = setRefClass("DICodaClass",  fields = list(ProbFile="character", ILocFile="character", IFile="character",   DFile="character",  ProbVector = "numeric",  ILocVector = "integer",   IFileVectors = "integer",  IFilePoint ="numeric",  ITotalVector="numeric",  DFileTotalVector="numeric",  DFilePoint="numeric",  DFileVectors="numeric",  TStartLoc = "integer"),  methods=list(    initialize = function(    MBS=NULL, ProbFile="", ProbIFile="", IFile="",    DFile="",DoCurrent = FALSE, ...) {    if (!is.null(MBS)) {      if (!is.null(MBS$OldCodaProbFile) &&        is.character(MBS$OldCodaProbFile) &&        MBS$OldCodaProbFile != "") {        if (DoCurrent == FALSE) {          .self$ProbFile <- MBS$OldCodaProbFile;          } else {          .self$ProbFile <- MBS$CodaProbFile;         }      } else {        .self$ProbFile = ProbFile;      }      if (!is.null(MBS$OldCodaILocFile) &&        is.character(MBS$OldCodaILocFile) &&        MBS$OldCodaILocFile != "") {        if (DoCurrent == FALSE) {          .self$ILocFile <- MBS$OldCodaILocFile;         } else {          .self$ILocFile <- MBS$CodaILocFile;                 }       } else {        .self$ILocFile <- ILocFile;      }        if (!is.null(MBS$CodaOldIFile) &&        is.character(MBS$CodaOldIFile) &&        MBS$CodaOldIFile != "") {        .self$IFile <- MBS$CodaOldIFile;        } else {        .self$IFile <- IFile;      }      if (!is.null(MBS$CodaOldJFile) &&        is.character(MBS$CodaOldJFile) &&        MBS$CodaOldJFile != "") {        .self$DFile <- MBS$CodaOldJFile;        } else {        .self$DFile <- DFile;      }        } else {      .self$ProbFile<- ProbFile;  .self$ILocFile <- ILocFile;      .self$DFile <- DFile;  .self$IFile <- IFile;    }    LL = 10000;    if (!is.null(MBS)) {      LL = MBS$MaxGibbsIters;      if (!is.null(MBS$LengthTempDraws) && MBS$Tempii >= 1) {        LL = MBS$LengthTempDraws[ MBS$Tempii+1-1];      }    }    OProbFile <- file(.self$ProbFile, "rb")  # open an output file connection     if (!is.null(.self$MBS)) {      try(.self$MBS$TotalR5OpenedFiles <- .self$MBS$TotalR5OpenedFiles+1);    }     AReadIn <- readBin(OProbFile, what=double(), n = LL);    .self$ProbVector <- AReadIn; AC = 0; TR = 0;    close(OProbFile);    if (!is.null(.self$MBS)) {      try(.self$MBS$TotalR5ClosedFiles <- .self$MBS$TotalR5ClosedFiles+1);    }        OILocFile <- file(.self$ILocFile, "rb")  # open an output file connection    if (!is.null(.self$MBS)) {      try(.self$MBS$TotalR5OpenedFiles <- .self$MBS$TotalR5OpenedFiles+1);    }    AReadIn <- readBin(OILocFile, what=integer(), n = LL);    .self$ILocVector <- AReadIn;    close(OILocFile);     if (!is.null(.self$MBS)) {      try(.self$MBS$TotalR5ClosedFiles <- .self$MBS$TotalR5ClosedFiles+1);    }      TTLL = .self$ILocVector[length(.self$ILocVector)] + MBS$p;     OIFile <- file(.self$IFile, "rb")  # open an output file connection    if (!is.null(.self$MBS)) {      try(.self$MBS$TotalR5OpenedFiles <- .self$MBS$TotalR5OpenedFiles+1);    }    AReadIn <- readBin(OIFile, what=integer(), n = TTLL);    .self$ITotalVector <- AReadIn;    close(OIFile);    if (!is.null(.self$MBS)) {      try(.self$MBS$TotalR5ClosedFiles <- .self$MBS$TotalR5ClosedFiles+1);    }    ODFile <- file(.self$DFile, "rb")  # open an output file connection    if (!is.null(.self$MBS)) {      try(.self$MBS$TotalR5OpenedFiles <- .self$MBS$TotalR5OpenedFiles+1);    }    AReadIn <- readBin(ODFile, what=double(), n = length(.self$ITotalVector));    .self$DFileTotalVector <- AReadIn;    close(ODFile);    if (!is.null(.self$MBS)) {      try(.self$MBS$TotalR5ClosedFiles <- .self$MBS$TotalR5ClosedFiles+1);    }    tt = 1; DS = 0; OnT = 1;    .self$DVectors = list();    .self$IVectors = list();    .self$IFilePoint = vector("integer", length(.self$ILocVector));    .self$DFilePoint = vector("integer", length(.self$DVectors));    .self$TStartLoc= vector("integer", length(.self$DVectors));    while (tt <= length(.self$ITotalVector)) {      if (abs(round(.self$DFileTotalVector[tt]) - .self$DFileTotalVector[tt]) <= .02) {        DTLen = as.integer(abs(round(.self$DFileTotalVector[tt])));        .self$DVectors[[OnT]] <- .self$DFileTotalVector[(tt+1):(tt+DTLen)];        .self$IVectors[[OnT]] <- .self$ITotalVector[(tt+1):(tt+DTLen)];        if (OnT > length(.self$IFilePoint)) {          .self$IFilePoint = c(.self$IFilePoint, .self$ITotalVector[tt]);          .self$DFilePoint = c(.self$DFilePoint, .self$DFileTotalVector[tt]);          .self$TStartLoc = c(.self$TStartLoc, tt);        } else {          .self$IFilePoint[OnT] = .self$ITotalVector[tt];          .self$DFilePoint[OnT] = .self$DFileTotalVector[tt];            .self$TStartLoc[OnT] = tt;              }        OnT <- OnT+1;        tt <- tt + DTLen;      } else{        tt <- tt+1;      }    }         return(.self);  }));################################################################################ PiAQuantilesBayesSpikeR5$methods(  GeneratePiAQuantiles = function() {    try(library(coda));    if (is.null(.self$.PiACodaList) || length(.self$.PiACodaList) == 0) {      .self$GeneratePiACodaList();    }    if (is.null(.self$.PiACodaList) || length(.self$.PiACodaList) == 0) {      print("GetPiAQuantiles Error, we tried to get a PiACodaList, could not retrieve!");      return(-1);    }    if (.self$ABayesSpikeCL$burnin > 0 &&      .self$ABayesSpikeCL$burnin < NROW(.self$.PiACodaList[[1]]) ) {      ALongPiAMatrix = matrix(0, length(.self$.PiACodaList) *        (NROW(.self$.PiACodaList[[1]]) - .self$ABayesSpikeCL$burnin+1),        NCOL(.self$.PiACodaList[[1]]) );      AOn <- 0;      for (ii in 1:length(.self$.PiACodaList)) {        if (NCOL(.self$.PiACodaList[[1]]) == 1) {          ALongPiAMatrix[AOn +             1:(NROW(.self$.PiACodaList[[1]])             - .self$ABayesSpikeCL$burnin+1),1] <- .self$.PiACodaList[[ii]][            .self$ABayesSpikeCL$burnin:(NROW(.self$.PiACodaList[[ii]]))];                } else {          ALongPiAMatrix[AOn +             1:(NROW(.self$.PiACodaList[[1]])             - .self$ABayesSpikeCL$burnin+1),] <- .self$.PiACodaList[[ii]][            .self$ABayesSpikeCL$burnin:(NROW(.self$.PiACodaList[[ii]])),];        }        AOn <- AOn + (          NROW(.self$.PiACodaList[[1]]) - .self$ABayesSpikeCL$burnin+1);       }    } else {      ALongPiAMatrix = matrix(0, length(.self$.PiACodaList) *        (NROW(.self$.PiACodaList[[1]])) );      AOn <- 0;      for (ii in 1:length(.self$.PiACodaList)) {       if (NCOL(.self$.PiACodaList[[1]]) == 1) {        ALongPiAMatrix[AOn +           1:(length(.self$.PiACodaList[[1]]))] <- .self$.PiACodaList[[ii]][          1:(NROW(.self$.PiACodaList[[ii]]))];              } else {        ALongPiAMatrix[AOn +           1:(length(.self$.PiACodaList[[1]])),] <- .self$.PiACodaList[[ii]][          1:(NROW(.self$.PiACodaList[[ii]])),];       }        AOn <- AOn + (          NROW(.self$.PiACodaList[[1]]));       }    }  try(library(coda));  if (NCOL(ALongPiAMatrix) == 1) {    try(.self$.PiASymmetricQuantiles <-       matrix(quantile(ALongPiAMatrix, .self$.KeepPosteriorQuantiles),      length(.self$.KeepPosteriorQuantiles),1));    try(colnames(.self$.PiASymmetricQuantiles) <-      paste(.self$.KeepPosteriorQuantiles * 100, "%", sep="") );    HPDNeeds <- .self$HPDQuantiles;    HPDGot <- c();   HPDN <- c();    if (.5 %in% .self$.KeepPosteriorQuantiles) {      HPDGot <- quantile(ALongPiAMatrix, .5);      HPDN <- "50%"    }    try(ALongPiAMatrix <- as.mcmc(ALongPiAMatrix));    for (ii in 1:length(HPDNeeds)) {      try(ART <- BayesSpike:::StableHPDinterval(ALongPiAMatrix, prob = HPDNeeds[ii]), silent=TRUE);      try(HPDGot <- c(HPDGot, ART[1:2]));      HPDN <- c(HPDN, paste( c((1-HPDNeeds[ii])/2, 1-(1-HPDNeeds[ii])/2) * 100,      "%", sep=""));    }    try(.self$.PiAHPDQuantiles <- matrix(HPDGot,      length(HPDGot),1) );    try(colnames(.self$.PiAHPDQuantiles) <- HPDN);    return(1);    }  ASQ <- summary(as.mcmc(ALongPiAMatrix), .self$.KeepPosteriorQuantiles);  try(.self$.PiASymmetricQuantiles <- ASQ[[2]]);  try(rownames(.self$.PiASymmetricQuantiles) <- paste("PiA:",     1:NROW(ASQ[[2]]), sep=""));  HPDNeeds <- .self$HPDQuantiles;  HPDGot <- c();  HPDN <- c();  if (.5 %in% .self$.KeepPosteriorQuantiles) {    HPDGot <- ASQ[[2]][,.self$.KeepPosteriorQuantiles == .5]    HPDN <- "50%";  }  try(ALongPiAMatrix <- as.mcmc(ALongPiAMatrix));    for (ii in 1:length(HPDNeeds)) {      try(ART <- BayesSpike:::StableHPDinterval(ALongPiAMatrix, prob = HPDNeeds[ii]), silent=TRUE);      try(HPDGot <- cbind(HPDGot, ART));      HPDN <- c(HPDN, paste( c((1-HPDNeeds[ii])/2, 1-(1-HPDNeeds[ii])/2) * 100,      "%", sep=""));    }  try(.self$.PiAHPDQuantiles <- matrix(HPDGot,      NROW(HPDGot),NCOL(HPDGot) ) );  try(rownames(.self$.PiAHPDQuantiles) <- paste("PiA:", 1:NROW(HPDGot), sep=""));  try(colnames(.self$.PiAHPDQuantiles) <- HPDN);  return(1);    });################################################################################ GenerateBetaQuantilesBayesSpikeR5$methods(  GenerateBetaQuantiles = function() {    try(library(coda));    if (!exists("MaxNCoords")) { MaxNCoords <- 500; }    ABT <- "    MBS = .self$MBS;    eval(parse(text=SetGText(\"MBS\", \"globalenv()\", S=1)));    WeightCodas <- NULL; StackWeightCodas <- NULL;    if (.self$ABayesSpikeCL$DoLogitNonePostPreProb == 1 ||        .self$ABayesSpikeCL$AlterWeightdfTNoise > 0.0 ||        .self$ABayesSpikeCL$AlterWeightdfRobit > 0.0)  {       try(WeightCodas <- .self$ABayesSpikeCL$AlterWeightCodaList)       if (!is.null(WeightCodas)) {         try(StackWeightCodas <- AStackCoda(WeightCodas, .self$MBS$burnin));       }    }    "    try(eval(parse(text=ABT)));    BackSubSetCoords <- .self$SubSetCoords;    ALongBetaMatrix <- NULL;    if (!is.null(.self$MBS) && !is.null(.self$MBS$CodaList) &&      length(.self$MBS$CodaList) >= 1 &&  .self$MBS$DoRecord[1] == 1 &&      NCOL(.self$MBS$CodaList[[1]]) >= .self$p) {      if (.self$Verbose >= 1) {        print("GetBetaQuantiles: Using the Algorithm CodaList");        flush.console();      }      if (sum(abs(.self$MBS$CodaList[[1]])) == 0) {        print("GetBetaQuantiles: Hey, CodaList was never filled, run algorithm!");        flush.console(); return(-1);      }         ALongBetaMatrix <- AStackCoda(.self$ABayesSpikeCL$CodaList, .self$ABayesSpikeCL$burnin, 1:.self$p);      if (.self$Verbose >= 1) {        print("GetBetaQuantiles: Used CodaList, now getting Summaries.");        flush.console();      }    } else if (.self$p < MaxNCoords) {      .self$SubSetCoords <- 1:.self$p       ALongBetaMatrix <- AStackCoda(.self$ABayesSpikeCL$SubCodaList, .self$ABayesSpikeCL$burnin);            }    if (!is.null(ALongBetaMatrix)) {    if (!is.null(StackWeightCodas)) {      if (NROW(StackWeightCodas) != NROW(ALongBetaMatrix)) {        print(paste("GetBetaQuantiles, we have non null StackWeightCodas",          length(StackWeightCodas), ", still, ALongBetaMatrix is length", NROW(ALongBetaMatrix),          sep="")); flush.console();      } else {      SummaryLong <- AlternateWeightSummary(ALongBetaMatrix, StackWeightCodas, burnin = 1, .self$.KeepPosteriorQuantiles);        try(.self$.BetaSymmetricQuantiles <- SummaryLong$MyQuant);      try(.self$.BetaHPDQuantiles <- SummaryLong$MyHPD);       SummaryZero <- AlternateWeightZeroSummary(ALongBetaMatrix, StackWeightCodas, burnin = 1, .self$.KeepPosteriorQuantiles);        try(.self$.BetaSymmetricUnshrinkQuantiles <- SummaryZero$MyQuant);      try(.self$.BetaHPDUnshrinkQuantiles <- SummaryZero$MyHPD);       return(1);      }    } else {      SummaryLong <- TakeSummary(ALongBetaMatrix, burnin = 1, .self$.KeepPosteriorQuantiles);        try(.self$.BetaSymmetricQuantiles <- SummaryLong$MyQuant);      try(.self$.BetaHPDQuantiles <- SummaryLong$MyHPD);       SummaryZero <- TakeSummaryZero(ALongBetaMatrix, burnin = 1, .self$.KeepPosteriorQuantiles);        try(.self$.BetaSymmetricUnshrinkQuantiles <- SummaryZero$MyQuant);      try(.self$.BetaHPDUnshrinkQuantiles <- SummaryZero$MyHPD);       return(1);    }    }  if (.self$MBS$Verbose >= 1) {    print("BayesSpikeR5.r::FillBetaQuantiles: Hardest Way"); flush.console();  }  TBetaSymmetricQuantiles <- matrix(0, .self$p,     length(.self$.KeepPosteriorQuantiles) );  TBetaSymmetricUnshrinkQuantiles <- matrix(0, .self$p,     length(.self$.KeepPosteriorQuantiles) );  HPDNeeds <-  .self$HPDQuantiles;  AK <- 0;  if (.self$MBS$p >= 50000) {      print(paste("GetBetaQuantiles: We must fill hardest way SubSetCoords MaxNCoords = ",         MaxNCoords, " at a time.", sep=""));      flush.console();  }  if (.5 %in% .self$.KeepPosteriorQuantiles) {    LenHPD = length(HPDNeeds) * 2+1;  AK <- 1;  } else { LenHPD = length(HPDNeeds) * 2; }  TBetaHPDQuantiles <- matrix(0, .self$p, LenHPD);  if (.self$p <= 1) {    print(paste("GetBetaQuantiles: why is .self$p = ", .self$p, "?", sep="")); flush.console();  }  if (LenHPD <= 1) {    print(paste("GetBetaQuantiles: why is Len HPD = ", LenHPD, "?", sep="")); flush.console();  }  TBetaHPDUnshrinkQuantiles <- matrix(0, .self$p, LenHPD);  ABOn <- 0;  for (tjt in 1:ceiling(.self$p / MaxNCoords)) {    if (.self$Verbose >= 2 || tjt %% 20 == 0) {      try(print(paste("GetBetaQuantiles: tjt = ", tjt, "/", ceiling(.self$p / MaxNCoords),        "  Doing Coords [", ABOn+1, ":", ABOn+MaxNCoords, "]",        sep="")));      flush.console();      if (tjt >= 2 && ceiling(.self$p / MaxNCoords) >= 20) {        .self$MBS$Verbose = -1;      }    }    NewCoords <- ABOn + 1:MaxNCoords;    NewCoords <- NewCoords[NewCoords <= .self$p];    if (length(NewCoords) <= 0) {      print(paste("ERROR: Issue in GetBetaQuantiles, have p = ", .self$p, ", and ABOn = ",        ABOn, ", what went wrong? ", sep=""));      flush.console();      return(-1);    }    try(.self$SubSetCoords <- as.integer(NewCoords));    try(.self$.SubCodaList <- NULL);    try(.self$ABayesSpikeCL$SubCodaList <- NULL);    LSCL <- .self$LoadSubCodaList(StartIter = 1, EndIter = .self$MaxGibbsIters);    ALongBetaMatrix <- AStackCoda(.self$ABayesSpikeCL$SubCodaList, .self$ABayesSpikeCL$burnin);    ABOn <- ABOn + MaxNCoords;      if (!is.null(StackWeightCodas)) {      if (NROW(StackWeightCodas) != NROW(ALongBetaMatrix)) {        print(paste("GetBetaQuantiles, we have non null StackWeightCodas",          length(StackWeightCodas), ", still, ALongBetaMatrix is length", NROW(ALongBetaMatrix),          sep="")); flush.console();      } else {      SummaryLong <- AlternateWeightSummary(ALongBetaMatrix, StackWeightCodas, burnin = 1, .self$.KeepPosteriorQuantiles);        try(TBetaSymmetricQuantiles[NewCoords,] <- SummaryLong$MyQuant);      try(TBetaHPDQuantiles[NewCoords,] <- SummaryLong$MyHPD);       SummaryZero <- AlternateWeightZeroSummary(ALongBetaMatrix, StackWeightCodas, burnin = 1, .self$.KeepPosteriorQuantiles);        try(TBetaSymmetricUnshrinkQuantiles[NewCoords,] <- SummaryZero$MyQuant);      try(TBetaHPDUnshrinkQuantiles[NewCoords,] <- SummaryZero$MyHPD);      }    } else {      SummaryLong <- TakeSummary(ALongBetaMatrix, burnin = 1, .self$.KeepPosteriorQuantiles);        try(TBetaSymmetricQuantiles[NewCoords,] <- SummaryLong$MyQuant);      try(TBetaHPDQuantiles[NewCoords,] <- SummaryLong$MyHPD);       SummaryZero <- TakeSummaryZero(ALongBetaMatrix, burnin = 1, .self$.KeepPosteriorQuantiles);        try(TBetaSymmetricUnshrinkQuantiles[NewCoords,] <- SummaryZero$MyQuant);      try(TBetaHPDUnshrinkQuantiles[NewCoords,] <- SummaryZero$MyHPD);     }    if (length(NewCoords) >= 1) {      colnames(TBetaSymmetricQuantiles) <- colnames(SummaryLong$MyQuant);      colnames(TBetaHPDQuantiles) <- colnames(SummaryLong$MyHPD);        colnames(TBetaHPDUnshrinkQuantiles) <- colnames(SummaryZero$MyHPD);      colnames(TBetaSymmetricUnshrinkQuantiles) <- colnames(SummaryZero$MyQuant);      }  if (.self$MBS$Verbose >= -1) {    try(print(paste("  TBetaSymmetricQuantiles Calculated for many dimensions, tjt = ",       tjt, sep=""))); flush.console();  }  }  rownames(TBetaSymmetricQuantiles) <- paste("Beta:", 1:.self$p, sep="");  rownames(TBetaHPDQuantiles) <- paste("Beta:", 1:.self$p, sep="");  rownames(TBetaHPDUnshrinkQuantiles) <- paste("Beta:", 1:.self$p, sep="");  rownames(TBetaHPDUnshrinkQuantiles) <- paste("Beta:", 1:.self$p, sep="");         try(.self$.BetaSymmetricQuantiles <- TBetaSymmetricQuantiles);  try(.self$.BetaSymmetricUnshrinkQuantiles <- TBetaSymmetricUnshrinkQuantiles);  try(.self$.BetaHPDQuantiles <- TBetaHPDQuantiles);  try(.self$.BetaHPDUnshrinkQuantiles <- TBetaHPDUnshrinkQuantiles);  if (exists("BackSubSetCoords") && !is.null(BackSubSetCoords) && length(BackSubSetCoords) >= 1) {    try(.self$SubSetCoords <- as.integer(BackSubSetCoords));  }  try(.self$SubCodaList <- NULL);   try(.self$ABayesSpikeCL$SubCodaList <- NULL);  if (.self$Verbose >= 1) {    print("GetBetaQuantiles: All Finished, finished hardest version!");    flush.console();  }  return(1);  });################################################################################ TauQuantiles####  An Altered GetBetaQuantilesBayesSpikeR5$methods(  GenerateTauQuantiles = function() {  WeightCodas <- NULL; StackWeightCodas <- NULL;  if (.self$ABayesSpikeCL$DoLogitNonePostPreProb == 1 ||      .self$ABayesSpikeCL$AlterWeightdfTNoise > 0.0 ||      .self$ABayesSpikeCL$AlterWeightdfRobit > 0.0)  {     try(WeightCodas <- .self$ABayesSpikeCL$AlterWeightCodaList)     if (!is.null(WeightCodas)) {       try(StackWeightCodas <- AStackCoda(WeightCodas, .self$MBS$burnin));     }  }    kGroups = length(.self$sOnTau);    if (!is.null(.self$MBS) && !is.null(.self$MBS$CodaList) &&      length(.self$MBS$CodaList) >= 1 &&  .self$MBS$DoRecord[2] == 1 &&      NCOL(.self$MBS$CodaList[[1]]) >= kGroups ) {      if (.self$MBS$DoRecord[1] == 1) {        StDD <- .self$p;        if (NROW(.self$MBS$CodaList[[1]]) < StDD + kGroups) {          print("GetTauQuantiles: Whoa, not going to work, DoRecord is: ");          print(.self$MBS$DoRecord); flush.console();          print(paste(" However dim CodaList is (",            paste(dim(.self$MBS$CodaList), collapse=", "),            ")", sep=""));          flush.console();          print("Error: Go seek the error!"); flush.console();          return(-1);        }      } else {        StDD <- 0;      }      if (.self$Verbose >= 1) {        print("GetTauQuantiles: Using the Algorithm CodaList");        flush.console();      }      if (sum(abs(.self$MBS$CodaList[[1]])) == 0) {        print("GetBetaQuantiles: Hey, CodaList was never filled, run algorithm!");        flush.console(); return(-1);      }         if (.self$ABayesSpikeCL$burnin > 0 &&        .self$ABayesSpikeCL$burnin < NROW(.self$ABayesSpikeCL$CodaList[[1]]) ) {      ALongTauMatrix = matrix(0, length(.self$ABayesSpikeCL$CodaList) *        (NROW(.self$MBS$CodaList[[1]]) - .self$ABayesSpikeCL$burnin+1),        kGroups  );      AOn <- 0;      for (ii in 1:length(.self$MBS$CodaList)) {        if (kGroups == 1 && NCOL(.self$MBS$CodaList) == 1) {          ALongTauMatrix[AOn +             1:(NROW(.self$ABayesSpikeCL$CodaList[[1]])             - .self$ABayesSpikeCL$burnin+1)] <- .self$ABayesSpikeCL$CodaList[[ii]][           .self$ABayesSpikeCL$burnin:(NROW(.self$ABayesSpikeCL$CodaList[[ii]]))];        } else if (kGroups == 1) {          ALongTauMatrix[AOn +             1:(NROW(.self$ABayesSpikeCL$CodaList[[1]])             - .self$ABayesSpikeCL$burnin+1)] <- .self$ABayesSpikeCL$CodaList[[ii]][           .self$ABayesSpikeCL$burnin:(NROW(.self$ABayesSpikeCL$CodaList[[ii]])), StDD+1];        } else {        ALongTauMatrix[AOn +           1:(NROW(.self$ABayesSpikeCL$CodaList[[1]])           - .self$ABayesSpikeCL$burnin+1),] <- .self$ABayesSpikeCL$CodaList[[ii]][          .self$ABayesSpikeCL$burnin:(NROW(.self$ABayesSpikeCL$CodaList[[ii]])), StDD+1:kGroups];        }        AOn <- AOn + (          NROW(.self$ABayesSpikeCL$CodaList[[1]]) - .self$ABayesSpikeCL$burnin+1);       }    } else {      ALongTauMatrix = matrix(0, length(.self$ABayesSpikeCL$CodaList) *        (NROW(.self$ABayesSpikeCL$CodaList[[1]])), kGroups);      AOn <- 0;      for (ii in 1:length(.self$ABayesSpikeCL$CodaList)) {        if (kGroups == 1 && NCOL(.self$ABayesSpikeCL$CodaList[[ii]]) == 1) {         ALongTauMatrix[AOn +           1:(length(.self$ABayesSpikeCL$CodaList[[1]]))] <- .self$ABayesSpikeCL$CodaList[[ii]][          1:(NROW(.self$ABayesSpikeCL$CodaList[[ii]]))];        } else if (kGroups == 1) {         ALongTauMatrix[AOn +           1:(length(.self$ABayesSpikeCL$CodaList[[1]]))] <- .self$ABayesSpikeCL$CodaList[[ii]][          1:(NROW(.self$ABayesSpikeCL$CodaList[[ii]])), StDD+1];        } else {         ALongTauMatrix[AOn +           1:(length(.self$ABayesSpikeCL$CodaList[[1]])),] <- .self$ABayesSpikeCL$CodaList[[ii]][          1:(NROW(.self$ABayesSpikeCL$CodaList[[ii]])), StDD+1:.kGroups];        }        AOn <- AOn + (          NROW(.self$ABayesSpikeCL$CodaList[[1]]));       }    }    if (.self$Verbose >= 1) {      print("GetTauQuantiles: Used CodaList, now getting Summaries.");      flush.console();    }    ASQ <- summary(as.mcmc(ALongTauMatrix), .self$.KeepPosteriorQuantiles);    try(.self$.TauSymmetricQuantiles <- ASQ[[2]]);    try(rownames(.self$.TauSymmetricQuantiles) <- paste("tau:",      1:kGroups));    HPDNeeds <- .self$HPDQuantiles;    HPDGot <- c();   HPDN <- c();    if (.5 %in% .self$.KeepPosteriorQuantiles) {      HPDGot <- ASQ[[2]][, .5 == .self$.KeepPosteriorQuantiles];      HPDN <- "50%";    }    try(ALongTauMatrix <- as.mcmc(ALongTauMatrix));    for (ii in 1:length(HPDNeeds)) {      try(ART <- BayesSpike:::StableHPDinterval(ALongTauMatrix, prob = HPDNeeds[ii]), silent=TRUE);      try(HPDGot <- cbind(HPDGot, ART));      HPDN <- c(HPDN, paste( c((1-HPDNeeds[ii])/2, 1-(1-HPDNeeds[ii])/2) * 100,      "%", sep="") );    }    try(.self$.TauHPDQuantiles <- matrix(HPDGot,      NROW(HPDGot),NCOL(HPDGot) ) );    try(rownames(.self$.TauHPDQuantiles) <- paste("tau:",       1:kGroups, sep=""));    try(colnames(.self$.TauHPDQuantiles) <- HPDN);    if (.self$Verbose >= 1) {      print("GetTauQuantiles: All Finished with CodaList Version.");      flush.console();    }    return(1);     }  kGroups <- length(.self$sOnTau);  if (!is.null(.self$MBS) && !is.null(.self$MBS$TauCodaList) &&      length(.self$MBS$TauCodaList) >= 1 &&       NCOL(.self$MBS$TauCodaList[[1]]) >= kGroups) {      if (.self$Verbose >= 1) {        print("GetTauaQuantiles: Apparently SubSetCoords allready filled!");        flush.console();      }      if (sum(abs(.self$MBS$TauCodaList[[1]])) == 0) {        print("GetTauQuantiles: Hey, CodaList was never filled, run algorithm!");        flush.console(); return(-1);      }        if (length(.self$MBS$TauCodaList)  == 1) {         if (.self$ABayesSpikeCL$burnin > 0 &&          .self$ABayesSpikeCL$burnin < NROW(.self$ABayesSpikeCL$TauCodaList[[1]]) )  {           if (kGroups == 1) {            ALongTauMatrix = .self$ABayesSpikeCL$TauCodaList[[1]][              .self$MBS$burnin:NROW(.self$ABayesSpikeCL$TauCodaList[[1]])]            } else {            ALongTauMatrix = .self$ABayesSpikeCL$TauCodaList[[1]][              .self$MBS$burnin:NROW(.self$ABayesSpikeCL$TauCodaList[[1]]), 1:kGroups]            }         } else {           if (kGroups == 1) {            ALongTauMatrix = .self$ABayesSpikeCL$TauCodaList[[1]];           } else {            ALongTauMatrix = .self$ABayesSpikeCL$TauCodaList[[1]][,1:kGroups];           }         }      } else if (.self$ABayesSpikeCL$burnin > 0 &&        .self$ABayesSpikeCL$burnin < NROW(.self$ABayesSpikeCL$TauCodaList[[1]]) ) {      ALongTauMatrix = matrix(0, length(.self$ABayesSpikeCL$TauCodaList) *        (NROW(.self$MBS$SubCodaList[[1]]) - .self$ABayesSpikeCL$burnin+1),        kGroups );      AOn <- 0;      for (ii in 1:length(.self$MBS$TauCodaList)) {        if (kGroups == 1) {         ALongTauMatrix[AOn +            1:(NROW(.self$ABayesSpikeCL$TauCodaList[[1]])            - .self$ABayesSpikeCL$burnin+1),] <- .self$ABayesSpikeCL$TauCodaList[[ii]][           .self$ABayesSpikeCL$burnin:(NROW(.self$ABayesSpikeCL$TauCodaList[[ii]]))];          } else {         ALongTauMatrix[AOn +            1:(NROW(.self$ABayesSpikeCL$TauCodaList[[1]])            - .self$ABayesSpikeCL$burnin+1),] <- .self$ABayesSpikeCL$TauCodaList[[ii]][           .self$ABayesSpikeCL$burnin:(NROW(.self$ABayesSpikeCL$TauCodaList[[ii]])),1:kGroups];        }        AOn <- AOn + (          NROW(.self$ABayesSpikeCL$TauCodaList[[1]]) - .self$ABayesSpikeCL$burnin+1);       }    } else {      ALongTauMatrix = matrix(0, length(.self$ABayesSpikeCL$TauCodaList) *        (NROW(.self$ABayesSpikeCL$TauCodaList[[1]])) );      AOn <- 0;      for (ii in 1:length(.self$ABayesSpikeCL$TauCodaList)) {        if (kGroups == 1) {         ALongTauMatrix[AOn +           1:(length(.self$ABayesSpikeCL$TauCodaList[[1]])),] <- .self$ABayesSpikeCL$TauCodaList[[ii]][          1:(NROW(.self$ABayesSpikeCL$TauCodaList[[ii]]))];                } else {         ALongTauMatrix[AOn +           1:(length(.self$ABayesSpikeCL$TauCodaList[[1]])),] <- .self$ABayesSpikeCL$TauCodaList[[ii]][          1:(NROW(.self$ABayesSpikeCL$TauCodaList[[ii]])),1:kGroups];                }        AOn <- AOn + (          NROW(.self$ABayesSpikeCL$TauCodaList[[1]]));       }    }    if (.self$Verbose >= 1) {      print("GetTauQuantiles: Finished filling given given TauCodaList");      flush.console();    }    ASQ <- summary(as.mcmc(ALongTauMatrix), .self$.KeepPosteriorQuantiles);    try(.self$.TauSymmetricQuantiles <- ASQ[[2]]);    try(colnames(.self$.TauSymmetricQuantiles) <-      paste("tau:", 1:kGroups, sep=""));    HPDNeeds <- .self$HPDQuantiles;    HPDGot <- c(); HPDN <- c();    if (.5 %in% .self$.KeepPosteriorQuantiles) {      HPDGot <- ASQ[[2]][,.5 == .self$.KeepPosteriorQuantiles]      HPDN <- "50%";    }    try(ALongTauMatrix <- as.mcmc(ALongTauMatrix));    for (ii in 1:length(HPDNeeds)) {      try(ART <- BayesSpike:::StableHPDinterval(ALongTauMatrix, prob = HPDNeeds[ii]), silent=TRUE);      try(HPDGot <- cbind(HPDGot, ART));      HPDN <- c(HPDN, paste( c((1-HPDNeeds[ii])/2, 1-(1-HPDNeeds[ii])/2) * 100,      "%", sep="") );    }    try(.self$.TauHPDQuantiles <- matrix(HPDGot,      NROW(HPDGot),NCOL(HPDGot) ) );    try(rownames(.self$.TauHPDQuantiles) <-      paste("tau:", 1:kGroups, sep=""));    try(colnames(.self$.TauHPDQuantiles) <- HPDN);    if (.self$Verbose >= 1) {      print("GetTauQuantiles: Finished with prefilled TauCodaList.");      flush.console();    }    return(1);     }  BackSubSetTau <- .self$SubSetTau;  MaxNCoords <- 200;  if (kGroups <= MaxNCoords) {    if (.self$Verbose >= 1) {      print("GetTauQuantiles: Filling by pulling up SubSetTau all at once");      flush.console();    }    try(.self$SubSetTau <- 1:kGroups);    ##try(.self$ABayesSpikeCL$SubSetTau <- .self$.SubSetTau);    try(.self$TauCodaList <- NULL);    try(.self$ABayesSpikeCL$TauCodaList <- NULL);    .self$GenerateTauCodaList(StartIter = .self$ABayesSpikeCL$burnin, EndIter = .self$MaxGibbsIters);    if (length(.self$TauCodaList) == 1) {      ALongTauMatrix = matrix(.self$TauCodaList[[1]],        NROW(.self$TauCodaList[[1]]), NCOL(.self$TauCodaList));    } else {      ALongTauMatrix = matrix(0, NROW(.self$TauCodaList[[1]])*length(.self$TauCodaList),        NCOL(.self$TauCodaList[[1]]));      AOn <- 0;      for (ii in 1:length(.self$TauCodaList)) {        if (kGroups == 1) {         ALongTauMatrix[AOn+1:NROW(.self$TauCodaList[[1]])] <-           .self$TauCodaList[[1]];                } else {        ALongTauMatrix[AOn+1:NROW(.self$TauCodaList[[1]]),1:kGroups] <-          .self$TauCodaList[[1]];        }        AOn <- AOn + NROW(.self$TauCodaList[[1]]);      }    }    ASQ <- summary(as.mcmc(ALongTauMatrix), .self$.KeepPosteriorQuantiles);    try(.self$.TauSymmetricQuantiles <- ASQ[[2]]);    try(rownames(.self$.TauSymmetricQuantiles) <-       paste("tau:", 1:kGroups, sep=""));    HPDNeeds <- .self$HPDQuantiles;    HPDGot <- c();    HPDN = c();    if (.5 %in% .self$.KeepPosteriorQuantiles) {      HPDGot <- ASQ[[2]][, .5 == .self$.KeepPosteriorQuantiles];      HPDN <- "50%";    }    try(ALongTauMatrix <- as.mcmc(ALongTauMatrix));    for (ii in 1:length(HPDNeeds)) {      try(ART <- BayesSpike:::StableHPDinterval(ALongTauMatrix, prob = HPDNeeds[ii]), silent=TRUE);      try(HPDGot <- cbind(HPDGot, ART));      HPDN <- c(HPDN,paste( c((1-HPDNeeds[ii])/2, 1-(1-HPDNeeds[ii])/2) * 100,      "%", sep="") );    }    try(.self$.TauHPDQuantiles <- matrix(HPDGot,      NROW(HPDGot),NCOL(HPDGot) ) );    try(rownames(.self$.TauHPDQuantiles) <- paste("tau:", 1:kGroups, sep=""));    try(colnames(.self$.TauHPDQuantiles) <- HPDN);    try(.self$TauCodaList <- NULL);    try(.self$MBS$TauCodaList <- NULL);    try(.self$SubSetTau <- BackSubSetTau);    ##try(.self$MBS$SubSetTau <- BackSubSetTau);    return(1);  }  if (.self$Verbose >= 1) {    print("GetTauQuantiles: Going to fill the hardest way.");    flush.console();  }  TTauSymmetricQuantiles <- matrix(0, kGroups,     length(.self$.KeepPosteriorQuantiles) );  HPDNeeds <-  .self$HPDQuantiles;  if (.5 %in% .self$.KeepPosteriorQuantiles) {    LenHPD <- 1 + length(HPDNeeds)*2;  } else {    LenHPD <- length(HPDNeeds) *2;  }  TTauHPDQuantiles <- matrix(0, kGroups, LenHPD);  ABOn <- 0;  for (tjt in 1:ceiling( kGroups / MaxNCoords)) {    if (.self$Verbose >= 2) {      print(paste("GetTauQuantiles: On Coords ", ABOn+1, ":", ABOn+MaxNCoords,        sep=""));      flush.console();    }    NewCoords <- ABOn + 1:MaxNCoords;    NewCoords <- NewCoords[NewCoords <= kGroups];    if (length(NewCoords) <= 0) {      print(paste("ERROR: Issue in GetTauQuantiles, have kGroups = ", kGroups, ", and ABOn = ",        ABOn, ", what went wrong? ", sep=""));      flush.console();      return(-1);    }    try(.self$SubSetTau <- NewCoords);    ##try(.self$ABayesSpikeCL$SubSetTau <- NewCoords);    try(.self$.TauCodaList <- NULL);    try(.self$ABayesSpikeCL$TauCodaList <- NULL);    .self$GenerateTauCodaList(StartIter = .self$ABayesSpikeCL$burnin, EndIter = .self$MaxGibbsIters);    if (length(.self$TauCodaList) == 1) {      ALongTauMatrix = matrix(.self$TauCodaList[[1]],        NROW(.self$TauCodaList[[1]]), NCOL(.self$TauCodaList));    } else {      ALongTauMatrix = matrix(0, NROW(.self$TauCodaList[[1]])*length(.self$TauCodaList),        NCOL(.self$TauCodaList[[1]]));      AOn <- 0;      for (ii in 1:length(.self$TauCodaList)) {        if (length(NewCoords) == 1) {          ALongTauMatrix[AOn+1:NROW(.self$.TauCodaList[[1]])] <-           .self$TauCodaList[[1]];                } else {          ALongTauMatrix[AOn+1:NROW(.self$.TauCodaList[[1]]),1:length(NewCoords)] <-           .self$TauCodaList[[1]];        }        AOn <- AOn + NROW(.self$TauCodaList[[1]]);      }    }    ABOn <- ABOn + MaxNCoords;    ASQ <- summary(as.mcmc(ALongTauMatrix), .self$.KeepPosteriorQuantiles);    try(TTauSymmetricQuantiles[NewCoords,] <- ASQ[[2]]);    try(rownames(TTauSymmetricQuantiles) <- paste("tau:", 1:kGroups, sep=""));    HPDNeeds <- .self$HPDQuantiles;    HPDGot <- c();   HPDN <- c();    if (.5 %in% .self$.KeepPosteriorQuantiles) {      HPDGot <- ASQ[[2]][,.5 == .self$.KeepPosteriorQuantiles];      HPDN <- "50%"    }    try(ALongTauMatrix <- as.mcmc(ALongTauMatrix));    for (ii in 1:length(HPDNeeds)) {      try(ART <- BayesSpike:::StableHPDinterval(ALongTauMatrix, prob = HPDNeeds[ii]), silent=TRUE);      try(HPDGot <- cbind(HPDGot, ART));      HPDN <- c(HPDN, paste( c((1-HPDNeeds[ii])/2, 1-(1-HPDNeeds[ii])/2) * 100,      "%", sep="") );    }    try(TTauHPDQuantiles[NewCoords,] <- matrix(HPDGot,      NROW(HPDGot),NCOL(HPDGot) ) );    try(rownames(TTauHPDQuantiles) <- paste("tau:", 1:kGroups, sep=""));    try(colnames(TTauHPDQuantiles) <- HPDN);  }   try(.self$.TauSymmetricQuantiles <- TTauSymmetricQuantiles);  try(.self$.TauHPDQuantiles <- TTauHPDQuantiles);  try(.self$SubSetTau <- BackSubSetTau);  ##try(.self$ABayesSpikeCL$SubSetTau <- BackSubSetTau);  try(.self$.TauCodaList <- NULL);   try(.self$ABayesSpikeCL$TauCodaList <- NULL);  if (.self$Verbose >= 1) {    print("GetTauQuantiles: All Finished, finished hardest version!");    flush.console();  }  return(1);  });################################################################################ GenerateBetaLongQuantilesBayesSpikeR5$methods(  GenerateBetaLongQuantiles = function() {  try(library(coda));  if (.self$DoLongCI == FALSE) {    print("GenerateBetaLongQuantiles: No can do, DoLongCI was FALSE!");    flush.console();    return(-1);  }  try(BackSubSetCoords <- .self$SubSetCoords);    try(library(coda));    if (!exists("MaxNCoords")) { MaxNCoords <- 500; }    ABT <- "    MBS = .self$MBS;    eval(parse(text=SetGText(\"MBS\", \"globalenv()\", S=1)));    WeightCodas <- NULL; StackWeightCodas <- NULL;    if (.self$ABayesSpikeCL$DoLogitNonePostPreProb == 1 ||        .self$ABayesSpikeCL$AlterWeightdfTNoise > 0.0 ||        .self$ABayesSpikeCL$AlterWeightdfRobit > 0.0)  {       try(WeightCodas <- .self$ABayesSpikeCL$AlterWeightCodaList)       if (!is.null(WeightCodas)) {         try(StackWeightCodas <- AStackCoda(WeightCodas, .self$MBS$burnin));       }    }    "    try(eval(parse(text=ABT)));    ALongBetaMatrix <- NULL;    if (.self$p < MaxNCoords) {      .self$SubSetCoords <- 1:.self$p       ALongBetaMatrix <- AStackCoda(.self$ABayesSpikeCL$SubCodaLongList, .self$ABayesSpikeCL$burnin);            }    if (!is.null(ALongBetaMatrix)) {    if (!is.null(StackWeightCodas)) {      if (NROW(StackWeightCodas) != NROW(ALongBetaMatrix)) {        print(paste("GetBetaQuantiles, we have non null StackWeightCodas",          length(StackWeightCodas), ", still, ALongBetaMatrix is length", NROW(ALongBetaMatrix),          sep="")); flush.console();      } else {      SummaryLong <- AlternateWeightSummary(ALongBetaMatrix, StackWeightCodas, burnin = 1, .self$.KeepPosteriorQuantiles);        try(.self$.BetaSymmetricLongQuantiles <- SummaryLong$MyQuant);      try(.self$.BetaHPDLongQuantiles <- SummaryLong$MyHPD);       return(1);      }    } else {      SummaryLong <- TakeSummary(ALongBetaMatrix, burnin = 1, .self$.KeepPosteriorQuantiles);        try(.self$.BetaSymmetricLongQuantiles <- SummaryLong$MyQuant);      try(.self$.BetaHPDLongQuantiles <- SummaryLong$MyHPD);       return(1);    }    }   if (exists("BackSubSetCoords") && !is.null(BackSubSetCoords) && length(BackSubSetCoords) >= 1) {    try(BackSubSetCoords <- .self$SubSetCoords);   }  if (.self$Verbose >= 1) {    print("GetBetaLongQuantiles: Going to fill the hardest way.");    flush.console();  }  TBetaSymmetricLongQuantiles <- matrix(0, .self$p,     length(.self$.KeepPosteriorQuantiles) );  HPDNeeds <-  .self$HPDQuantiles;  AK <- 0;  if (.5 %in% .self$.KeepPosteriorQuantiles) {    LenHPD = length(HPDNeeds) * 2+1;  AK <- 1;  } else { LenHPD = length(HPDNeeds) * 2; }  TBetaHPDLongQuantiles <- matrix(0, .self$p, LenHPD);  ABOn <- 0;  ABOn <- 0;  for (tjt in 1:ceiling(.self$p / MaxNCoords)) {    if (.self$Verbose >= 2 || tjt %% 20 == 0) {      try(print(paste("GetBetaQuantiles: tjt = ", tjt, "/", ceiling(.self$p / MaxNCoords),        "  Doing Coords [", ABOn+1, ":", ABOn+MaxNCoords, "]",        sep="")));      flush.console();      if (tjt >= 2 && ceiling(.self$p / MaxNCoords) >= 20) {        .self$MBS$Verbose = -1;      }    }    NewCoords <- ABOn + 1:MaxNCoords;    NewCoords <- NewCoords[NewCoords <= .self$p];    if (length(NewCoords) <= 0) {      print(paste("ERROR: Issue in GetBetaQuantiles, have p = ", .self$p, ", and ABOn = ",        ABOn, ", what went wrong? ", sep=""));      flush.console();      return(-1);    }    try(.self$SubSetCoords <- as.integer(NewCoords));    try(.self$SubCodaLongList <- NULL);    try(.self$ABayesSpikeCL$SubCodaLongList <- NULL);    Loaded <- .self$LoadSubCodaLongList(StartIter = 0, EndIter = .self$MaxGibbsIters);    ALongBetaMatrix <- AStackCoda(.self$MBS$SubCodaLongList, .self$ABayesSpikeCL$burnin)    ABOn <- ABOn + MaxNCoords;    if (!is.null(StackWeightCodas)) {      if (NROW(StackWeightCodas) != NROW(ALongBetaMatrix)) {        print(paste("GetBetaQuantiles, we have non null StackWeightCodas",          length(StackWeightCodas), ", still, ALongBetaMatrix is length", NROW(ALongBetaMatrix),          sep="")); flush.console();      } else {      SummaryLong <- AlternateWeightSummary(ALongBetaMatrix, StackWeightCodas, burnin = 1, .self$.KeepPosteriorQuantiles);        try(TBetaSymmetricLongQuantiles[NewCoords,] <- SummaryLong$MyQuant);      try(TBetaHPDLongQuantiles[NewCoords,] <- SummaryLong$MyHPD);       }    } else {      SummaryLong <- TakeSummary(ALongBetaMatrix, burnin = 1, .self$.KeepPosteriorQuantiles);        try(TBetaSymmetricLongQuantiles[NewCoords,] <- SummaryLong$MyQuant);      try(TBetaHPDLongQuantiles[NewCoords,] <- SummaryLong$MyHPD);     }    if (length(NewCoords) >= 1) {      colnames(TBetaSymmetricLongQuantiles) <- colnames(SummaryLong$MyQuant);      colnames(TBetaHPDLongQuantiles) <- colnames(SummaryLong$MyHPD);       }  if (.self$MBS$Verbose >= -1) {    try(print(paste("  TBetaSymmetricQuantiles Calculated for many dimensions, tjt = ",       tjt, sep=""))); flush.console();  }  }  rownames(TBetaSymmetricLongQuantiles) <- paste("Beta:", 1:.self$p, sep="");  rownames(TBetaHPDLongQuantiles) <- paste("Beta:", 1:.self$p, sep="");     try(.self$.BetaSymmetricLongQuantiles <- TBetaSymmetricLongQuantiles);  try(.self$.BetaHPDLongQuantiles <- TBetaHPDLongQuantiles);  try(.self$SubSetCoords <- BackSubSetCoords);  try(.self$SubCodaLongList <- NULL);   try(.self$ABayesSpikeCL$SubCodaLongList <- NULL);  if (.self$Verbose >= 1) {    print("GetBetaLongQuantiles: All Finished, finished hardest version!");    flush.console();  }  return(1);  });